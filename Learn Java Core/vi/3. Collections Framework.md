### **Bài 1: Tổng quan về Java Collections Framework**

#### **1. Giải thích khái niệm**

##### **Java Collections Framework (JCF) là gì?**
Java Collections Framework là một kiến trúc hợp nhất để biểu diễn và thao tác các collection object. Nó là một tập hợp các interface và class được thiết kế để cung cấp các cấu trúc dữ liệu hiệu suất cao, có thể tái sử dụng. Trước khi có JCF, các lập trình viên Java phải dựa vào các array, `Vector`, và `Hashtable`, những thứ không phải là một phần của một framework mạch lạc. JCF đã giới thiệu một cách tiêu chuẩn hóa để xử lý các nhóm object.

**Mục tiêu cốt lõi của JCF:**
*   **Giảm nỗ lực lập trình:** Cung cấp các cấu trúc dữ liệu tiêu chuẩn, có thể tái sử dụng để bạn không phải tự viết chúng từ đầu.
*   **Tăng hiệu suất:** Cung cấp các triển khai hiệu suất cao của các cấu trúc dữ liệu phổ biến.
*   **Thúc đẩy khả năng tương tác:** Thiết lập một ngôn ngữ chung để truyền các collection giữa các phần khác nhau của một API.
*   **Nuôi dưỡng tái sử dụng phần mềm:** Khuyến khích việc tạo ra các thuật toán có thể hoạt động trên bất kỳ collection nào triển khai một interface cụ thể.

##### **Arrays vs. Collections**
| Tính năng | Arrays | Collections |
| :--- | :--- | :--- |
| **Kích thước** | Kích thước cố định, được khai báo khi khởi tạo. Không thể tăng hoặc giảm. | Kích thước động. Có thể tăng và giảm trong thời gian chạy. |
| **Kiểu dữ liệu** | Có thể chứa cả primitive và object. | Chỉ có thể chứa object (các primitive được tự động boxing). |
| **Hiệu suất** | Thường nhanh hơn cho việc truy cập phần tử với chỉ số đã biết (`arr[i]`). | Hiệu suất thay đổi theo từng triển khai (`ArrayList` nhanh cho truy cập theo chỉ số, `LinkedList` thì không). |
| **Chức năng** | Các method tích hợp sẵn bị hạn chế. | Tập hợp phong phú các method để tìm kiếm, sắp xếp, chèn, xóa, v.v. |
| **Hệ thống phân cấp** | Không phải là một phần của JCF. `Object` là superclass trực tiếp. | Là một phần của một hệ thống phân cấp interface được xác định rõ ràng (`List`, `Set`, `Queue`, v.v.). |

##### **Các hệ thống phân cấp cốt lõi**
JCF được xây dựng xung quanh hai hệ thống phân cấp interface chính: `java.util.Collection` và `java.util.Map`. Điều quan trọng cần hiểu là **`Map` không kế thừa từ `Collection`**. Một `Collection` đại diện cho một nhóm các phần tử riêng lẻ, trong khi một `Map` đại diện cho một nhóm các cặp key-value.

**1. Hệ thống phân cấp `Collection`:**
Đây là interface gốc cho các cấu trúc dữ liệu lưu trữ các phần tử đơn lẻ.

```
                  +---------------+
                  |   Iterable    |  <- Gốc cuối cùng, cung cấp các iterator
                  +---------------+
                         ^
                         | (extends)
                  +---------------+
                  |  Collection   |  <- add(), remove(), contains(), size()
                  +---------------+
                         ^
                         |
           +-------------+-------------+
           |             |             |
     +-----------+ +-----------+ +-----------+
     |   List    | |    Set    | |   Queue   |  <- Các sub-interface cốt lõi
     +-----------+ +-----------+ +-----------+
```

*   **`Iterable<E>`:** Super-interface cho toàn bộ hệ thống phân cấp `Collection`. Method trừu tượng duy nhất của nó, `iterator()`, cung cấp một `Iterator` cho phép bạn lặp qua các phần tử. Bất kỳ lớp nào triển khai `Iterable` đều có thể được sử dụng trong một vòng lặp `for-each` nâng cao.
*   **`Collection<E>`:** Nền tảng. Định nghĩa các method cốt lõi cho tất cả các collection, chẳng hạn như `add(E e)`, `remove(Object o)`, `contains(Object o)`, `size()`, `isEmpty()`, và `clear()`.
*   **`List<E>`:** Một collection **có thứ tự** (một chuỗi) cho phép các phần tử **trùng lặp**. Bạn có thể truy cập các phần tử bằng chỉ số số nguyên của chúng.
*   **`Set<E>`:** Một collection **không chứa phần tử trùng lặp**. Nó mô hình hóa sự trừu tượng của tập hợp toán học.
*   **`Queue<E>`:** Một collection được sử dụng để chứa các phần tử trước khi xử lý. Ngoài các hoạt động `Collection` cơ bản, queue cung cấp các hoạt động chèn, trích xuất và kiểm tra bổ sung, thường theo kiểu **FIFO (First-In, First-Out)**.

**2. Hệ thống phân cấp `Map`:**
Interface này dành cho các cấu trúc dữ liệu ánh xạ các key đến các value. Các key phải là duy nhất.

```
                  +-----------+
                  |    Map    |  <- put(K,V), get(K), remove(K), keySet()
                  +-----------+
```
*   **`Map<K, V>`:** Một object ánh xạ các key đến các value. Một map không thể chứa các key trùng lặp; mỗi key có thể ánh xạ đến tối đa một value. Nó cung cấp ba "collection views," cho phép nội dung của một map được xem như một `Set` các key, `Collection` các value, hoặc `Set` các ánh xạ key-value.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa việc sử dụng cơ bản của ba loại collection chính và một map, làm nổi bật các đặc điểm chính của chúng.

```java
import java.util.*;

public class FrameworkOverview {
    public static void main(String[] args) {
        // 1. List: Có thứ tự, cho phép trùng lặp
        List<String> userList = new ArrayList<>();
        userList.add("Alice");
        userList.add("Bob");
        userList.add("Alice"); // Trùng lặp được phép
        System.out.println("List of users: " + userList);
        System.out.println("Second user: " + userList.get(1)); // Truy cập bằng chỉ số

        // 2. Set: Không có thứ tự, các phần tử duy nhất
        Set<String> uniqueUsers = new HashSet<>();
        uniqueUsers.add("Alice");
        uniqueUsers.add("Bob");
        uniqueUsers.add("Alice"); // Trùng lặp bị bỏ qua
        System.out.println("Set of unique users: " + uniqueUsers);

        // 3. Map: Cặp key-value, các key duy nhất
        Map<String, Integer> userScores = new HashMap<>();
        userScores.put("Alice", 100);
        userScores.put("Bob", 95);
        userScores.put("Alice", 105); // Thay thế giá trị trước đó cho "Alice"
        System.out.println("Map of user scores: " + userScores);
        System.out.println("Alice's score: " + userScores.get("Alice")); // Truy cập bằng key

        // Sử dụng Iterable với vòng lặp for-each
        System.out.print("Iterating through the list: ");
        for (String user : userList) {
            System.out.print(user + " ");
        }
        System.out.println();
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một `List` các số nguyên và thêm các số `10, 20, 30, 20, 10`. In danh sách ra.
2.  Tạo một `Set` các số nguyên và thêm các số tương tự (`10, 20, 30, 20, 10`) vào đó. In tập hợp ra.
3.  Quan sát và giải thích sự khác biệt trong đầu ra giữa `List` và `Set`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào sau đây là đúng về Java Collections Framework?

A) Interface `Map` kế thừa từ interface `Collection`.
B) Một `List` không thể chứa các phần tử trùng lặp.
C) Interface `Iterable` là gốc của hệ thống phân cấp `Map`.
D) Interface `Set` đảm bảo rằng nó không chứa các phần tử trùng lặp.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Interface `Set` đảm bảo rằng nó không chứa các phần tử trùng lặp. Đây là đặc điểm xác định của một `Set`.

### **Bài 2: Interface `List` - `ArrayList` vs. `LinkedList`**

#### **1. Giải thích khái niệm**

Interface `List` đại diện cho một chuỗi các phần tử có thứ tự. Không giống như `Set`, một `List` cho phép các phần tử trùng lặp. Hai tính năng quan trọng nhất của một `List` là:
1.  **Truy cập theo vị trí (Positional Access):** Các phần tử có thể được truy cập, chèn hoặc xóa dựa trên chỉ số số nguyên của chúng (vị trí).
2.  **Có thứ tự (Ordered):** Nó duy trì thứ tự chèn của các phần tử.

Hai triển khai `List` đa năng chính là `ArrayList` và `LinkedList`. Lựa chọn giữa chúng là một quyết định quan trọng về hiệu suất dựa trên trường hợp sử dụng của bạn.

##### **`ArrayList` - Mảng có thể thay đổi kích thước**

*   **Cấu trúc nội bộ:** Một `ArrayList` được hỗ trợ bởi một **mảng động** (một array có thể tăng kích thước). Nó lưu trữ trực tiếp các phần tử trong một khối bộ nhớ liền kề. Nó cũng duy trì một trường `size` để theo dõi có bao nhiêu phần tử thực sự có trong danh sách.
    ```
    // Nội bộ ArrayList
    Object[] elementData; // Mảng hỗ trợ
    int size;             // Số lượng phần tử hiện tại trong danh sách
    ```
*   **Thay đổi kích thước (Resizing):** Khi bạn thêm một phần tử và mảng nội bộ đã đầy, `ArrayList` tạo ra một **mảng mới, lớn hơn** (thường gấp 1,5 lần kích thước cũ), sao chép tất cả các phần tử từ mảng cũ sang mảng mới, và sau đó thêm phần tử mới. Thao tác thay đổi kích thước này là một quá trình O(n), có thể chậm nếu nó xảy ra thường xuyên. Bạn có thể cấp phát trước dung lượng trong constructor (`new ArrayList<>(initialCapacity)`) để tránh điều này.

*   **Độ phức tạp thời gian (Time Complexity):**
    *   **`get(int index)`:** O(1) - Cực kỳ nhanh. Vì nó là một array, nó có thể tính toán độ lệch bộ nhớ và nhảy trực tiếp đến phần tử.
    *   **`add(E element)` (ở cuối):** O(1) được khấu hao (Amortized O(1)). Nó là O(1) trung bình, nhưng trở thành O(n) khi cần thay đổi kích thước.
    *   **`add(int index, E element)` (ở giữa):** O(n). Tất cả các phần tử từ chỉ số đó trở đi phải được dịch sang phải để tạo không gian.
    *   **`remove(int index)` (ở giữa):** O(n). Tất cả các phần tử sau chỉ số đó phải được dịch sang trái để lấp đầy khoảng trống.

*   **Trường hợp sử dụng tốt nhất:** Tuyệt vời cho các tình huống bạn có một khối lượng lớn **thao tác đọc** (truy cập ngẫu nhiên theo chỉ số) và ít thao tác chèn/xóa ở giữa danh sách. Đây là triển khai `List` được sử dụng phổ biến nhất.

##### **`LinkedList` - Chuỗi các Node**

*   **Cấu trúc nội bộ:** Một `LinkedList` là một **danh sách liên kết đôi**. Nó không lưu trữ các phần tử trong bộ nhớ liền kề. Thay vào đó, mỗi phần tử được bao bọc trong một object `Node`. Mỗi `Node` chứa ba mẩu thông tin: chính phần tử đó, một con trỏ đến `Node` trước đó, và một con trỏ đến `Node` tiếp theo.
    ```
    // Nội bộ Node của LinkedList
    class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
    }
    // LinkedList giữ các con trỏ đến node đầu tiên và cuối cùng.
    Node<E> first;
    Node<E> last;
    ```
*   **Độ phức tạp thời gian:**
    *   **`get(int index)`:** O(n). Để tìm phần tử tại một chỉ số cụ thể, nó phải duyệt qua danh sách từ đầu (hoặc cuối, tùy theo cái nào gần hơn) cho đến khi nó đến được node mong muốn.
    *   **`add(E element)` (ở đầu/cuối):** O(1). Nó chỉ cần cập nhật các con trỏ của node cuối cùng/đầu tiên.
    *   **`add(int index, E element)` (ở giữa):** O(n). Điều này gây hiểu lầm. Đầu tiên mất O(n) để duyệt đến điểm chèn, nhưng việc chèn thực tế là một thao tác O(1) nhanh chóng của việc nối lại các con trỏ. Độ phức tạp tổng thể bị chi phối bởi việc duyệt.
    *   **`remove(int index)` (ở giữa):** O(n). Tương tự như việc thêm, mất O(n) để tìm node, nhưng việc xóa chính nó là một cập nhật con trỏ O(1) nhanh chóng.

*   **Trường hợp sử dụng tốt nhất:** Lý tưởng cho các tình huống có khối lượng lớn **thao tác chèn và xóa** ở đầu, giữa hoặc cuối danh sách. Nó hoạt động như một `Queue` hoặc `Deque` (Double-Ended Queue) rất hiệu quả. Sử dụng nó khi bạn hiếm khi cần truy cập các phần tử theo chỉ số.

##### **`Vector` và `Stack`**
*   **`Vector`:** Một lớp cũ, kế thừa từ Java 1.0. Về cơ bản, nó là một phiên bản đồng bộ hóa (synchronized) của `ArrayList`. Tất cả các method public của nó đều là `synchronized`, điều này làm cho nó an toàn cho luồng nhưng gây ra một chi phí hiệu suất đáng kể. Trong Java hiện đại, hầu như luôn tốt hơn là sử dụng một `ArrayList` và quản lý đồng bộ hóa bên ngoài nếu cần, hoặc sử dụng `CopyOnWriteArrayList` cho các kịch bản đọc nhiều đồng thời.
*   **`Stack`:** Một cấu trúc dữ liệu LIFO (Last-In, First-Out) kế thừa `Vector`. Đây là một lựa chọn thiết kế tồi, vì một `Stack` không nên phơi bày tất cả các method của một `List` (như `get(index)`). Sự thay thế hiện đại, được ưa thích là sử dụng một interface, `Deque`, với triển khai của nó là `ArrayDeque`.

---

#### **2. Ví dụ mã nguồn**

Mã này minh họa sự khác biệt về hiệu suất giữa `ArrayList` và `LinkedList` khi thêm các phần tử vào đầu.

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ListPerformanceDemo {
    public static void main(String[] args) {
        int numElements = 100_000;

        // --- ArrayList: Thêm vào đầu ---
        List<Integer> arrayList = new ArrayList<>();
        long startTime = System.nanoTime();
        for (int i = 0; i < numElements; i++) {
            arrayList.add(0, i); // Thêm vào chỉ số 0 đòi hỏi phải dịch chuyển tất cả các phần tử khác
        }
        long endTime = System.nanoTime();
        System.out.println("ArrayList add at beginning time: " + (endTime - startTime) / 1_000_000 + " ms");

        // --- LinkedList: Thêm vào đầu ---
        List<Integer> linkedList = new LinkedList<>();
        startTime = System.nanoTime();
        for (int i = 0; i < numElements; i++) {
            linkedList.add(0, i); // Thêm vào chỉ số 0 là một cập nhật con trỏ O(1)
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList add at beginning time: " + (endTime - startTime) / 1_000_000 + " ms");

        // LƯU Ý: Sự khác biệt về thời gian sẽ rất lớn.
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một `ArrayList` các chuỗi và một `LinkedList` các chuỗi.
2.  Điền vào cả hai với 5 triệu phần tử chuỗi (ví dụ: `"Element " + i`).
3.  Đo thời gian cần thiết để lấy phần tử ở chỉ số giữa (chỉ số 2.500.000) từ `ArrayList`.
4.  Đo thời gian cần thiết để lấy cùng một phần tử từ `LinkedList`.
5.  In thời gian ra và quan sát sự khác biệt về hiệu suất cho việc truy cập ngẫu nhiên.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang xây dựng một ứng dụng quản lý một playlist các bài hát. Các hoạt động chính là thêm bài hát vào cuối playlist và thường xuyên xáo trộn toàn bộ playlist (liên quan đến nhiều lần chèn và xóa ngẫu nhiên). Triển khai `List` nào sẽ là lựa chọn tồi tệ nhất cho trường hợp sử dụng này?

A) `ArrayList`
B) `LinkedList`
C) `Vector`
D) Không quan trọng, chúng có hiệu suất như nhau.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** A) `ArrayList`. Mặc dù việc thêm vào cuối là hiệu quả, một thao tác xáo trộn liên quan đến nhiều lần chèn và xóa trong suốt danh sách. Đối với một `ArrayList`, mỗi thao tác này là O(n) vì nó đòi hỏi phải dịch chuyển các phần lớn của mảng bên dưới. Một `LinkedList` sẽ xử lý các lần chèn và xóa này hiệu quả hơn nhiều (mặc dù việc duyệt để tìm vị trí vẫn là một yếu tố). `Vector` cũng là một lựa chọn tồi do chi phí đồng bộ hóa, nhưng cấu trúc cơ bản của `ArrayList` làm cho nó trở thành lựa chọn tồi tệ nhất cho yêu cầu "xáo trộn" cụ thể này.

### **Bài 3: Interface `Set` - `HashSet`, `LinkedHashSet`, và `TreeSet`**

#### **1. Giải thích khái niệm**

Interface `Set` mô hình hóa sự trừu tượng của tập hợp toán học. Đặc điểm xác định của nó là nó **không thể chứa các phần tử trùng lặp**. Bất kỳ nỗ lực nào để thêm một phần tử đã có trong tập hợp sẽ bị bỏ qua (method `add` sẽ trả về `false`).

Sức mạnh của các triển khai `Set` đến từ khả năng thực hiện các bài kiểm tra thành viên (`contains()`) rất nhanh chóng. Ba triển khai chính mỗi cái cung cấp một sự đánh đổi khác nhau giữa hiệu suất và thứ tự.

##### **`HashSet` - Cho truy cập nhanh, không có thứ tự**

*   **Cấu trúc nội bộ:** Một `HashSet` được hỗ trợ bởi một instance `HashMap`. Các phần tử bạn thêm vào `HashSet` được sử dụng làm **key** trong `HashMap` nội bộ. Giá trị được liên kết với mỗi key là một object giả hằng số được gọi là `PRESENT`.
    ```java
    // Khi bạn làm: myHashSet.add("apple");
    // Nội bộ, nó trở thành: myHashMap.put("apple", PRESENT);
    ```
*   **Cách hoạt động (Hashing):** Khi bạn thêm một phần tử, `HashSet` tính toán `hashCode()` của phần tử. Mã hash này được sử dụng để xác định "bucket" (hoặc chỉ số) nào trong mảng nội bộ của `HashMap` mà phần tử nên được lưu trữ. Method `equals()` sau đó được sử dụng để kiểm tra xem phần tử đã tồn tại giữa các phần tử khác trong cùng một bucket hay chưa (trong trường hợp có xung đột hash).
*   **Hợp đồng `equals()` và `hashCode()`:** Để `HashSet` hoạt động chính xác, bất kỳ object nào bạn lưu trữ trong đó **phải** triển khai đúng `equals()` và `hashCode()` theo hợp đồng của chúng. Nếu hai object bằng nhau, mã hash của chúng PHẢI giống nhau.
*   **Thứ tự:** Nó **không đảm bảo** về thứ tự lặp của các phần tử. Thứ tự có thể, và có khả năng sẽ, thay đổi theo thời gian khi nhiều phần tử được thêm vào và map hỗ trợ được thay đổi kích thước.
*   **Hiệu suất:** Cung cấp độ phức tạp thời gian trung bình **O(1)** cho các thao tác `add()`, `remove()`, và `contains()`, giả sử có một hàm hash tốt. Điều này làm cho nó cực kỳ nhanh.
*   **Nulls:** Cho phép một phần tử `null`.

##### **`LinkedHashSet` - Cho truy cập theo thứ tự chèn**

*   **Cấu trúc nội bộ:** Một `LinkedHashSet` là một subclass của `HashSet`. Nó cũng được hỗ trợ bởi một cấu trúc giống `HashMap` (`LinkedHashMap`, để chính xác). Ngoài cơ chế hashing tiêu chuẩn, nó duy trì một **danh sách liên kết đôi** chạy qua tất cả các mục của nó.
*   **Cách hoạt động:** Danh sách liên kết này được sử dụng để duy trì thứ tự mà các phần tử được chèn vào tập hợp. Khi bạn lặp qua một `LinkedHashSet`, bạn sẽ nhận lại các phần tử theo đúng thứ tự bạn đã thêm chúng.
*   **Thứ tự:** Đảm bảo **thứ tự chèn**.
*   **Hiệu suất:** Cung cấp cùng độ phức tạp thời gian trung bình **O(1)** như `HashSet` cho `add()`, `remove()`, và `contains()`. Chi phí duy trì danh sách liên kết là rất nhỏ.
*   **Trường hợp sử dụng tốt nhất:** Sử dụng nó khi bạn cần tính duy nhất và truy cập nhanh của một `HashSet`, nhưng cũng cần duy trì thứ tự chèn. Nó rất tuyệt vời để tạo ra mã có thể dự đoán và kiểm thử được, nơi thứ tự lặp lại quan trọng.

##### **`TreeSet` - Cho thứ tự được sắp xếp**

*   **Cấu trúc nội bộ:** Một `TreeSet` được hỗ trợ bởi một `TreeMap`, là một **cây Đỏ-Đen (Red-Black Tree)**, một loại cây tìm kiếm nhị phân tự cân bằng.
*   **Cách hoạt động:** Thay vì sử dụng hashing, `TreeSet` sử dụng **thứ tự tự nhiên** của phần tử hoặc một `Comparator` được cung cấp tại thời điểm khởi tạo để sắp xếp các phần tử theo một thứ tự được sắp xếp. Khi bạn thêm một phần tử, `TreeSet` duyệt qua cây để tìm vị trí chính xác cho phần tử mới trong khi vẫn giữ cho cây cân bằng.
*   **Thứ tự:** Đảm bảo rằng các phần tử sẽ ở **thứ tự được sắp xếp** (tăng dần, theo mặc định).
*   **Cơ chế sắp xếp:**
    1.  **`Comparable`:** Nếu bạn thêm các object vào `TreeSet`, lớp của chúng phải triển khai interface `Comparable` và method `compareTo()` của nó. Điều này định nghĩa "thứ tự tự nhiên" của các object (ví dụ: đối với `String`, đó là thứ tự bảng chữ cái; đối với `Integer`, đó là thứ tự số học).
    2.  **`Comparator`:** Hoặc, bạn có thể truyền một object `Comparator` vào constructor của `TreeSet`. `Comparator` này sẽ được sử dụng để so sánh và sắp xếp các phần tử, ghi đè lên thứ tự tự nhiên của chúng.
*   **Hiệu suất:** Cung cấp độ phức tạp thời gian **O(log n)** cho `add()`, `remove()`, và `contains()`. Điều này chậm hơn so với O(1) của `HashSet` nhưng vẫn rất hiệu quả, và chi phí này mang lại lợi ích của một collection được sắp xếp liên tục.
*   **Nulls:** Không cho phép các phần tử `null` (nó sẽ gây ra `NullPointerException` khi cố gắng so sánh nó).

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa các hành vi sắp xếp khác nhau của ba triển khai `Set`.

```java
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

public class SetImplementationsDemo {
    public static void main(String[] args) {
        // --- HashSet: Không có thứ tự đảm bảo ---
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Banana");
        hashSet.add("Apple");
        hashSet.add("Cherry");
        hashSet.add("Date");
        // Thứ tự đầu ra không được đảm bảo, phụ thuộc vào mã hash.
        System.out.println("HashSet (unordered): " + hashSet);

        // --- LinkedHashSet: Thứ tự chèn ---
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Banana");
        linkedHashSet.add("Apple");
        linkedHashSet.add("Cherry");
        linkedHashSet.add("Date");
        // Đầu ra sẽ chính xác là: Banana, Apple, Cherry, Date
        System.out.println("LinkedHashSet (insertion-ordered): " + linkedHashSet);

        // --- TreeSet: Thứ tự được sắp xếp ---
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("Banana");
        treeSet.add("Apple");
        treeSet.add("Cherry");
        treeSet.add("Date");
        // Đầu ra sẽ được sắp xếp theo bảng chữ cái: Apple, Banana, Cherry, Date
        System.out.println("TreeSet (sorted): " + treeSet);
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp `Book` tùy chỉnh với các trường `title` (String) và `publicationYear` (int).
2.  Triển khai đúng các method `equals()` và `hashCode()` dựa trên trường `title`.
3.  Tạo một `HashSet<Book>` và thêm một vài object `Book` vào đó, bao gồm một tiêu đề trùng lặp. Quan sát rằng bản sao bị từ chối.
4.  Bây giờ, làm cho lớp `Book` triển khai interface `Comparable<Book>`. Method `compareTo()` nên sắp xếp sách theo `publicationYear` của chúng.
5.  Tạo một `TreeSet<Book>` và thêm các object sách tương tự vào đó.
6.  In `TreeSet` ra và quan sát rằng các cuốn sách bây giờ được sắp xếp theo năm.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn cần lưu trữ một collection các ID người dùng duy nhất (các object `UUID`) thường xuyên được thêm vào và kiểm tra sự tồn tại. Thứ tự của các ID người dùng hoàn toàn không quan trọng. Triển khai `Set` nào sẽ cung cấp hiệu suất tốt nhất cho tác vụ này?

A) `TreeSet`, vì nó giữ các ID được sắp xếp để tra cứu nhanh.
B) `LinkedHashSet`, vì nó duy trì thứ tự chèn, điều này tốt cho việc caching.
C) `HashSet`, vì nó cung cấp độ phức tạp thời gian trung bình O(1) cho `add` và `contains`.
D) `Vector`, vì nó an toàn cho luồng.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `HashSet`. Các yêu cầu là `add` nhanh và kiểm tra `contains` nhanh (`tính duy nhất`) và thứ tự không quan trọng. Đây chính là trường hợp sử dụng mà `HashSet` vượt trội, cung cấp độ phức tạp thời gian trung bình tốt nhất có thể là O(1). `TreeSet` sẽ chậm hơn (O(log n)), và `LinkedHashSet` thêm một chút chi phí cho việc sắp xếp không cần thiết ở đây.

### **Bài 4: Interface `Map` và Nội bộ `HashMap`**

#### **1. Giải thích khái niệm**

Interface `Map` đại diện cho một collection các **cặp key-value**. Nó là một trong những cấu trúc dữ liệu hữu ích nhất trong lập trình. Nguyên tắc cốt lõi là mỗi key phải là duy nhất, và nó ánh xạ đến chính xác một value.

**Các Method chính của `Map`:**
*   `V put(K key, V value)`: Liên kết giá trị được chỉ định với key được chỉ định.
*   `V get(Object key)`: Trả về giá trị mà key được chỉ định ánh xạ tới, hoặc `null` nếu map này không chứa ánh xạ cho key.
*   `V remove(Object key)`: Xóa ánh xạ cho một key nếu nó có mặt.
*   `boolean containsKey(Object key)`: Trả về `true` nếu map này chứa một ánh xạ cho key được chỉ định.
*   `Set<K> keySet()`: Trả về một `Set` view của các key có trong map này.
*   `Collection<V> values()`: Trả về một `Collection` view của các giá trị.
*   `Set<Map.Entry<K, V>> entrySet()`: Trả về một `Set` view của các ánh xạ key-value.

##### **`HashMap` - `Map` phổ biến nhất**

`HashMap` là con ngựa thồ của các triển khai `Map`. Nó cung cấp độ phức tạp thời gian trung bình O(1) cho các thao tác `get()` và `put()`. Nó **không** đảm bảo bất kỳ thứ tự nào cho các phần tử của nó. Nó cho phép một key `null` và nhiều value `null`.

##### **Nội bộ `HashMap`: Cơ chế cốt lõi**

Hiểu cách một `HashMap` hoạt động bên trong là một chủ đề phỏng vấn thường xuyên và quan trọng. Nó là sự kết hợp bậc thầy của một array và các danh sách liên kết (và trong Java 8+, là các cây).

1.  **Mảng các "Bucket":**
    Một `HashMap` chứa một mảng nội bộ được gọi là `table`. Mỗi phần tử của mảng này là một "bucket".
    ```java
    // Cấu trúc nội bộ đơn giản hóa
    transient Node<K,V>[] table;
    ```
    Một bucket có thể là `null` hoặc trỏ đến `Node` đầu tiên của một cấu trúc dữ liệu (một danh sách liên kết hoặc một cây).

2.  **`Node` (hoặc `Entry`):**
    Mỗi cặp key-value được lưu trữ trong một object `Node`. Một `Node` chứa:
    *   Mã hash của key.
    *   Chính object key.
    *   Chính object value.
    *   Một con trỏ đến `Node` tiếp theo trong cùng một bucket.

3.  **Thao tác `put(key, value)` - Từng bước:**
    Khi bạn gọi `map.put("john", 123);`:
    *   **Bước 1: Tính toán Mã Hash:** Method `hashCode()` của key (`"john"`) được gọi.
    *   **Bước 2: Tính toán Chỉ số mảng:** Mã hash này sau đó được truyền qua một hàm hashing nội bộ để tính toán một chỉ số trong mảng `table`. Điều này đảm bảo chỉ số luôn nằm trong giới hạn của mảng. Công thức thường là `index = hashCode & (n - 1)`, trong đó `n` là độ dài mảng. Đây là một cách nhanh để thực hiện phép toán modulo nếu `n` là một lũy thừa của hai.
    *   **Bước 3: Xử lý Xung đột (Collision):**
        *   **Trường hợp A: Bucket trống (`table[index] == null`).** Một `Node` mới được tạo với cặp key-value và được đặt tại chỉ số này. Đây là kịch bản lý tưởng, O(1).
        *   **Trường hợp B: Bucket không trống (Xung đột!).** Điều này có nghĩa là một key khác đã được ánh xạ đến cùng một chỉ số này.
            *   `HashMap` lặp qua danh sách liên kết tại bucket đó.
            *   Đối với mỗi `Node` trong danh sách, nó kiểm tra xem key mới có `equals()` với key hiện có hay không.
            *   Nếu tìm thấy một kết quả khớp, giá trị của `Node` đó chỉ đơn giản là được cập nhật với giá trị mới, và giá trị cũ được trả về.
            *   Nếu không tìm thấy kết quả khớp nào sau khi duyệt qua toàn bộ danh sách, `Node` mới được thêm vào cuối danh sách.

4.  **Thao tác `get(key)`:**
    *   Nó tuân theo cùng một logic: tính toán `hashCode()` của key, tìm chỉ số bucket, và nếu bucket không trống, duyệt qua danh sách liên kết, sử dụng method `equals()` để tìm chính xác key.

**Sơ đồ nội bộ `HashMap`:**
```
  table (Mảng các Node)
  Chỉ số
    0    -> null
    1    -> (hash1, "key1", val1, next) -> (hashA, "keyA", valA, next) -> null
    2    -> null
    3    -> (hash3, "key3", val3, next) -> null
    ...
   n-1   -> (hashZ, "keyZ", valZ, next) -> null
```

##### **Thay đổi kích thước và Load Factor**
*   **Capacity:** Độ dài của mảng `table` nội bộ. Luôn là một lũy thừa của hai.
*   **Load Factor:** Một thước đo về mức độ đầy của bảng hash được phép trước khi dung lượng của nó được tự động tăng lên. Mặc định là **0.75**.
*   **Resizing:** Khi `(size / capacity) > loadFactor`, `HashMap` được **thay đổi kích thước**. Một mảng mới có dung lượng gấp đôi được tạo ra, và tất cả các mục hiện có được **re-hash** để tìm vị trí bucket mới của chúng trong mảng lớn hơn. Đây là một thao tác O(n) tốn kém.

##### **Cải tiến Java 8+: Tree Bins**
*   **Vấn đề:** Trong trường hợp xấu nhất, nếu tất cả các key có cùng một mã hash, tất cả chúng đều ánh xạ đến cùng một bucket, và danh sách liên kết trở nên rất dài. Tất cả các thao tác suy giảm xuống O(n).
*   **Giải pháp:** Trong Java 8, nếu số lượng node trong một bucket duy nhất đạt đến một ngưỡng nhất định (mặc định là `TREEIFY_THRESHOLD = 8`), danh sách liên kết cho bucket đó được chuyển đổi thành một **cây Đỏ-Đen tự cân bằng**.
*   **Lợi ích:** Điều này cải thiện độ phức tạp thời gian trong trường hợp xấu nhất cho `get()` và `put()` từ O(n) thành **O(log n)**, một sự cải thiện đáng kể.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa chức năng cốt lõi và cách việc ghi đè `equals` và `hashCode` là rất quan trọng.

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

// Một lớp key tùy chỉnh
class Employee {
    private final int id;
    private final String department;

    public Employee(int id, String department) {
        this.id = id;
        this.department = department;
    }

    // QUAN TRỌNG: Phải ghi đè cả hai để HashMap hoạt động chính xác
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id && Objects.equals(department, employee.department);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, department);
    }
}

public class HashMapDemo {
    public static void main(String[] args) {
        Map<Employee, String> employeeNames = new HashMap<>();

        Employee e1 = new Employee(101, "Engineering");
        Employee e2 = new Employee(102, "HR");
        Employee e3 = new Employee(101, "Engineering"); // Về mặt logic giống như e1

        employeeNames.put(e1, "Alice");
        employeeNames.put(e2, "Bob");

        // --- Minh họa get() ---
        System.out.println("Name for e1: " + employeeNames.get(e1)); // Alice
        // Chúng ta sử dụng một object "bằng nhau" e3 để truy xuất giá trị. Điều này chỉ hoạt động
        // vì chúng ta đã triển khai đúng equals() và hashCode().
        System.out.println("Name for e3: " + employeeNames.get(e3)); // Alice

        // --- Minh họa put() với một key bằng nhau ---
        System.out.println("Map size before put(e3): " + employeeNames.size()); // 2
        employeeNames.put(e3, "Alicia"); // Điều này sẽ CẬP NHẬT giá trị cho key hiện có
        System.out.println("Map size after put(e3): " + employeeNames.size()); // Vẫn là 2
        System.out.println("New name for e1: " + employeeNames.get(e1)); // Alicia
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp `Word` đơn giản có một trường `private String value`.
2.  **Không** ghi đè `equals()` hoặc `hashCode()` lúc đầu.
3.  Tạo một `HashMap<Word, Integer>` để đếm tần suất từ.
4.  Đặt một `new Word("hello")` mới với số đếm là 1 vào map.
5.  Thử truy xuất số đếm bằng một `new Word("hello")` khác. Quan sát rằng nó thất bại (trả về `null`).
6.  Bây giờ, triển khai đúng `equals()` và `hashCode()` trong lớp `Word` của bạn.
7.  Chạy lại bài kiểm tra và quan sát rằng bây giờ nó hoạt động chính xác.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một `HashMap`, mục đích chính của method `equals()` của key là gì?

A) Để tính toán chỉ số ban đầu trong mảng nội bộ.
B) Để cân bằng lại cấu trúc cây nội bộ khi một bucket trở nên quá lớn.
C) Để xử lý xung đột hash bằng cách so sánh các key trong cùng một bucket để tìm một kết quả khớp chính xác.
D) Để xác định dung lượng ban đầu của bảng `HashMap`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Để xử lý xung đột hash bằng cách so sánh các key trong cùng một bucket để tìm một kết quả khớp chính xác. Method `hashCode()` đưa bạn đến đúng bucket, nhưng nếu nhiều key rơi vào cùng một bucket đó (một xung đột), method `equals()` là thẩm quyền cuối cùng được sử dụng để phân biệt giữa chúng.

### **Bài 5: Các loại `Map` - `LinkedHashMap`, `TreeMap`, và `Hashtable`**

#### **1. Giải thích khái niệm**

Trong khi `HashMap` là lựa chọn đa năng, Java Collections Framework cung cấp một số triển khai `Map` khác, mỗi loại cung cấp các tính năng độc đáo liên quan đến thứ tự, sắp xếp và an toàn cho luồng.

##### **`LinkedHashMap` - Cho thứ tự chèn**

*   **Mối quan hệ với `HashMap`:** `LinkedHashMap` là một subclass trực tiếp của `HashMap`. Nó kế thừa tất cả các cơ chế hashing và đặc tính hiệu suất của một `HashMap`.
*   **Tính năng độc đáo:** Nó duy trì một **danh sách liên kết đôi** chạy qua tất cả các mục của nó. Danh sách này bảo tồn thứ tự mà các key được chèn vào map.
*   **Cấu trúc nội bộ:** Mỗi `Entry` trong một `LinkedHashMap` chứa các con trỏ bổ sung, `before` và `after`, liên kết nó với các mục được chèn trước đó và tiếp theo, tương ứng.
    ```
    // Ngoài các trường Node tiêu chuẩn, một LinkedHashMap.Entry còn có:
    Entry<K,V> before, after;
    ```
*   **Thứ tự:** Khi bạn lặp qua một `LinkedHashMap` (ví dụ, `keySet()` hoặc `entrySet()` của nó), các phần tử được trả về theo **thứ tự chèn**.
*   **Thứ tự truy cập:** `LinkedHashMap` có một constructor đặc biệt: `new LinkedHashMap(initialCapacity, loadFactor, accessOrder)`. Nếu `accessOrder` được đặt thành `true`, danh sách liên kết sẽ được sắp xếp lại mỗi khi một mục được *truy cập* (với `get()`). Mục được truy cập gần đây nhất sẽ di chuyển đến cuối danh sách. Tính năng này cực kỳ hữu ích để triển khai **bộ đệm LRU (Least Recently Used)**.
*   **Hiệu suất:** Các thao tác `put()` và `get()` vẫn là **O(1)** trung bình. Chi phí để duy trì danh sách liên kết là rất nhỏ.
*   **Trường hợp sử dụng tốt nhất:** Khi bạn cần tra cứu nhanh của một `HashMap` nhưng cũng yêu cầu thứ tự lặp lại có thể dự đoán và ổn định (hoặc thứ tự chèn hoặc thứ tự truy cập).

##### **`TreeMap` - Cho thứ tự được sắp xếp**

*   **Cấu trúc nội bộ:** Một `TreeMap` là một **cây Đỏ-Đen (Red-Black Tree)**, một loại cây tìm kiếm nhị phân tự cân bằng. Nó hoàn toàn không sử dụng hashing.
*   **Thứ tự:** Nó lưu trữ các mục của mình được sắp xếp theo **thứ tự tự nhiên** của các key, hoặc bởi một `Comparator` được cung cấp tại thời điểm tạo map. Điều này có nghĩa là việc lặp qua một `TreeMap` sẽ luôn mang lại các key theo một chuỗi được sắp xếp.
*   **Yêu cầu đối với Key:**
    1.  Các key phải triển khai interface `Comparable`.
    2.  HOẶC, bạn phải cung cấp một `Comparator` cho constructor của `TreeMap`.
*   **Hiệu suất:** Các thao tác `put()`, `get()`, và `containsKey()` có độ phức tạp thời gian là **O(log n)**. Điều này là do mỗi thao tác có thể yêu cầu duyệt cây từ gốc đến một nút lá. Mặc dù chậm hơn so với O(1) của `HashMap`, nó rất hiệu quả và đảm bảo một cái nhìn được sắp xếp của dữ liệu mọi lúc.
*   **Các Method bổ sung:** Vì nó được sắp xếp, `TreeMap` triển khai interface `NavigableMap`, cung cấp các method hữu ích như `firstKey()`, `lastKey()`, `headMap(toKey)`, và `tailMap(fromKey)` để lấy các phạm vi của map.
*   **Nulls:** Không cho phép một key `null` (nó không thể được so sánh), nhưng nó cho phép các value `null`.

##### **`Hashtable` - `Map` đồng bộ hóa kế thừa**

*   **Lịch sử:** `Hashtable` là một lớp kế thừa từ Java 1.0, trước khi Collections Framework tồn tại. Sau này nó đã được trang bị lại để triển khai interface `Map`.
*   **Sự khác biệt chính (Đồng bộ hóa):** Nó là **synchronized**. Mọi method public trong `Hashtable` đều được đánh dấu là `synchronized`, có nghĩa là chỉ một luồng có thể truy cập map tại một thời điểm. Điều này cung cấp sự an toàn cho luồng nhưng với một chi phí hiệu suất rất cao do tranh chấp khóa.
*   **Sự khác biệt chính (Nulls):** Nó **không** cho phép các key `null` hoặc các value `null`. Cố gắng chèn một trong hai sẽ dẫn đến một `NullPointerException`.
*   **Sự thay thế hiện đại:** `Hashtable` thường được coi là lỗi thời. Đối với các thao tác map an toàn cho luồng, sự thay thế hiện đại, hiệu suất cao là **`ConcurrentHashMap`**, cung cấp khả năng mở rộng tốt hơn nhiều bằng cách sử dụng các cơ chế khóa tinh vi hơn. Nếu bạn chỉ cần làm cho một `HashMap` an toàn cho luồng cho các trường hợp sử dụng đơn giản, bạn có thể sử dụng trình bao bọc `Collections.synchronizedMap(new HashMap<>())`.

##### **Bảng tóm tắt**

| Tính năng | `HashMap` | `LinkedHashMap` | `TreeMap` | `Hashtable` |
| :--- | :--- | :--- | :--- | :--- |
| **Thứ tự** | Không có | Thứ tự chèn hoặc truy cập | Thứ tự được sắp xếp | Không có |
| **Cấu trúc nội bộ** | Bảng Hash (Array + List/Tree) | Bảng Hash + Danh sách liên kết | Cây Đỏ-Đen | Bảng Hash |
| **Hiệu suất** | O(1) trung bình | O(1) trung bình | O(log n) | O(1) trung bình (đồng thời kém) |
| **Key Null** | Cho phép một | Cho phép một | Không cho phép | Không cho phép |
| **Value Null** | Cho phép | Cho phép | Cho phép | Không cho phép |
| **An toàn cho luồng** | Không an toàn | Không an toàn | Không an toàn | Synchronized (An toàn) |
| **Tốt nhất cho** | Đa năng, tốc độ tối đa | Lặp lại có thể dự đoán, bộ đệm LRU | Dữ liệu được sắp xếp, truy vấn phạm vi | Mã kế thừa (tránh trong mã mới) |

---

#### **2. Ví dụ mã nguồn: Bộ đệm LRU với `LinkedHashMap`**

Đây là một trường hợp sử dụng kinh điển cho `LinkedHashMap` thể hiện sức mạnh của `accessOrder`.

```java
import java.util.LinkedHashMap;
import java.util.Map;

// Một bộ đệm LRU loại bỏ mục được sử dụng gần đây nhất khi nó đạt đến dung lượng của mình.
public class LruCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LruCache(int capacity) {
        // Các đối số constructor chính:
        // initialCapacity, loadFactor, accessOrder = true
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    // Method này được gọi bởi put và putAll. Chúng ta ghi đè nó để triển khai chính sách loại bỏ.
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        // Trả về true để xóa mục cũ nhất nếu kích thước vượt quá dung lượng.
        return size() > capacity;
    }

    public static void main(String[] args) {
        LruCache<Integer, String> cache = new LruCache<>(3);

        cache.put(1, "A");
        cache.put(2, "B");
        cache.put(3, "C");
        System.out.println("Initial cache: " + cache); // {1=A, 2=B, 3=C}

        // Truy cập key 1 làm cho nó trở thành mục được sử dụng gần đây nhất.
        cache.get(1);
        System.out.println("After accessing 1: " + cache); // {2=B, 3=C, 1=A}

        // Thêm một mục mới (4) sẽ loại bỏ mục được sử dụng ít gần đây nhất (key 2).
        cache.put(4, "D");
        System.out.println("After adding 4: " + cache); // {3=C, 1=A, 4=D}
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một `TreeMap` ánh xạ các ID nhân viên `Integer` đến tên nhân viên `String`.
2.  Thêm một vài nhân viên không theo thứ tự (ví dụ: ID 50, sau đó 10, sau đó 30).
3.  Lặp qua `entrySet()` của map và in từng cặp key-value. Quan sát rằng chúng được in theo thứ tự được sắp xếp của các key.
4.  Sử dụng method `tailMap(30)` để có được một cái nhìn của map chỉ chứa các nhân viên có ID từ 30 trở lên, và in nó ra.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang xây dựng một hệ thống cần hiển thị một danh sách các quốc gia và thủ đô của chúng. Yêu cầu là các quốc gia phải luôn được hiển thị theo thứ tự bảng chữ cái. Triển khai `Map` nào là lựa chọn thích hợp nhất?

A) `HashMap`, vì nó là nhanh nhất.
B) `LinkedHashMap`, vì nó bảo tồn thứ tự mà bạn đã thêm các quốc gia.
C) `Hashtable`, vì dữ liệu quốc gia là quan trọng và cần được an toàn cho luồng.
D) `TreeMap`, vì nó tự động sắp xếp các mục dựa trên thứ tự tự nhiên của các key của nó.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `TreeMap`. Yêu cầu chính là đầu ra phải được sắp xếp theo thứ tự bảng chữ cái. `TreeMap` là triển khai map tiêu chuẩn duy nhất cung cấp sự đảm bảo này một cách tự động. Các key (tên quốc gia `String`) có một thứ tự tự nhiên theo bảng chữ cái, mà `TreeMap` sẽ sử dụng để duy trì cấu trúc được sắp xếp của nó.

### **Bài 6: Interface `Queue` và `Deque`**

#### **1. Giải thích khái niệm**

##### **Interface `Queue`**
Một `Queue` là một collection được thiết kế để chứa các phần tử trước khi xử lý. Khái niệm cơ bản là nó sắp xếp các phần tử theo một cách cụ thể, thường là **FIFO (First-In, First-Out)**. Điều này giống như một hàng chờ tại quầy vé: người đầu tiên vào hàng là người đầu tiên được phục vụ.

**Các hoạt động cốt lõi của `Queue`:**
Interface `Queue` cung cấp hai bộ method cho các hoạt động chính của nó, một bộ ném ra một ngoại lệ nếu hoạt động thất bại, và một bộ khác trả về một giá trị đặc biệt (`null` hoặc `false`).

| Hoạt động | Ném ngoại lệ | Trả về giá trị đặc biệt |
| :--- | :--- | :--- |
| **Chèn** (vào đuôi) | `add(e)` | `offer(e)` |
| **Xóa** (khỏi đầu) | `remove()` | `poll()` |
| **Kiểm tra** (phần đầu) | `element()` | `peek()` |

*   **`offer(e)` vs. `add(e)`:** Trong các queue có giới hạn (dung lượng cố định), `offer` được ưu tiên hơn. Nó sẽ chỉ trả về `false` nếu queue đã đầy, trong khi `add` sẽ ném ra một `IllegalStateException`.
*   **`poll()` vs. `remove()`:** `poll` thường an toàn hơn. Nó trả về `null` nếu queue trống, trong khi `remove` ném ra một `NoSuchElementException`.
*   **`peek()` vs. `element()`:** `peek` cũng an toàn hơn, trả về `null` cho một queue trống, trong khi `element` ném ra `NoSuchElementException`.

**Các triển khai phổ biến:**
*   **`LinkedList`:** Chúng ta đã thấy rằng `LinkedList` là một `List`, nhưng nó cũng triển khai interface `Queue`. Hiệu suất O(1) của nó cho việc thêm vào đuôi và xóa khỏi đầu làm cho nó trở thành một triển khai `Queue` xuất sắc.
*   **`PriorityQueue`:** Một queue chuyên biệt không sắp xếp các phần tử theo thứ tự FIFO. Thay vào đó, nó sắp xếp chúng dựa trên độ ưu tiên.

##### **`PriorityQueue` - Queue dựa trên độ ưu tiên**

*   **Cấu trúc nội bộ:** Một `PriorityQueue` được triển khai như một **đống nhị phân (binary heap)**, một loại cây nhị phân cụ thể thỏa mãn thuộc tính heap: mỗi nút nhỏ hơn (hoặc bằng, đối với min-heap) các con của nó. `PriorityQueue` của Java là một **min-heap**, có nghĩa là phần tử có giá trị *thấp nhất* có độ ưu tiên cao nhất và sẽ ở đầu queue.
*   **Thứ tự:** Khi bạn gọi `poll()`, bạn được đảm bảo sẽ nhận được phần tử nhỏ nhất trong queue theo thứ tự tự nhiên của nó (`Comparable`) hoặc một `Comparator` được cung cấp tại thời điểm khởi tạo. Thứ tự lặp lại (vòng lặp `for-each`) **không được đảm bảo** là đã được sắp xếp.
*   **Hiệu suất:** Các hoạt động `offer(e)` (thêm) và `poll()` (xóa) là **O(log n)**. `peek()` là **O(1)**.
*   **Trường hợp sử dụng tốt nhất:** Bất kỳ kịch bản nào bạn cần xử lý mục "quan trọng nhất" một cách nhất quán trước, chẳng hạn như trong các bộ lập lịch tác vụ (xử lý tác vụ có độ ưu tiên cao nhất), các thuật toán tìm đường (như Dijkstra's, khám phá đường đi ngắn nhất trước), hoặc mô phỏng sự kiện.

##### **Interface `Deque`**

Một `Deque` (phát âm là "deck") là một **"hàng đợi hai đầu" (double-ended queue).** Nó mở rộng interface `Queue` nhưng hỗ trợ chèn và xóa phần tử ở **cả hai đầu**. Nó có thể được sử dụng như một queue FIFO và một stack LIFO.

*   **Như một Queue (FIFO):** Sử dụng `addLast()` (hoặc `offerLast()`) để chèn và `removeFirst()` (hoặc `pollFirst()`) để xóa.
*   **Như một Stack (LIFO):** Sử dụng `addFirst()` (hoặc `push()`) để chèn và `removeFirst()` (hoặc `pop()`) để xóa.

**Các Method cốt lõi của `Deque`:**

| Đầu | Chèn | Xóa | Kiểm tra |
| :--- | :--- | :--- | :--- |
| **Đầu (Head)** | `addFirst(e)`, `offerFirst(e)` | `removeFirst()`, `pollFirst()` | `getFirst()`, `peekFirst()` |
| **Cuối (Tail)** | `addLast(e)`, `offerLast(e)` | `removeLast()`, `pollLast()` | `getLast()`, `peekLast()` |

##### **`ArrayDeque` - Triển khai `Deque` và `Stack` nên dùng**

*   **Cấu trúc nội bộ:** Một `ArrayDeque` được hỗ trợ bởi một **mảng tròn có thể thay đổi kích thước**. Cấu trúc thông minh này cho phép nó cung cấp độ phức tạp thời gian trung bình O(1) cho việc thêm và xóa các phần tử từ cả đầu và đuôi.
*   **Hiệu suất:** **O(1)** được khấu hao (amortized O(1)) cho tất cả các hoạt động `add...` và `remove...`. Nó hiệu quả hơn `LinkedList` cho các hoạt động `Deque` vì nó không có chi phí tạo đối tượng node.
*   **Thực hành tốt nhất:** `ArrayDeque` là **triển khai được ưu tiên cho một `Stack`**. Lớp `Stack` kế thừa nên được tránh. Nó cũng là lựa chọn tốt nhất cho một `Queue` đa năng nếu bạn không cần thứ tự ưu tiên.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa hành vi FIFO của một queue, hành vi LIFO của một stack (sử dụng `ArrayDeque`), và hành vi dựa trên độ ưu tiên của một `PriorityQueue`.

```java
import java.util.*;

public class QueueDequeDemo {
    public static void main(String[] args) {
        // --- 1. Queue (FIFO) sử dụng ArrayDeque ---
        System.out.println("--- Queue (FIFO) Demo ---");
        Queue<String> customerLine = new ArrayDeque<>();
        customerLine.offer("Alice");
        customerLine.offer("Bob");
        customerLine.offer("Charlie");
        System.out.println("Serving: " + customerLine.poll()); // Phục vụ Alice
        System.out.println("Next in line: " + customerLine.peek()); // Bob
        System.out.println("Serving: " + customerLine.poll()); // Phục vụ Bob
        System.out.println();

        // --- 2. Stack (LIFO) sử dụng ArrayDeque ---
        System.out.println("--- Stack (LIFO) Demo ---");
        Deque<String> browserHistory = new ArrayDeque<>();
        browserHistory.push("google.com"); // push() là addFirst()
        browserHistory.push("stackoverflow.com");
        browserHistory.push("github.com");
        System.out.println("Current page: " + browserHistory.peek()); // github.com
        System.out.println("Pressing back button: " + browserHistory.pop()); // pop() là removeFirst()
        System.out.println("Current page: " + browserHistory.peek()); // stackoverflow.com
        System.out.println();

        // --- 3. PriorityQueue Demo ---
        System.out.println("--- PriorityQueue Demo ---");
        // Theo mặc định, nó là một min-heap (số thấp nhất = độ ưu tiên cao nhất)
        Queue<Integer> taskPriorities = new PriorityQueue<>();
        taskPriorities.offer(5); // Độ ưu tiên thấp
        taskPriorities.offer(1); // Độ ưu tiên cao
        taskPriorities.offer(3); // Độ ưu tiên trung bình
        System.out.println("Processing highest priority task: " + taskPriorities.poll()); // Xử lý 1
        System.out.println("Processing next task: " + taskPriorities.poll()); // Xử lý 3
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn được giao nhiệm vụ đảo ngược một chuỗi bằng cách sử dụng một stack.
1.  Tạo một `ArrayDeque` để sử dụng như một stack.
2.  Lặp qua các ký tự của một chuỗi đã cho (ví dụ: "hello") và `push` mỗi ký tự vào stack.
3.  Tạo một `StringBuilder`.
4.  Trong khi stack không trống, `pop` mỗi ký tự từ stack và nối nó vào `StringBuilder`.
5.  In nội dung của `StringBuilder`. Đầu ra phải là chuỗi đảo ngược ("olleh").

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn cần một cấu trúc dữ liệu để triển khai một stack LIFO. Lựa chọn nào sau đây là hiện đại, được khuyến nghị trong Java vì hiệu suất và thiết kế vượt trội của nó?

A) `java.util.Stack`
B) `java.util.Vector`
C) `java.util.LinkedList`
D) `java.util.ArrayDeque`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `java.util.ArrayDeque`. Nó được thiết kế đặc biệt cho các hoạt động stack (và queue) hiệu quả với độ phức tạp khấu hao O(1) cho push và pop. Lớp `Stack` kế thừa `Vector` và có các vấn đề về hiệu suất do đồng bộ hóa. Mặc dù `LinkedList` có thể được sử dụng như một stack, `ArrayDeque` thường hiệu quả hơn do ít chi phí bộ nhớ hơn.

### **Bài 7: Các khái niệm nâng cao - `Comparable` vs. `Comparator`**

#### **1. Giải thích khái niệm**

Trong Java, việc sắp xếp và thứ tự là các hoạt động cơ bản, đặc biệt đối với các collection như `TreeSet`, `TreeMap`, và khi sử dụng `Collections.sort()` hoặc `List.sort()`. Framework cung cấp hai interface chính để định nghĩa logic sắp xếp: `Comparable` và `Comparator`. Hiểu rõ sự khác biệt là rất quan trọng để kiểm soát thứ tự của các object tùy chỉnh của bạn.

##### **`Comparable<T>` - Cho thứ tự tự nhiên**
*   **Interface:** `java.lang.Comparable<T>`
*   **Method:** Nó có một method duy nhất: `int compareTo(T other)`
*   **Mục đích:** `Comparable` được sử dụng để định nghĩa **thứ tự tự nhiên, duy nhất** cho một lớp. Bạn triển khai interface này *trực tiếp trong lớp* có các object mà bạn muốn sắp xếp. Đây là ý thức về thứ tự nội tại của chính object.
*   **Ví dụ tương tự:** Hãy nghĩ về `Comparable` như chiều cao của một người. Chiều cao là một thuộc tính nội tại. Bạn có thể sắp xếp một nhóm người theo chiều cao của họ một cách tự nhiên mà không cần bất kỳ công cụ bên ngoài nào. `String` được sắp xếp tự nhiên theo thứ tự bảng chữ cái. `Integer` được sắp xếp tự nhiên theo thứ tự số học.
*   **Hợp đồng `compareTo()`:**
    *   Trả về một **số nguyên âm** nếu object `this` *nhỏ hơn* object `other`.
    *   Trả về **không** nếu object `this` *bằng* object `other`.
    *   Trả về một **số nguyên dương** nếu object `this` *lớn hơn* object `other`.
*   **Sử dụng:** Được sử dụng bởi `TreeSet`, `TreeMap`, và các method sắp xếp theo mặc định nếu không có `Comparator` nào được chỉ định.

##### **`Comparator<T>` - Cho thứ tự tùy chỉnh hoặc bên ngoài**
*   **Interface:** `java.util.Comparator<T>`
*   **Method:** Nó có một method trừu tượng duy nhất: `int compare(T o1, T o2)` (và một số method default trong Java 8+).
*   **Mục đích:** `Comparator` được sử dụng để định nghĩa **các chiến lược sắp xếp bên ngoài, tùy chỉnh, hoặc nhiều chiến lược khác nhau** cho một lớp. Bạn tạo một *lớp riêng biệt* triển khai interface `Comparator`. Bạn không sửa đổi lớp của các object mà bạn muốn sắp xếp.
*   **Ví dụ tương tự:** Hãy nghĩ về `Comparator` như một lăng kính cụ thể để xem và sắp xếp mọi người. Bạn có thể có một `Comparator` sắp xếp mọi người theo tuổi, một cái khác sắp xếp họ theo họ, và một cái thứ ba sắp xếp họ theo quốc gia xuất xứ. Logic sắp xếp là bên ngoài đối với chính object `Person`.
*   **Hợp đồng `compare()`:**
    *   Trả về một **số nguyên âm** nếu `o1` *nhỏ hơn* `o2`.
    *   Trả về **không** nếu `o1` *bằng* `o2`.
    *   Trả về một **số nguyên dương** nếu `o1` *lớn hơn* `o2`.
*   **Sử dụng:** Bạn truyền một instance của `Comparator` của bạn vào constructor của một `TreeSet`/`TreeMap` hoặc vào một method `sort()`.

##### **Khi nào nên dùng cái nào? Một sự phân biệt rõ ràng**
*   Sử dụng **`Comparable`** khi thứ tự sắp xếp là rõ ràng, tự nhiên, và chỉ có một cách logic duy nhất để sắp xếp các object (ví dụ: sắp xếp các object `User` theo ID duy nhất của chúng). Triển khai nó trực tiếp trong lớp `User`.
*   Sử dụng **`Comparator`** khi:
    *   Bạn muốn sắp xếp các object của một lớp mà bạn không thể sửa đổi (ví dụ: một lớp từ một thư viện của bên thứ ba).
    *   Bạn cần nhiều cách khác nhau để sắp xếp cùng một loại object (ví dụ: sắp xếp `Employee` theo tên, sau đó theo lương, sau đó theo ngày tuyển dụng).
    *   Bạn muốn sử dụng một biểu thức lambda ngắn gọn cho một tác vụ sắp xếp một lần.

**Thực hành tốt nhất:** Khi triển khai `compareTo`, một thực hành tốt là đảm bảo rằng `x.compareTo(y) == 0` nhất quán với `x.equals(y)`. Mặc dù không bắt buộc nghiêm ngặt, việc không làm như vậy có thể dẫn đến hành vi bất ngờ trong `Set` và `Map`. Ví dụ, một `TreeSet` sử dụng `compareTo` để xác định tính duy nhất, vì vậy nếu `compareTo` trả về 0 cho hai object không bằng nhau, `TreeSet` sẽ coi chúng là trùng lặp và loại bỏ một.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này cho thấy một lớp `Movie` có một thứ tự tự nhiên theo năm (`Comparable`) và cũng cung cấp một số `Comparator` tùy chỉnh cho các nhu cầu sắp xếp khác.

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// Lớp Movie có một "thứ tự tự nhiên" theo năm (triển khai Comparable)
class Movie implements Comparable<Movie> {
    private final String title;
    private final int year;
    private final double rating;

    public Movie(String title, int year, double rating) {
        this.title = title;
        this.year = year;
        this.rating = rating;
    }

    public String getTitle() { return title; }
    public int getYear() { return year; }
    public double getRating() { return rating; }

    // Thứ tự sắp xếp tự nhiên: theo năm, tăng dần
    @Override
    public int compareTo(Movie other) {
        return Integer.compare(this.year, other.year);
    }

    @Override
    public String toString() {
        return "Movie{" + "title='" + title + '\'' + ", year=" + year + ", rating=" + rating + '}';
    }
}

// Một Comparator tùy chỉnh để sắp xếp theo đánh giá
class RatingComparator implements Comparator<Movie> {
    @Override
    public int compare(Movie m1, Movie m2) {
        return Double.compare(m2.getRating(), m1.getRating()); // Thứ tự giảm dần
    }
}

public class SortingDemo {
    public static void main(String[] args) {
        List<Movie> movies = new ArrayList<>();
        movies.add(new Movie("The Godfather", 1972, 9.2));
        movies.add(new Movie("Parasite", 2019, 8.6));
        movies.add(new Movie("Inception", 2010, 8.8));

        // 1. Sắp xếp bằng thứ tự tự nhiên (Comparable: theo năm)
        Collections.sort(movies);
        System.out.println("Sorted by year (natural order):");
        movies.forEach(System.out::println);

        // 2. Sắp xếp bằng một lớp Comparator tùy chỉnh (theo đánh giá)
        movies.sort(new RatingComparator()); // List.sort() được ưu tiên hơn từ Java 8
        System.out.println("\nSorted by rating (Comparator):");
        movies.forEach(System.out::println);

        // 3. Sắp xếp bằng một biểu thức lambda Comparator (theo tiêu đề) - Java 8+
        movies.sort((m1, m2) -> m1.getTitle().compareTo(m2.getTitle()));
        System.out.println("\nSorted by title (Lambda Comparator):");
        movies.forEach(System.out::println);
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp `Player` với các trường `name` (String) và `score` (int).
2.  Triển khai `Comparable<Player>` để định nghĩa thứ tự tự nhiên là sắp xếp theo tên theo thứ tự bảng chữ cái.
3.  Tạo một lớp riêng `PlayerScoreComparator` triển khai `Comparator<Player>` để sắp xếp người chơi theo điểm của họ theo thứ tự giảm dần (điểm cao nhất trước).
4.  Trong `main`, tạo một `List<Player>`, thêm một vài người chơi, và chứng minh rằng bạn có thể sắp xếp danh sách cả theo tên (sử dụng thứ tự tự nhiên) và theo điểm (bằng cách truyền một instance của comparator của bạn).

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn cần sắp xếp một `List<String>` theo độ dài của các chuỗi, từ ngắn nhất đến dài nhất. Cách nào là ngắn gọn và hiện đại nhất để đạt được điều này?

A) Tạo một lớp `StringLength` mới kế thừa `String` và triển khai `Comparable`.
B) Tạo một lớp riêng `StringLengthComparator` triển khai `Comparator<String>`.
C) Sử dụng `Collections.sort(list, (s1, s2) -> Integer.compare(s1.length(), s2.length()));`
D) Không thể, vì thứ tự tự nhiên của `String` là theo thứ tự bảng chữ cái.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `Sử dụng Collections.sort(list, (s1, s2) -> Integer.compare(s1.length(), s2.length()));`. Điều này sử dụng một biểu thức lambda để tạo một `Comparator` ẩn danh ngay lập tức. Đó là cách ngắn gọn và thành ngữ nhất để thực hiện một sắp xếp tùy chỉnh trong Java hiện đại. Mặc dù B cũng là một cách đúng để làm điều đó, nó dài dòng hơn.

### **Bài 8: Các khái niệm nâng cao - Iterator Fail-Fast vs. Fail-Safe**

#### **1. Giải thích khái niệm**

Khi bạn lặp qua một collection trong khi nó đang được sửa đổi bởi một luồng khác (hoặc thậm chí cùng một luồng), bạn có thể gặp phải các vấn đề nghiêm trọng như dữ liệu không nhất quán hoặc hành vi không thể đoán trước. Các iterator của Java có hai chiến lược chính để đối phó với vấn đề này: **Fail-Fast** và **Fail-Safe**.

##### **Iterator Fail-Fast**

*   **Hành vi:** Một iterator fail-fast ném ra một **`ConcurrentModificationException`** nếu collection bị sửa đổi cấu trúc (tức là các phần tử được thêm vào hoặc xóa đi) bất kỳ lúc nào sau khi iterator được tạo, theo bất kỳ cách nào ngoại trừ thông qua method `remove()` của chính iterator.
*   **Cơ chế:** Hầu hết các collection tiêu chuẩn trong `java.util` (như `ArrayList`, `HashMap`, `HashSet`) sử dụng một cơ chế đơn giản để đạt được điều này. Collection duy trì một bộ đếm nội bộ được gọi là `modCount` (số lần sửa đổi).
    1.  Khi một iterator được tạo, nó ghi lại giá trị hiện tại của `modCount`.
    2.  Trên mỗi hoạt động (`next()`, `hasNext()`), iterator kiểm tra xem `modCount` của collection có còn giống với giá trị mà nó đã ghi lại hay không.
    3.  Nếu `modCount` đã thay đổi, iterator biết một phần khác của mã đã sửa đổi collection, và nó ngay lập tức ném ra `ConcurrentModificationException`.
*   **Hệ thống "Nỗ lực hết sức":** Điều quan trọng cần biết là đây **không phải là một cơ chế được đảm bảo**. Nó là một kiểm tra "nỗ lực hết sức". Ngoại lệ được ném ra trên cơ sở nỗ lực hết sức và chỉ nên được sử dụng để phát hiện lỗi trong quá trình phát triển, không phải để kiểm soát logic ứng dụng. Có những kịch bản mà một sửa đổi có thể xảy ra mà iterator không nhận thấy ngay lập tức.
*   **Các Collection nào?** `ArrayList`, `LinkedList`, `HashSet`, `HashMap`, và hầu hết các collection khác trong package `java.util`.

##### **Iterator Fail-Safe (hoặc Iterator nhất quán yếu)**

*   **Hành vi:** Một iterator fail-safe **không** ném ra `ConcurrentModificationException`. Thay vào đó, nó hoạt động trên một **bản sao hoặc một bản chụp nhanh (snapshot)** của collection cơ sở.
*   **Cơ chế:** Khi iterator được tạo, nó tạo một bản sao của cấu trúc dữ liệu của collection. Iterator sau đó duyệt qua bản sao này.
    1.  Bất kỳ sửa đổi nào được thực hiện đối với collection ban đầu sau khi iterator được tạo đều **không được phản ánh** trong chế độ xem của iterator. Bạn sẽ lặp qua trạng thái của collection như nó đã tồn tại tại thời điểm iterator được tạo.
    2.  Cách tiếp cận này tiêu tốn nhiều bộ nhớ hơn vì một bản sao của collection được tạo ra.
*   **Tính nhất quán:** Chúng được gọi là "nhất quán yếu" vì chúng đảm bảo sẽ không ném ra ngoại lệ, nhưng chúng không phản ánh trạng thái cập nhật nhất của collection.
*   **Các Collection nào?** Các collection từ package `java.util.concurrent`, chẳng hạn như **`CopyOnWriteArrayList`**, **`CopyOnWriteArraySet`**, và iterator `keySet()` của **`ConcurrentHashMap`**.

##### **Bảng so sánh tóm tắt**

| Tính năng | Iterator Fail-Fast | Iterator Fail-Safe |
| :--- | :--- | :--- |
| **Ngoại lệ** | Ném `ConcurrentModificationException` khi có sửa đổi đồng thời. | Không ném `ConcurrentModificationException`. |
| **Chế độ xem dữ liệu** | Hoạt động trực tiếp trên collection. | Hoạt động trên một bản sao/snapshot của collection. |
| **Tính nhất quán** | Chế độ xem được cập nhật cho đến khi một ngoại lệ được ném ra. | Chế độ xem là một snapshot; nó có thể không phản ánh các thay đổi gần đây. |
| **Sử dụng bộ nhớ** | Thấp. Không có bộ nhớ bổ sung cho dữ liệu collection. | Cao. Yêu cầu bộ nhớ bổ sung cho bản sao. |
| **Hiệu suất** | Nhanh hơn, vì nó không liên quan đến việc sao chép. | Chậm hơn để tạo do chi phí sao chép. |
| **Tìm thấy trong** | Package `java.util` (ví dụ: `ArrayList`, `HashMap`). | Package `java.util.concurrent` (ví dụ: `CopyOnWriteArrayList`). |

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa hành vi của cả hai loại iterator.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class IteratorDemo {
    public static void main(String[] args) {
        // --- 1. Ví dụ Iterator Fail-Fast ---
        System.out.println("--- Fail-Fast Demo (ArrayList) ---");
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        Iterator<String> failFastIterator = list.iterator();
        try {
            while (failFastIterator.hasNext()) {
                String element = failFastIterator.next();
                System.out.println(element);
                // Sửa đổi này sẽ gây ra ngoại lệ trong lần gọi *tiếp theo* tới hasNext() hoặc next()
                if (element.equals("B")) {
                    list.remove("C"); // Sửa đổi cấu trúc
                }
            }
        } catch (java.util.ConcurrentModificationException e) {
            System.out.println("ERROR: ConcurrentModificationException was thrown!");
        }

        System.out.println("\n--- 2. Ví dụ Iterator Fail-Safe ---");
        List<String> concurrentList = new CopyOnWriteArrayList<>();
        concurrentList.add("X");
        concurrentList.add("Y");
        concurrentList.add("Z");

        Iterator<String> failSafeIterator = concurrentList.iterator();
        // Iterator đang hoạt động trên một snapshot được chụp khi nó được tạo: [X, Y, Z]
        while (failSafeIterator.hasNext()) {
            String element = failSafeIterator.next();
            System.out.println("Iterating over: " + element);
            // Sửa đổi này ảnh hưởng đến danh sách ban đầu, nhưng KHÔNG ảnh hưởng đến snapshot của iterator
            if (element.equals("Y")) {
                concurrentList.add("W");
            }
        }
        System.out.println("No exception was thrown.");
        System.out.println("Final state of the list: " + concurrentList); // [X, Y, Z, W]
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một `HashMap<Integer, String>`.
2.  Thêm một vài cặp key-value vào đó.
3.  Tạo một iterator cho `keySet()` của nó.
4.  Bắt đầu một vòng lặp `for-each` trên `keySet()` (vòng lặp này ngầm sử dụng một iterator).
5.  Bên trong vòng lặp, khi gặp một key cụ thể, hãy thử xóa một key khác trực tiếp khỏi map bằng cách sử dụng `map.remove()`.
6.  Bao bọc vòng lặp của bạn trong một khối `try-catch` và xác minh rằng một `ConcurrentModificationException` được ném ra, chứng tỏ rằng các iterator của `HashMap` là fail-fast.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang xây dựng một ứng dụng đa luồng trong đó một luồng thường xuyên lặp qua một danh sách các listener để gửi thông báo cho họ, trong khi các luồng khác có thể thêm hoặc xóa listener khỏi cùng một danh sách đó bất kỳ lúc nào. Yêu cầu chính của bạn là tránh `ConcurrentModificationException` bằng mọi giá, và bạn có thể chấp nhận thực tế rằng một listener mới được thêm vào có thể không nhận được thông báo ngay lập tức. Collection nào phù hợp nhất cho kịch bản này?

A) `ArrayList` được bao bọc bởi `Collections.synchronizedList()`
B) `LinkedList`
C) `Vector`
D) `CopyOnWriteArrayList`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `CopyOnWriteArrayList`. Đây chính là trường hợp sử dụng cho `CopyOnWriteArrayList`. Iterator fail-safe của nó đảm bảo rằng không có `ConcurrentModificationException` nào sẽ được ném ra trong quá trình lặp. Hành vi "copy-on-write" đảm bảo rằng các ghi (thêm/xóa listener) không can thiệp vào các luồng hiện đang đọc (lặp) danh sách. Mặc dù A và C cung cấp sự an toàn cho luồng, các iterator của chúng vẫn là fail-fast và sẽ ném ra ngoại lệ trong kịch bản này.

### **Bài 9: Concurrent Collections**

#### **1. Giải thích khái niệm**

Các lớp collection tiêu chuẩn từ `java.util` (như `ArrayList` và `HashMap`) **không an toàn cho luồng (thread-safe)**. Nếu nhiều luồng truy cập và sửa đổi một collection như vậy đồng thời, trạng thái nội bộ của collection có thể bị hỏng, dẫn đến mất dữ liệu, kết quả không chính xác, hoặc `ConcurrentModificationException`.

Java cung cấp hai chiến lược chính để xử lý các collection trong một môi trường đa luồng: **các trình bao bọc đồng bộ hóa (synchronized wrappers)** và các collection chuyên dụng trong package **`java.util.concurrent`**.

##### **Synchronized Wrappers (`Collections.synchronized...`)**

Đây là cách tiếp cận cũ hơn. Lớp tiện ích `Collections` cung cấp các method bao bọc có thể nhận bất kỳ collection tiêu chuẩn nào và trả về một phiên bản an toàn cho luồng của nó.

*   **Methods:** `Collections.synchronizedList()`, `Collections.synchronizedSet()`, `Collections.synchronizedMap()`.
*   **Cơ chế:** Các trình bao bọc này đạt được sự an toàn cho luồng bằng cách trang trí mọi method của collection bằng một khối `synchronized`, khóa trên một mutex duy nhất (chính object collection).
*   **Vấn đề (Khả năng mở rộng kém):** Điều này tạo ra một nút thắt cổ chai hiệu suất lớn. Chỉ một luồng có thể truy cập collection tại một thời điểm, cho *bất kỳ* hoạt động nào (đọc hoặc ghi). Nếu bạn có nhiều luồng cố gắng đọc từ collection, tất cả chúng sẽ bị chặn chờ đợi khóa duy nhất, mặc dù các hoạt động đọc không can thiệp lẫn nhau. Điều này được gọi là **đồng thời thấp (low concurrency)**.
*   **Các hành động phức hợp:** Hơn nữa, việc đồng bộ hóa trên các method riêng lẻ không đủ để bảo vệ các hành động phức hợp. Việc lặp qua một collection được đồng bộ hóa không an toàn trừ khi bạn tự đồng bộ hóa toàn bộ khối lặp.

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
// ... thêm các phần tử ...

// Lặp KHÔNG AN TOÀN cho luồng
for (String item : list) {
    // Một luồng khác có thể sửa đổi danh sách ở đây, gây ra một ngoại lệ
}

// Lặp AN TOÀN cho luồng (nhưng chặn tất cả các luồng khác)
synchronized (list) {
    for (String item : list) {
        // ... các hoạt động an toàn ...
    }
}
```

##### **Concurrent Collections (`java.util.concurrent`)**

Package `java.util.concurrent`, được giới thiệu trong Java 5, cung cấp một bộ các lớp collection hiệu suất cao được thiết kế đặc biệt cho việc truy cập đồng thời. Chúng là lựa chọn được ưu tiên trong lập trình đa luồng hiện đại.

Các collection này sử dụng các cơ chế khóa tinh vi và chi tiết hơn thay vì một khóa độc quyền duy nhất, cho phép đồng thời và khả năng mở rộng cao hơn nhiều.

##### **`ConcurrentHashMap` - `Map` có thể mở rộng**

*   **Cơ chế:** Thay vì một khóa duy nhất cho toàn bộ map, `ConcurrentHashMap` sử dụng một kỹ thuật được gọi là **phân mảnh khóa (lock striping)** hoặc **khóa theo phân đoạn (segmented locking)**. Bảng nội bộ được chia thành các phân đoạn (hoặc, trong các triển khai hiện đại, khóa được đặt trên nút đầu tiên của mỗi bucket). Một luồng chỉ cần khóa phân đoạn/bucket cụ thể mà nó đang ghi vào, cho phép các luồng khác truy cập các phần khác của map đồng thời.
*   **Hoạt động đọc:** Các hoạt động đọc (`get()`) thường là **không chặn (non-blocking)** và hoàn toàn không yêu cầu khóa, cung cấp hiệu suất cực cao cho các ứng dụng đọc nhiều.
*   **Iterators:** Các iterator là **nhất quán yếu (weakly consistent)** (fail-safe). Chúng phản ánh trạng thái của map tại một thời điểm nào đó kể từ khi iterator được tạo và sẽ không ném ra `ConcurrentModificationException`.
*   **Hiệu suất:** Cung cấp hiệu suất và khả năng mở rộng vượt trội so với `Hashtable` hoặc một `synchronizedMap`. Nó là lựa chọn mặc định cho một map an toàn cho luồng.

##### **`CopyOnWriteArrayList` - Cho các kịch bản đọc nhiều**

*   **Cơ chế:** Như tên cho thấy, nó triển khai một chiến lược **"copy-on-write"**.
    *   **Hoạt động đọc:** Đọc rất nhanh vì chúng hoạt động trên mảng hỗ trợ hiện có, bất biến và yêu cầu **không có khóa**.
    *   **Hoạt động ghi (`add`, `remove`):** Bất kỳ sửa đổi nào cũng tốn kém. Một **bản sao mới** của toàn bộ mảng cơ sở được tạo ra, sửa đổi được thực hiện trên bản sao, và sau đó tham chiếu nội bộ được hoán đổi nguyên tử để trỏ đến mảng mới.
*   **Iterators:** Các iterator là các **snapshot fail-safe**. Chúng lặp qua mảng đã tồn tại tại thời điểm iterator được tạo.
*   **Trường hợp sử dụng tốt nhất:** Khi bạn có một collection được lặp qua thường xuyên hơn nhiều so với việc nó bị sửa đổi. Một ví dụ kinh điển là một danh sách các listener trong một hệ thống dựa trên sự kiện.

##### **Concurrent Queues (`BlockingQueue`)**

Package `java.util.concurrent` cũng cung cấp các triển khai `Queue` mạnh mẽ là trung tâm của nhiều mẫu producer-consumer.
*   **Interface `BlockingQueue<E>`:** Một phần mở rộng của `Queue` cung cấp các hoạt động chặn.
    *   `put(e)`: Chờ cho đến khi có không gian trong queue để chèn một phần tử.
    *   `take()`: Chờ cho đến khi có một phần tử trong queue để lấy nó.
*   **Các triển khai phổ biến:**
    *   **`LinkedBlockingQueue`:** Một queue có thể có giới hạn hoặc không dựa trên một danh sách liên kết. Có thể có thông lượng rất cao.
    *   **`ArrayBlockingQueue`:** Một queue có kích thước cố định được hỗ trợ bởi một mảng. Nó công bằng, có nghĩa là nó cấp quyền truy cập cho các luồng theo thứ tự chúng đã chờ.

---

#### **2. Ví dụ mã nguồn: `ConcurrentHashMap` vs. `synchronizedMap`**

Ví dụ này mô phỏng các ghi đồng thời vào cả hai loại map để làm nổi bật sự khác biệt về hiệu suất (mặc dù sự khác biệt thực tế là rõ rệt nhất với nhiều lõi).

```java
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ConcurrentCollectionsDemo {

    public static void performWrites(Map<Integer, Integer> map) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        long startTime = System.nanoTime();

        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                for (int j = 0; j < 100_000; j++) {
                    int key = (int) (Math.random() * 10000);
                    map.put(key, j);
                }
            });
        }
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);

        long endTime = System.nanoTime();
        System.out.println("Time taken: " + (endTime - startTime) / 1_000_000 + " ms. Map size: " + map.size());
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("--- Testing synchronizedMap ---");
        Map<Integer, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
        performWrites(syncMap);

        System.out.println("\n--- Testing ConcurrentHashMap ---");
        Map<Integer, Integer> concurrentMap = new ConcurrentHashMap<>();
        performWrites(concurrentMap);
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn cần triển khai một hệ thống producer-consumer đơn giản.
1.  Tạo một `BlockingQueue<Integer>` có dung lượng cố định là 10 (sử dụng `ArrayBlockingQueue`).
2.  Tạo một "producer" `Runnable` tạo ra 100 số nguyên ngẫu nhiên và `put` chúng vào queue. Nó nên in ra mỗi số nó tạo ra. Thêm một `Thread.sleep()` nhỏ để mô phỏng công việc.
3.  Tạo một "consumer" `Runnable` lặp 100 lần, `take` một số nguyên từ queue, và in nó ra.
4.  Tạo hai luồng, một cho producer và một cho consumer, và khởi động chúng. Quan sát cách các method `put` và `take` tự động chặn, điều phối công việc giữa hai luồng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Nhược điểm đáng kể nhất của việc sử dụng `Collections.synchronizedList()` so với `CopyOnWriteArrayList` là gì?

A) `synchronizedList` không cho phép các phần tử null.
B) `synchronizedList` có một iterator fail-safe, điều này ít được mong muốn hơn.
C) `synchronizedList` sử dụng một khóa duy nhất cho tất cả các hoạt động, dẫn đến đồng thời và khả năng mở rộng kém, đặc biệt là đối với các lần đọc.
D) `synchronizedList` là một API cũ, đã lỗi thời.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `synchronizedList` sử dụng một khóa duy nhất cho tất cả các hoạt động, dẫn đến đồng thời và khả năng mở rộng kém, đặc biệt là đối với các lần đọc. Toàn bộ collection bị khóa cho mọi hoạt động, ngăn cản nhiều luồng thậm chí đọc danh sách cùng một lúc, trong khi `CopyOnWriteArrayList` cho phép các lần đọc đồng thời không giới hạn mà không cần khóa nào.

### **Bài 10: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Chúc mừng bạn đã hoàn thành chuyến tham quan chuyên sâu về Java Collections Framework. Bài học cuối cùng này sẽ tóm tắt các cấu trúc dữ liệu chính, trình bày các câu hỏi phỏng vấn phổ biến để kiểm tra kiến thức của bạn, và cung cấp một dự án nhỏ để áp dụng các khái niệm này trong một kịch bản thực tế.

---

#### **1. Bảng tóm tắt các Collection chính**

| Interface | Class | Cấu trúc nội bộ | Thứ tự | Trùng lặp | Nulls | An toàn luồng | Trường hợp sử dụng chính |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **List** | `ArrayList` | Mảng động | Chèn | Cho phép | Cho phép | Không | Truy cập ngẫu nhiên nhanh; `List` mặc định. |
| | `LinkedList` | Danh sách liên kết đôi | Chèn | Cho phép | Cho phép | Không | Chèn/xóa thường xuyên. |
| **Set** | `HashSet` | `HashMap` | Không có | Không | 1 key | Không | Lưu trữ phần tử duy nhất nhanh nhất. |
| | `LinkedHashSet` | `HashMap` + List | Chèn | Không | 1 key | Không | Phần tử duy nhất với thứ tự có thể dự đoán. |
| | `TreeSet` | Cây Đỏ-Đen | Sắp xếp | Không | Không cho phép | Không | Phần tử duy nhất, được sắp xếp. |
| **Queue** | `PriorityQueue` | Đống nhị phân | Ưu tiên | Cho phép | Không cho phép | Không | Xử lý các mục theo độ ưu tiên. |
| **Deque** | `ArrayDeque` | Mảng tròn | FIFO/LIFO | Cho phép | Không cho phép | Không | Tốt nhất cho triển khai Stack/Queue. |
| **Map** | `HashMap` | Bảng Hash | Không có | Không (key) | 1 key null | Không | Lưu trữ key-value đa năng. |
| | `LinkedHashMap` | Bảng Hash + List | Chèn | Không (key) | 1 key null | Không | Map có thứ tự, bộ đệm LRU. |
| | `TreeMap` | Cây Đỏ-Đen | Sắp xếp | Không (key) | Không key null | Không | Map được sắp xếp, truy vấn phạm vi. |
| **Concurrent** | `ConcurrentHashMap`| Bảng Hash phân đoạn| Không có | Không (key) | Không cho phép | Có | Map an toàn cho luồng hiệu suất cao. |
| **Concurrent** | `CopyOnWriteArrayList`| Mảng bất biến | Chèn | Cho phép | Cho phép | Có | Truy cập danh sách đồng thời, đọc nhiều. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Giải thích hoạt động nội bộ của một `HashMap`. Điều gì xảy ra khi có xung đột?"**
    *   *Trả lời:* Một `HashMap` được hỗ trợ bởi một mảng các "bucket". Khi bạn `put` một phần tử, nó tính toán `hashCode()` của key để xác định chỉ số bucket. Nếu bucket trống, một `Node` mới được đặt ở đó. Nếu bucket không trống (một xung đột), các key trong bucket đó được kiểm tra bằng `equals()`. Nếu một key bằng nhau được tìm thấy, giá trị của nó được cập nhật. Nếu không, `Node` mới được thêm vào cuối một danh sách liên kết tại bucket đó. Từ Java 8, nếu danh sách này phát triển vượt quá một ngưỡng nhất định, nó được chuyển đổi thành một cây cân bằng để cải thiện hiệu suất trong trường hợp xấu nhất từ O(n) thành O(log n).

2.  **"Khi nào bạn sẽ chọn một `ArrayList` thay vì một `LinkedList`?"**
    *   *Trả lời:* Chọn `ArrayList` khi trường hợp sử dụng chính của bạn là truy cập ngẫu nhiên nhanh (sử dụng `get(index)`). Cấu trúc dựa trên mảng của nó cung cấp truy cập O(1). Nó cũng hiệu quả cho việc thêm/xóa ở cuối danh sách. Chọn `LinkedList` khi bạn có tần suất cao các lần chèn và xóa ở giữa danh sách, vì đây là một thao tác O(1) cho `LinkedList` (một khi vị trí được tìm thấy) so với một thao tác dịch chuyển O(n) tốn kém cho `ArrayList`.

3.  **"Sự khác biệt giữa `HashSet`, `LinkedHashSet`, và `TreeSet` là gì?"**
    *   *Trả lời:* Cả ba đều là `Set` và lưu trữ các phần tử duy nhất. Sự khác biệt chính là thứ tự. `HashSet` cung cấp hiệu suất tốt nhất (O(1)) nhưng không cung cấp đảm bảo về thứ tự. `LinkedHashSet` cung cấp hiệu suất O(1) và duy trì thứ tự mà các phần tử đã được chèn. `TreeSet` chậm hơn một chút (O(log n)) nhưng giữ các phần tử trong một thứ tự được sắp xếp liên tục, được định nghĩa bởi thứ tự tự nhiên của chúng (`Comparable`) hoặc một `Comparator` tùy chỉnh.

4.  **"Giải thích sự khác biệt giữa `Comparable` và `Comparator`."**
    *   *Trả lời:* `Comparable` được sử dụng để định nghĩa *thứ tự tự nhiên, duy nhất* cho một lớp. Chính lớp đó triển khai interface `Comparable`. `Comparator` được sử dụng để định nghĩa *các chiến lược sắp xếp bên ngoài, tùy chỉnh, hoặc nhiều chiến lược khác nhau*. Một lớp riêng biệt triển khai interface `Comparator`. Bạn sử dụng `Comparable` cho thứ tự sắp xếp mặc định và `Comparator` khi bạn cần sự linh hoạt, nhiều thứ tự sắp xếp, hoặc không thể sửa đổi mã nguồn của lớp bạn muốn sắp xếp.

5.  **"Tại sao `ConcurrentHashMap` nhanh hơn `Hashtable` hoặc một `synchronizedMap`?"**
    *   *Trả lời:* `Hashtable` và `synchronizedMap` sử dụng một khóa duy nhất cho toàn bộ collection. Điều này có nghĩa là chỉ một luồng có thể truy cập map tại một thời điểm, cho bất kỳ hoạt động nào, gây ra sự tranh chấp cao và khả năng mở rộng kém. `ConcurrentHashMap` sử dụng một cơ chế khóa thông minh hơn (phân mảnh khóa hoặc khóa trên mỗi bucket) cho phép nhiều luồng đọc và ghi vào các phần khác nhau của map đồng thời, dẫn đến thông lượng cao hơn nhiều trong các ứng dụng đa luồng.

---

#### **3. Dự án nhỏ cuối cùng: Xây dựng một hệ thống bảng xếp hạng**

Dự án này sẽ yêu cầu bạn chọn và sử dụng các collection phù hợp để xây dựng một hệ thống theo dõi và hiển thị điểm số của người chơi.

**🎯 Mục tiêu:** Tạo một lớp `Leaderboard` có thể thêm điểm số người chơi mới và lấy ra N người chơi hàng đầu một cách hiệu quả.

**Yêu cầu dự án:**

1.  **Lớp `PlayerScore`:**
    *   Tạo một lớp để chứa `playerId` (String) và `score` (int) của người chơi.
    *   Lớp này phải triển khai `Comparable`. Thứ tự tự nhiên nên là theo điểm theo thứ tự **giảm dần** (điểm cao nhất trước). Nếu điểm bằng nhau, bạn có thể giải quyết bằng thứ tự bảng chữ cái của `playerId`.
    *   Triển khai đúng `equals()` và `hashCode()` dựa trên `playerId`.

2.  **Lớp `Leaderboard`:**
    *   `Leaderboard` nên lưu trữ các điểm số. Bạn cần chọn đúng (các) collection để đáp ứng các yêu cầu.
    *   **Gợi ý:** Bạn có thể sẽ cần hai collection hoạt động cùng nhau:
        *   Một để cung cấp các cập nhật và tra cứu nhanh cho điểm số của một người chơi. Collection nào là tốt nhất cho `get(playerId)` và `put(playerId, newScore)`? Một `Map` sẽ là lý tưởng.
        *   Một cái khác để giữ các điểm số được sắp xếp mọi lúc để dễ dàng lấy ra những người chơi hàng đầu. Collection nào là tốt nhất cho việc này? Một `TreeSet` hoặc `PriorityQueue`.

3.  **Các Method của `Leaderboard`:**
    *   **`addOrUpdateScore(String playerId, int score)`:**
        *   Nếu người chơi là mới, hãy thêm điểm của họ.
        *   Nếu người chơi đã tồn tại, chỉ cập nhật điểm của họ nếu điểm mới cao hơn điểm cũ. Method này cần phải hiệu quả.
    *   **`getTopPlayers(int n)`:**
        *   Trả về một `List` của `n` object `PlayerScore` hàng đầu một cách hiệu quả. Đây phải là một hoạt động nhanh.

4.  **Chiến lược triển khai:**
    *   Sử dụng một `Map<String, PlayerScore>` để tra cứu nhanh theo `playerId`.
    *   Sử dụng một `TreeSet<PlayerScore>` để giữ tất cả các điểm số được sắp xếp.
    *   Khi cập nhật một điểm số, bạn phải trước tiên xóa object `PlayerScore` cũ khỏi `TreeSet` và sau đó thêm cái mới vào, bởi vì một `TreeSet` không thể tự sắp xếp lại nếu bạn thay đổi một object đã ở bên trong nó.

**Ví dụ sử dụng:**`
```java
    public static void main(String[] args) {
    Leaderboard leaderboard = new Leaderboard();

    leaderboard.addOrUpdateScore("player1", 100);
    leaderboard.addOrUpdateScore("player2", 150);
    leaderboard.addOrUpdateScore("player3", 80);
    leaderboard.addOrUpdateScore("player1", 120); // Cập nhật điểm của player1

    System.out.println("Top 2 Players: " + leaderboard.getTopPlayers(2));
    // Đầu ra dự kiến có thể là: [PlayerScore{playerId='player2', score=150}, PlayerScore{playerId='player1', score=120}]
}
```

Dự án này sẽ thách thức bạn suy nghĩ chín chắn về hiệu suất và các tính năng của các collection khác nhau và kết hợp chúng để xây dựng một hệ thống hiệu quả và mạnh mẽ.

