Chắc chắn rồi, đây là phần dịch tiếp theo.

### **Bài 1: Hiểu về Hệ thống phân cấp Exception**

#### **1. Giải thích khái niệm**

##### **Exception là gì?**
Một exception là một sự kiện làm gián đoạn luồng thực thi bình thường của các chỉ thị của một chương trình. Khi một sự kiện như vậy xảy ra, Java Virtual Machine (JVM) tạo ra một object `Exception` chứa thông tin về lỗi (như loại lỗi và trạng thái của chương trình khi nó xảy ra) và "ném" (throws) nó. Quá trình này dừng việc thực thi bình thường và bắt đầu tìm kiếm mã có thể xử lý vấn đề.

Mục đích chính của việc xử lý exception là để tách biệt logic nghiệp vụ chính của một method khỏi mã xử lý các tình huống ngoại lệ, thường là không mong đợi. Điều này dẫn đến mã sạch hơn, dễ đọc hơn và mạnh mẽ hơn.

##### **Hệ thống phân cấp `Throwable`**
Trong Java, tất cả các exception và error đều là các object kế thừa từ lớp `java.lang.Throwable`. Lớp này là gốc của toàn bộ hệ thống phân cấp exception. Nó có hai lớp con trực tiếp: `Error` và `Exception`.

```
                  +-----------------+
                  |   java.lang.    |
                  |   Throwable     |
                  +-----------------+
                         /   \
                        /     \
              +-----------+   +---------------+
              |   Error   |   |   Exception   |
              +-----------+   +---------------+
                                   /       \
                                  /         \
                 +-------------------+   +--------------------+
                 |   Checked         |   |   RuntimeException |
                 |   Exceptions      |   |   (Unchecked)      |
                 | (ví dụ: IOException) |   | (ví dụ: NullPointer)|
                 +-------------------+   +--------------------+
```

##### **`Error` vs. `Exception`**

*   **`Error`:** Đại diện cho các vấn đề nghiêm trọng, bất thường nằm ngoài ứng dụng và một ứng dụng hợp lý không nên cố gắng bắt (catch). Đây thường là các vấn đề không thể phục hồi liên quan đến chính JVM.
    *   **Ví dụ:** `OutOfMemoryError` (JVM đã hết bộ nhớ), `StackOverflowError` (các cuộc gọi method lồng nhau quá sâu), `LinkageError`.
    *   **Quy tắc:** Bạn gần như không bao giờ nên bắt một `Error`. Nếu một `Error` xảy ra, hành động tốt nhất thường là để chương trình kết thúc và chẩn đoán vấn đề cấp hệ thống cơ bản.

*   **`Exception`:** Đại diện cho các điều kiện mà một ứng dụng hợp lý *có thể* muốn bắt và xử lý. Đây là những vấn đề có thể xảy ra trong quá trình hoạt động bình thường nhưng nằm ngoài tầm kiểm soát ngay lập tức của chương trình. Lớp `Exception` được chia thành hai loại quan trọng: checked và unchecked.

##### **Checked vs. Unchecked Exceptions**

Đây là sự phân biệt quan trọng nhất trong hệ thống xử lý exception của Java.

1.  **Checked Exceptions:**
    *   **Định nghĩa:** Tất cả các lớp kế thừa từ `Exception` nhưng **không** kế thừa từ `RuntimeException`.
    *   **Thực thi của trình biên dịch:** Trình biên dịch Java *kiểm tra* tại thời điểm biên dịch rằng bạn đã xử lý các exception này. Bạn phải bắt chúng trong một khối `try-catch` hoặc khai báo rằng method của bạn có thể ném chúng bằng cách sử dụng từ khóa `throws` trong chữ ký của method.
    *   **Mục đích:** Chúng đại diện cho các điều kiện lỗi có thể dự đoán, có thể phục hồi thường nằm ngoài logic chương trình, chẳng hạn như lỗi mạng (`SocketException`), lỗi hệ thống tệp (`IOException`), hoặc các vấn đề kết nối cơ sở dữ liệu (`SQLException`). Chúng buộc lập trình viên phải suy nghĩ và xử lý các kịch bản lỗi tiềm ẩn.

2.  **Unchecked Exceptions (Runtime Exceptions):**
    *   **Định nghĩa:** Tất cả các lớp kế thừa từ `RuntimeException`. Các `Error` cũng là unchecked, nhưng thuật ngữ này thường dùng để chỉ các `RuntimeException`.
    *   **Thực thi của trình biên dịch:** Trình biên dịch **không** kiểm tra xem bạn có xử lý chúng hay không. Bạn không bắt buộc phải sử dụng khối `try-catch` hoặc mệnh đề `throws`.
    *   **Mục đích:** Chúng thường đại diện cho **lỗi lập trình (bug)**, chẳng hạn như các sai sót logic, sử dụng API không đúng cách, hoặc các vi phạm khác về các điều kiện tiên quyết.
    *   **Ví dụ:** `NullPointerException` (cố gắng sử dụng một tham chiếu `null`), `IllegalArgumentException` (truyền một đối số không hợp lệ vào một method), `ArrayIndexOutOfBoundsException` (truy cập một mảng với một chỉ số bất hợp pháp). Ý tưởng là bạn nên sửa mã để ngăn chặn những điều này xảy ra, thay vì bắt chúng.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này cho thấy cách đối xử khác nhau của trình biên dịch đối với các checked và unchecked exception.

```java
import java.io.FileReader;
import java.io.FileNotFoundException;

public class ExceptionTypesDemo {

    // 1. Method xử lý một CHECKED exception
    // Trình biên dịch BẮT BUỘC chúng ta phải xử lý FileNotFoundException.
    // Chúng ta chọn khai báo nó với 'throws'.
    public static void readSomeFile(String filename) throws FileNotFoundException {
        // Dòng này có thể ném ra một checked FileNotFoundException.
        FileReader reader = new FileReader(filename);
        System.out.println("File found and opened.");
        // ... logic đọc file ...
    }

    // 2. Method xử lý một UNCHECKED exception
    // Chúng ta KHÔNG bắt buộc phải khai báo NullPointerException.
    public static void printStringLength(String text) {
        // Nếu 'text' là null, dòng này sẽ ném ra một unchecked NullPointerException.
        System.out.println("Length is: " + text.length());
    }

    public static void main(String[] args) {
        // Chúng ta phải xử lý checked exception từ readSomeFile()
        try {
            readSomeFile("my-file.txt");
        } catch (FileNotFoundException e) {
            System.out.println("ERROR: The file was not found.");
        }

        // Chúng ta không bị buộc phải xử lý unchecked exception tiềm ẩn.
        // Điều này sẽ làm chương trình bị sập nếu một giá trị null được truyền vào.
        printStringLength(null);
    }
}
```

---

#### **3. Bài tập nhỏ**

Hãy xem xét các lớp exception Java phổ biến sau. Đối với mỗi lớp, hãy phân loại nó là **Checked** hoặc **Unchecked**. Bạn có thể cần đoán hoặc tra cứu hệ thống phân cấp của chúng.

1.  `java.sql.SQLException`
2.  `java.lang.ArrayIndexOutOfBoundsException`
3.  `java.lang.InterruptedException`
4.  `java.lang.NumberFormatException`
5.  `java.net.SocketTimeoutException`

*(Đáp án: 1. Checked, 2. Unchecked, 3. Checked, 4. Unchecked, 5. Checked)*

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều nào sau đây mô tả đúng nhất sự khác biệt cơ bản giữa `java.lang.Error` và `java.lang.Exception`?

A) `Error` là một checked exception, trong khi `Exception` là một unchecked exception.
B) `Error` thường đại diện cho các lỗi cấp hệ thống không thể phục hồi mà không nên bắt, trong khi `Exception` đại diện cho các điều kiện mà một ứng dụng có thể xử lý một cách hợp lý.
C) `Error` chỉ có thể được ném bởi JVM, trong khi `Exception` chỉ có thể được ném bởi mã ứng dụng.
D) `Error` không tạo ra một stack trace, trong khi `Exception` thì có.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) `Error` thường đại diện cho các lỗi cấp hệ thống không thể phục hồi mà không nên bắt, trong khi `Exception` đại diện cho các điều kiện mà một ứng dụng có thể xử lý một cách hợp lý.

### **Bài 2: `try-catch-finally` và Sự lan truyền Exception**

#### **1. Giải thích khái niệm**

##### **Khối `try-catch-finally`**

Đây là cơ chế cơ bản để xử lý exception trong Java.

*   **Khối `try`:** Bao bọc đoạn mã "được bảo vệ" có thể ném ra một exception. JVM giám sát khối này.
*   **Khối `catch`:** Đây là trình xử lý exception. Nó chỉ được thực thi nếu một exception của một loại được chỉ định (hoặc subtype của nó) được ném ra trong khối `try`. Bạn có thể có nhiều khối `catch` để xử lý các loại exception khác nhau.
*   **Khối `finally`:** Khối này **luôn luôn** được thực thi, bất kể điều gì xảy ra trong các khối `try` và `catch`. Nó thực thi cho dù một exception có được ném ra hay không, và cho dù một exception bị bắt có được xử lý hay không.

**Trường hợp sử dụng chính của `finally` là dọn dẹp tài nguyên.** Nó đảm bảo rằng mã dọn dẹp quan trọng (như đóng một tệp, một kết nối cơ sở dữ liệu, hoặc một socket mạng) sẽ chạy, ngăn chặn rò rỉ tài nguyên.

**Các kịch bản thứ tự thực thi:**
1.  **Không có Exception:** `try` → `finally`. Khối `catch` được bỏ qua.
2.  **Exception được ném và bị bắt:** `try` (dừng lại tại exception) → `catch` → `finally`.
3.  **Exception được ném và không bị bắt:** `try` (dừng lại tại exception) → `finally` → exception lan truyền lên call stack.
4.  **Khối `try` hoặc `catch` có một câu lệnh `return`:** Câu lệnh `return` được chuẩn bị, sau đó khối `finally` thực thi, và cuối cùng, giá trị được trả về. **Điểm quan trọng:** Nếu khối `finally` cũng có một câu lệnh `return`, nó sẽ *ghi đè* giá trị trả về từ khối `try` hoặc `catch`. Đây được coi là một thực hành rất tồi.

##### **Sự lan truyền Exception (Stack Unwinding)**

Khi một method ném ra một exception, đường dẫn thực thi bình thường của JVM bị tạm dừng. JVM sau đó bắt đầu một quá trình được gọi là **sự lan truyền exception** hoặc **tháo dỡ ngăn xếp (stack unwinding)**.

1.  **Method ném:** Method A ném ra một exception. JVM ngay lập tức ngừng thực thi Method A.
2.  **Kiểm tra Trình xử lý:** JVM kiểm tra xem Method A có một khối `try-catch` có thể xử lý loại exception cụ thể này hay không.
3.  **Tháo dỡ Ngăn xếp:**
    *   Nếu không tìm thấy trình xử lý nào trong Method A, JVM kết thúc Method A và "tháo dỡ" call stack, quay trở lại điểm mà Method A được gọi (ví dụ: trong Method B).
    *   Quá trình lặp lại: JVM bây giờ kiểm tra xem Method B có một trình xử lý phù hợp hay không.
    *   Điều này tiếp tục trên toàn bộ call stack.
4.  **Kết thúc chương trình:** Nếu exception lan truyền lên đến method `main` và vẫn không được bắt, luồng sẽ kết thúc, và stack trace của exception được in ra console.

**Sơ đồ Stack Unwinding:**
```
+---------------+
|   main()      |  <-- 3. Exception đến đây. Không có trình xử lý? Luồng kết thúc.
+---------------+
       ^
       | calls
+---------------+
|   methodB()   |  <-- 2. Không tìm thấy trình xử lý. Tháo dỡ đến main().
+---------------+
       ^
       | calls
+---------------+
|   methodA()   |  <-- 1. Exception được ném ra. Không tìm thấy trình xử lý. Tháo dỡ đến methodB().
+---------------+
```

##### **`throw` vs. `throws`**

Hai từ khóa này thường bị nhầm lẫn nhưng có ý nghĩa rất khác nhau.

*   **`throw`:** Một **hành động**. Nó được sử dụng để thực sự ném một object exception. Bạn sử dụng nó bên trong thân của một method để báo hiệu rằng một điều kiện ngoại lệ đã xảy ra.
    `throw new IllegalArgumentException("Amount must be positive.");`

*   **`throws`:** Một **khai báo**. Nó được sử dụng trong chữ ký của một method để khai báo rằng method *có thể* ném một hoặc nhiều checked exception. Nó là một cảnh báo cho bất kỳ mã nào gọi method này rằng nó phải chuẩn bị để xử lý các exception đó.
    `public void readFile() throws IOException, InterruptedException { ... }`

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa luồng thực thi của `try-catch-finally` và sự lan truyền exception.

```java
public class PropagationDemo {

    // Method 3: Nguồn gốc của exception
    public static void performCalculation(int divisor) {
        System.out.println("Entering performCalculation...");
        if (divisor == 0) {
            // Unchecked exception được ném ra ở đây
            throw new ArithmeticException("Division by zero");
        }
        System.out.println("Leaving performCalculation..."); // Dòng này bị bỏ qua
    }

    // Method 2: Gọi method có vấn đề nhưng không xử lý exception
    public static void processData() {
        System.out.println("Entering processData...");
        try {
            performCalculation(0); // Exception lan truyền từ đây
        } finally {
            // Khối finally này SẼ thực thi trước khi exception lan truyền xa hơn
            System.out.println("processData's finally block executed.");
        }
        System.out.println("Leaving processData..."); // Dòng này bị bỏ qua
    }

    // Method 1 (main): Gọi method xử lý và xử lý exception
    public static void main(String[] args) {
        System.out.println("Entering main...");
        try {
            processData(); // Exception lan truyền đến đây
        } catch (ArithmeticException e) {
            // Exception cuối cùng đã được bắt và xử lý.
            System.out.println("CAUGHT in main: " + e.getMessage());
        }
        System.out.println("Leaving main...");
    }
}
```
**Đầu ra của mã:**
```
Entering main...
Entering processData...
Entering performCalculation...
processData's finally block executed.
CAUGHT in main: Division by zero
Leaving main...```

---

#### **3. Bài tập nhỏ**

Tạo một method `int getNumber()` có thể ném ra một checked exception tùy chỉnh `MyInputException`.
1.  Bên trong một khối `try`, nhắc người dùng nhập một số.
2.  Nếu đầu vào không phải là một số nguyên hợp lệ, việc phân tích cú pháp sẽ ném ra một `NumberFormatException`. Bắt lỗi này và `throw new MyInputException("Invalid input, not a number.");`.
3.  Thêm một khối `finally` in ra "Finished attempting to read number."
4.  Trong method `main` của bạn, hãy gọi `getNumber()`. Bạn sẽ bị buộc phải xử lý `MyInputException`.
5.  Chạy chương trình hai lần: một lần với một số hợp lệ và một lần với văn bản không hợp lệ, và quan sát đường dẫn thực thi và đầu ra trong cả hai trường hợp.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Đầu ra của đoạn mã sau là gì?
```java
public static int testFinally() {
    try {
        return 1;
    } catch (Exception e) {
        return 2;
    } finally {
        return 3;
    }
}
// Trong main: System.out.println(testFinally());
```
A) 1
B) 2
C) 3
D) Nó sẽ không biên dịch.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) 3. Đây là một câu hỏi mẹo kinh điển. `return 1` trong khối `try` được chuẩn bị. Tuy nhiên, trước khi method thực sự trả về, khối `finally` **phải** thực thi. Vì khối `finally` cũng có một câu lệnh `return`, nó "chiếm quyền" quá trình trả về và method ngay lập tức trả về `3`. Giá trị trả về ban đầu là `1` bị loại bỏ. Đây là lý do tại sao việc có một câu lệnh `return` trong một khối `finally` là một thực hành rất tồi.

### **Bài 3: Checked vs. Unchecked Exceptions - Một cái nhìn sâu hơn**

#### **1. Giải thích khái niệm**

Chúng ta đã giới thiệu sự khác biệt giữa checked và unchecked exception, nhưng việc thiết kế các API mạnh mẽ đòi hỏi một sự hiểu biết sâu sắc hơn về triết lý và sự đánh đổi đằng sau chúng. Quyết định liệu có nên làm cho một exception tùy chỉnh trở thành checked hay unchecked là một lựa chọn thiết kế quan trọng.

##### **Triết lý của Checked Exceptions**

*   **Buộc phải phục hồi:** Checked exception được thiết kế cho các điều kiện mà từ đó chương trình thường có thể **phục hồi một cách thực tế**. Trình biên dịch buộc mã gọi phải đối mặt với khả năng thất bại.
*   **Hợp đồng API:** Sử dụng một checked exception là một tuyên bố mạnh mẽ trong hợp đồng của API của bạn. Bạn đang nói với các client của mình: "Thao tác này có thể thất bại vì lý do cụ thể, có thể dự đoán được này. Bạn *phải* có một kế hoạch để xử lý nó."
*   **Các yếu tố bên ngoài:** Chúng được sử dụng tốt nhất cho các lỗi nằm ngoài tầm kiểm soát ngay lập tức của mã của lập trình viên, chẳng hạn như:
    *   Các vấn đề về hệ thống tệp (`IOException`)
    *   Các vấn đề về kết nối mạng (`SocketException`)
    *   Cơ sở dữ liệu không khả dụng (`SQLException`)
    *   Cấu hình không hợp lệ (`MalformedURLException`)

**Ưu điểm:**
*   **Tài liệu API:** Mệnh đề `throws` ghi lại rõ ràng các lỗi tiềm ẩn của một method.
*   **Tính mạnh mẽ:** Buộc các nhà phát triển xây dựng logic phục hồi và dự phòng, dẫn đến các ứng dụng có khả năng phục hồi cao hơn.

**Nhược điểm:**
*   **Tính dài dòng (Boilerplate):** Có thể dẫn đến mã lộn xộn với nhiều khối `try-catch`, đặc biệt nếu các exception không được xử lý tốt ở lớp kiến trúc phù hợp.
*   **Trừu tượng bị rò rỉ (Leaky Abstractions):** Nếu một chi tiết triển khai cấp thấp (như một `SQLException`) được khai báo trên một method nghiệp vụ cấp cao, nó "rò rỉ" chi tiết triển khai cho client. Điều này thường được giải quyết bằng cách bao bọc checked exception trong một unchecked exception tùy chỉnh.

##### **Triết lý của Unchecked (Runtime) Exceptions**

*   **Chỉ ra Bug:** Unchecked exception chủ yếu dành cho các điều kiện phản ánh **lỗi lập trình** hoặc vi phạm các điều kiện tiên quyết của một method. Chúng chỉ ra một tình huống mà chương trình không thể phục hồi một cách thực tế và không nên được mong đợi sẽ làm vậy. Vấn đề nên được sửa chữa trong mã.
*   **Hợp đồng API:** Sử dụng một unchecked exception là một tuyên bố trong hợp đồng API của bạn nói rằng: "Nếu bạn sử dụng method này một cách chính xác, exception này sẽ không bao giờ xảy ra. Nếu nó xảy ra, đó là một bug trong mã gọi của bạn."
*   **Các yếu tố nội bộ:** Chúng được sử dụng tốt nhất cho các lỗi nằm trong tầm kiểm soát của lập trình viên, chẳng hạn như:
    *   Các đối số không hợp lệ (`IllegalArgumentException`)
    *   Các tham số null (`NullPointerException`)
    *   Trạng thái bất hợp pháp (`IllegalStateException` - ví dụ: gọi `connect()` trên một object đã được kết nối)
    *   Lỗi chỉ số mảng (`ArrayIndexOutOfBoundsException`)

**Ưu điểm:**
*   **Mã sạch hơn:** Tránh sự lộn xộn của các khối `try-catch` đối với các lỗi về cơ bản là bug.
*   **Thất bại nhanh (Fail-Fast):** Cho phép chương trình bị sập gần nguồn gốc của bug, giúp dễ dàng xác định và sửa chữa hơn.

**Nhược điểm:**
*   **Nguy hiểm tiềm ẩn:** Trình biên dịch không buộc bạn phải xử lý chúng, vì vậy một lỗi tiềm ẩn có thể không được chú ý cho đến khi nó làm sập ứng dụng trong môi trường sản xuất.

##### **Tình huống khó xử trong thiết kế: "Nếu một client có thể được mong đợi một cách hợp lý để phục hồi từ một exception, hãy biến nó thành một checked exception. Nếu một client không thể làm gì để phục hồi từ exception đó, hãy biến nó thành một unchecked exception."** - *Joshua Bloch, Effective Java*

Đây là quy tắc vàng. Trước khi tạo một exception tùy chỉnh, hãy tự hỏi mình: "Mã gọi *thực sự có thể làm gì* nếu điều này xảy ra?"
*   Nếu câu trả lời là "thử lại thao tác, thử một máy chủ khác, hoặc nhắc người dùng cung cấp một đường dẫn tệp mới," đó là một ứng cử viên tốt cho một **checked exception**.
*   Nếu câu trả lời là "không có gì, đầu vào không hợp lệ, điều này không bao giờ nên xảy ra, điều duy nhất cần làm là ghi lại lỗi và sập chương trình," nó nên là một **unchecked exception**.

---

#### **2. Ví dụ mã nguồn: Lựa chọn thiết kế API**

Hãy tưởng tượng việc thiết kế một API tài khoản ngân hàng đơn giản.

##### **Kịch bản 1: Rút tiền (Một điều kiện có thể phục hồi?)**
Một người dùng cố gắng rút nhiều tiền hơn số họ có là một sự kiện có thể dự đoán, phổ biến. Ứng dụng có thể phục hồi bằng cách hiển thị một thông báo "Không đủ tiền". Điều này làm cho nó trở thành một ứng cử viên tốt cho một **checked exception** tùy chỉnh.

```java
// Một checked exception tùy chỉnh
class InsufficientFundsException extends Exception {
    private final double deficit;
    public InsufficientFundsException(String message, double deficit) {
        super(message);
        this.deficit = deficit;
    }
    public double getDeficit() { return deficit; }
}

class BankAccount {
    private double balance;
    // ... constructor ...

    // Mệnh đề 'throws' là một phần rõ ràng của hợp đồng API.
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount <= 0) {
            // Đây là một lỗi lập trình, không phải là một điều kiện có thể phục hồi.
            throw new IllegalArgumentException("Withdrawal amount must be positive.");
        }
        if (this.balance < amount) {
            // Đây là một điều kiện có thể phục hồi.
            throw new InsufficientFundsException("Insufficient funds", amount - this.balance);
        }
        this.balance -= amount;
    }
}

// Mã client BỊ BUỘC phải xử lý lỗi có thể phục hồi.
class BankApp {
    public void performWithdrawal(BankAccount account, double amount) {
        try {
            account.withdraw(amount);
            System.out.println("Withdrawal successful.");
        } catch (InsufficientFundsException e) {
            System.err.println("Transaction failed: " + e.getMessage());
            System.err.printf("You are short by $%.2f\n", e.getDeficit());
            // Giao diện người dùng bây giờ có thể hiển thị một thông báo hữu ích.
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn đang tạo một lớp `UserRegistry`. Nó có một method `User findUserById(String id)`.
1.  Quyết định điều gì sẽ xảy ra nếu không tìm thấy người dùng với `id` đã cho.
    *   Đây có nên là một checked hay một unchecked exception?
    *   Giải thích lựa chọn của bạn dựa trên nguyên tắc "client có thể phục hồi được không?". Một client có thể làm gì một cách hợp lý trong tình huống này?
2.  Tạo một exception tùy chỉnh cho kịch bản này (ví dụ: `UserNotFoundException`).
3.  Triển khai method `findUserById` trong một lớp `UserRegistry` giả. Nếu không tìm thấy người dùng, hãy ném ra exception mới của bạn.
4.  Trong `main`, hãy gọi method này và xử lý exception một cách thích hợp dựa trên việc bạn đã chọn checked hay unchecked.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Method của bạn kết nối với một cổng thanh toán của bên thứ ba qua mạng. Kết nối có thể bị hết thời gian chờ. Thời gian chờ này là điều mà mã gọi có thể xử lý bằng cách thử lại yêu cầu sau vài giây. Theo các thực hành tốt nhất, loại exception nào mà method của bạn nên ném ra để báo hiệu thời gian chờ này?

A) Một unchecked exception tùy chỉnh, như `PaymentGatewayTimeoutRuntimeException`.
B) `java.lang.Error`, vì mạng là một hệ thống bên ngoài.
C) Một `java.lang.RuntimeException` tiêu chuẩn.
D) Một checked exception tùy chỉnh, như `PaymentGatewayTimeoutException`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Một checked exception tùy chỉnh, như `PaymentGatewayTimeoutException`. Một thời gian chờ mạng là một ví dụ kinh điển về một điều kiện bên ngoài, có thể phục hồi. Ứng dụng client không thể ngăn chặn nó, nhưng nó *có thể* được mong đợi một cách hợp lý để có một chiến lược phục hồi (như thử lại). Việc buộc client phải xử lý điều này bằng một checked exception dẫn đến một hệ thống mạnh mẽ hơn.

### **Bài 4: Custom Exceptions và Các thực hành tốt nhất**

#### **1. Giải thích khái niệm**

Mặc dù Java cung cấp một bộ phong phú các lớp exception tiêu chuẩn, chúng thường quá chung chung để mô tả một lỗi cụ thể trong miền ứng dụng của bạn. Việc tạo ra các **lớp exception tùy chỉnh** của riêng bạn là một cách mạnh mẽ để cải thiện sự rõ ràng, dễ đọc và khả năng bảo trì của mã xử lý lỗi của bạn.

##### **Tại sao nên tạo Custom Exceptions?**

1.  **Tính cụ thể và rõ ràng:** Một `UserNotFoundException` mô tả rõ ràng hơn nhiều so với một `IllegalArgumentException` chung chung. Nó ngay lập tức cho nhà phát triển biết điều gì đã sai.
2.  **Các khối `catch` chi tiết:** Nó cho phép các client viết các khối `catch` cụ thể để xử lý các kịch bản lỗi tùy chỉnh của bạn, tách chúng khỏi các lỗi khác, chung chung hơn.
3.  **Mang theo thông tin bổ sung:** Bạn có thể thêm các trường tùy chỉnh vào lớp exception của mình để mang theo thông tin ngữ cảnh có giá trị về lỗi. Ví dụ, một `InvalidOrderException` có thể mang theo `orderId` và một danh sách các lỗi xác thực.
4.  **Nối chuỗi Exception (Wrapping):** Custom exception là cần thiết cho mẫu "dịch exception", nơi bạn bắt một exception cấp thấp, cụ thể về triển khai (như `SQLException`) và ném lại nó như một exception cấp cao hơn, cụ thể về ứng dụng (như `DataAccessException`).

##### **Cách tạo một Custom Exception**

Việc tạo một custom exception cũng đơn giản như việc kế thừa lớp cha phù hợp.

1.  **Chọn Lớp cha:**
    *   Kế thừa **`Exception`** nếu bạn muốn tạo một **checked exception**. Làm điều này cho các lỗi có thể phục hồi, có thể dự đoán mà bạn muốn buộc các client phải xử lý (ví dụ: các vi phạm quy tắc nghiệp vụ như `InsufficientFundsException`).
    *   Kế thừa **`RuntimeException`** nếu bạn muốn tạo một **unchecked exception**. Làm điều này cho các lỗi lập trình hoặc vi phạm các điều kiện tiên quyết (ví dụ: `ResourceNotFoundException` khi một ID lẽ ra phải tồn tại).

2.  **Tuân thủ quy ước đặt tên:** Tên lớp nên kết thúc bằng hậu tố `Exception`.

3.  **Cung cấp các Constructor tiêu chuẩn:** Đây là một quy ước mạnh mẽ để cung cấp bốn constructor tương tự như `Throwable` cung cấp:
    *   Một constructor không có đối số.
    *   Một constructor chấp nhận một `String message`.
    *   Một constructor chấp nhận một `Throwable cause` (cho việc nối chuỗi exception).
    *   Một constructor chấp nhận cả một `String message` và một `Throwable cause`.

##### **Nối chuỗi Exception**

Nối chuỗi exception là thực hành bao bọc một exception bị bắt bên trong một exception mới, cụ thể hơn. Exception ban đầu được gọi là "nguyên nhân" (cause). Điều này rất quan trọng để không làm mất nguyên nhân gốc rễ của một lỗi.

*   **Tại sao?** Nó ngăn chặn các chi tiết triển khai cấp thấp bị rò rỉ vào các tầng cao hơn của ứng dụng. Tầng nghiệp vụ không nên biết hoặc quan tâm đến `SQLException`; nó chỉ nên quan tâm đến `DataAccessException`. Bằng cách bao bọc `SQLException`, bạn che giấu chi tiết nhưng bảo toàn stack trace ban đầu để gỡ lỗi.
*   **Làm thế nào?** Bạn truyền exception ban đầu (`e`) vào constructor của exception mới của bạn, sau đó gọi `super(message, cause)`.

---

#### **2. Ví dụ mã nguồn: Custom Exception với Nối chuỗi**

Ví dụ này minh họa việc tạo một checked exception tùy chỉnh mang theo dữ liệu bổ sung và sử dụng nối chuỗi exception.

```java
import java.sql.SQLException;

// 1. Tạo một CHECKED exception tùy chỉnh
public class DataAccessException extends Exception {

    // Trường tùy chỉnh để mang theo ngữ cảnh bổ sung
    private final String sqlQuery;

    // 2. Cung cấp các constructor tiêu chuẩn
    public DataAccessException(String message, String sqlQuery) {
        super(message);
        this.sqlQuery = sqlQuery;
    }

    // Constructor cho việc nối chuỗi exception
    public DataAccessException(String message, String sqlQuery, Throwable cause) {
        super(message, cause); // Truyền 'cause' cho lớp cha
        this.sqlQuery = sqlQuery;
    }

    public String getSqlQuery() {
        return sqlQuery;
    }
}

// Tầng truy cập dữ liệu (Cấp thấp)
class UserRepository {
    public void findUserById(String id) throws DataAccessException {
        String query = "SELECT * FROM users WHERE id = '" + id + "'";
        try {
            // Mô phỏng một lỗi cơ sở dữ liệu
            throw new SQLException("Connection timeout");
        } catch (SQLException e) {
            // 3. Nối chuỗi Exception: Bắt exception cấp thấp và bao bọc nó.
            // Đừng để SQLException rò rỉ ra khỏi tầng này.
            throw new DataAccessException("Failed to execute user query", query, e);
        }
    }
}

// Tầng dịch vụ (Cấp cao)
public class UserService {
    public static void main(String[] args) {
        UserRepository repo = new UserRepository();
        try {
            repo.findUserById("123");
        } catch (DataAccessException dae) {
            System.err.println("--- APPLICATION ERROR ---");
            System.err.println("Message: " + dae.getMessage());
            System.err.println("Failed Query: " + dae.getSqlQuery());

            // Lấy nguyên nhân ban đầu để gỡ lỗi/ghi log
            Throwable cause = dae.getCause();
            if (cause != null) {
                System.err.println("Root Cause: " + cause.getMessage());
                // Trong một ứng dụng thực tế, bạn sẽ ghi log toàn bộ stack trace của nguyên nhân.
                // dae.printStackTrace();
            }
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một **unchecked** exception tùy chỉnh có tên `InvalidProductException`.
2.  Exception này nên kế thừa `RuntimeException`.
3.  Thêm một trường `private final String productId` vào nó.
4.  Cung cấp một constructor chấp nhận một `message` và một `productId`.
5.  Tạo một lớp `ProductValidator` với một method `static` `void validate(Product product)`.
6.  Method `validate` nên kiểm tra xem giá của sản phẩm có âm không. Nếu có, nó nên `throw new InvalidProductException("Price cannot be negative", product.getId())`.
7.  Trong `main`, tạo một sản phẩm có giá âm và gọi trình xác thực. Bắt exception và in ra thông báo tùy chỉnh và `productId` không hợp lệ.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều nào sau đây là lý do **ít phù hợp nhất** để tạo một lớp exception tùy chỉnh mới?

A) Để cung cấp thông tin cụ thể hơn về một lỗi so với một lớp exception tiêu chuẩn cho phép.
B) Để cho phép một client bắt exception cụ thể của bạn một cách riêng biệt với các exception khác.
C) Để làm cho mã của bạn biên dịch được bằng cách thỏa mãn một mệnh đề `throws`.
D) Để bao bọc một exception cấp thấp hơn để ngăn chặn rò rỉ chi tiết triển khai.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Để làm cho mã của bạn biên dịch được bằng cách thỏa mãn một mệnh đề `throws`. Mặc dù việc tạo một lớp exception sẽ làm hài lòng trình biên dịch, đó là một lý do rất tồi nếu chỉ có vậy. Thông thường, điều này dẫn đến các thực hành tồi như bắt một exception rộng và bao bọc nó chỉ để "chuyển nó lên", mà không thêm bất kỳ giá trị hoặc ngữ cảnh nào. Quyết định của bạn nên được thúc đẩy bởi nhu cầu về sự rõ ràng, tính cụ thể, và thiết kế API tốt hơn, không chỉ là để làm hài lòng trình biên dịch.

### **Bài 5: `try-with-resources` và Suppressed Exceptions**

#### **1. Giải thích khái niệm**

##### **Vấn đề: Rò rỉ tài nguyên trong các khối `finally`**
Trước Java 7, việc đóng tài nguyên một cách đúng đắn (như các file stream, kết nối cơ sở dữ liệu, hoặc socket mạng) rất dài dòng và phức tạp một cách đáng ngạc nhiên. Một khối `finally` được yêu cầu để đảm bảo rằng method `close()` sẽ được gọi.

**Cách cũ, dài dòng:**
```java
FileReader fr = null;
try {
    fr = new FileReader("file.txt");
    // ... làm việc với fr ...
} catch (IOException e) {
    // xử lý lỗi
} finally {
    // Đây là khối dọn dẹp
    if (fr != null) {
        try {
            fr.close(); // Chính method close() có thể ném ra một IOException!
        } catch (IOException e) {
            // Chúng ta làm gì ở đây? Exception ban đầu quan trọng hơn.
            e.printStackTrace();
        }
    }
}
```
Mẫu này có hai vấn đề chính:
1.  **Mã soạn sẵn (Boilerplate):** Mã xấu xí và làm sao lãng khỏi logic chính.
2.  **Exception bị nuốt (Swallowed Exceptions):** Nếu mã trong khối `try` ném ra một exception, và `fr.close()` trong khối `finally` *cũng* ném ra một exception, thì exception thứ hai từ khối `finally` sẽ là cái được lan truyền lên call stack. Exception ban đầu, quan trọng hơn từ khối `try` bị mất ("bị nuốt").

##### **Giải pháp: `try-with-resources`**
Java 7 đã giới thiệu câu lệnh `try-with-resources` để giải quyết vấn đề này một cách thanh lịch. Nó tự động hóa quá trình đóng tài nguyên.

*   **Interface `AutoCloseable`:** Phép màu đằng sau `try-with-resources` là interface `java.lang.AutoCloseable` (và sub-interface của nó là `java.io.Closeable`). Interface này có một method duy nhất: `void close() throws Exception`. Bất kỳ lớp nào triển khai interface này đều có thể được sử dụng trong một câu lệnh `try-with-resources`.

*   **Cú pháp:** Bạn khai báo và khởi tạo tài nguyên trong một cặp ngoặc đơn `()` sau từ khóa `try`. Bạn có thể khai báo nhiều tài nguyên, được phân tách bằng dấu chấm phẩy.
    ```java
    try (ResourceType resource1 = new ResourceType();
         ResourceType resource2 = new ResourceType()) {
        // ... sử dụng resource1 và resource2 ...
    } // resource2.close() và resource1.close() được gọi tự động ở đây.
    ```
*   **Cách hoạt động bên trong:** Trình biên dịch viết lại khối `try-with-resources` thành một khối `try-finally` tiêu chuẩn. Các lời gọi `close()` được tự động đặt bên trong khối `finally` theo thứ tự ngược lại của việc khai báo. Điều này đảm bảo rằng các tài nguyên được đóng ngay cả khi một exception xảy ra.

##### **Suppressed Exceptions (Exception bị chặn)**
`try-with-resources` cũng giải quyết vấn đề "exception bị nuốt". Nếu một exception được ném ra từ khối `try`, và *một exception khác* được ném ra từ lời gọi `close()` tự động, thì exception từ khối `try` là cái được lan truyền. Exception từ lời gọi `close()` bị "chặn" và được đính kèm vào exception chính.

Sau đó, bạn có thể truy xuất các exception bị chặn này bằng cách sử dụng method `getSuppressed()` trên exception bị bắt. Điều này đảm bảo rằng bạn không làm mất bất kỳ thông tin nào về những gì đã sai.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này tạo ra một tài nguyên `AutoCloseable` tùy chỉnh để minh họa cơ chế đóng tự động và exception bị chặn.

```java
// Một tài nguyên tùy chỉnh triển khai AutoCloseable
class MyResource implements AutoCloseable {
    private final String name;

    public MyResource(String name) {
        this.name = name;
        System.out.println("Resource '" + name + "' created.");
    }

    public void doWork() {
        System.out.println("Resource '" + name + "' is doing work.");
        // Mô phỏng một exception trong quá trình làm việc
        throw new RuntimeException("Error during work in " + name);
    }

    @Override
    public void close() throws Exception {
        // Đây là logic dọn dẹp
        System.out.println("Resource '" + name + "' is closing.");
        // Mô phỏng một exception trong quá trình đóng
        throw new Exception("Error while closing " + name);
    }
}

public class TryWithResourcesDemo {
    public static void main(String[] args) {
        try (MyResource res1 = new MyResource("Resource1");
             MyResource res2 = new MyResource("Resource2")) {
            res1.doWork();
        } catch (Exception e) {
            System.err.println("\n--- CAUGHT PRIMARY EXCEPTION ---");
            System.err.println("Primary Exception: " + e.getMessage());

            // Kiểm tra các exception bị chặn
            Throwable[] suppressed = e.getSuppressed();
            if (suppressed.length > 0) {
                System.err.println("\n--- SUPPRESSED EXCEPTIONS ---");
                for (Throwable t : suppressed) {
                    System.err.println("Suppressed: " + t.getMessage());
                }
            }
        }
    }
}
```
**Đầu ra của mã:**
```
Resource 'Resource1' created.
Resource 'Resource2' created.
Resource 'Resource1' is doing work.
Resource 'Resource2' is closing.
Resource 'Resource1' is closing.

--- CAUGHT PRIMARY EXCEPTION ---
Primary Exception: Error during work in Resource1

--- SUPPRESSED EXCEPTIONS ---
Suppressed: Error while closing Resource2
Suppressed: Error while closing Resource1
```
**Phân tích:**
1.  Cả hai tài nguyên đều được tạo.
2.  `res1.doWork()` ném ra exception chính.
3.  Khối `try` kết thúc.
4.  Cơ chế `try-with-resources` cố gắng đóng các tài nguyên. Nó gọi `res2.close()` trước (ném ra một exception) và sau đó `res1.close()` (cũng ném ra một exception).
5.  Exception chính từ `doWork()` là cái được bắt. Hai exception từ các lời gọi `close()` được đính kèm như các exception bị chặn. Không có thông tin nào bị mất.

---

#### **3. Bài tập nhỏ**

1.  Sử dụng các lớp `java.io.PrintWriter` và `java.io.FileWriter` của thư viện chuẩn Java.
2.  Viết một method `void writeToFile(String filename, String text)` ghi một văn bản đã cho vào một tệp.
3.  Triển khai method này bằng cách sử dụng một câu lệnh `try-with-resources` để đảm bảo rằng `PrintWriter` (và `FileWriter` bên dưới của nó) luôn được đóng.
4.  Bạn sẽ cần xử lý `IOException` mà constructor của `FileWriter` và các method của `PrintWriter` có thể ném ra.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một khối `try-with-resources`, các method `close()` của các tài nguyên được gọi theo thứ tự nào?

A) Theo cùng thứ tự chúng được khai báo trong câu lệnh `try()`.
B) Theo thứ tự ngược lại chúng được khai báo trong câu lệnh `try()`.
C. Thứ tự không được đảm bảo và phụ thuộc vào JVM.
D) Song song bởi nhiều luồng để đạt hiệu quả.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Theo thứ tự ngược lại chúng được khai báo trong câu lệnh `try()`. Đây là một lựa chọn thiết kế có chủ ý mô phỏng việc tháo dỡ một ngăn xếp. Nó đảm bảo rằng các tài nguyên có thể phụ thuộc vào các tài nguyên khác được đóng trước (ví dụ: một `BufferedInputStream` được đóng trước `FileInputStream` mà nó bao bọc).

### **Bài 6: Tóm tắt chủ đề, Câu hỏi phỏng vấn và Dự án cuối cùng**

Bài học cuối cùng này cung cấp một bản tóm tắt hợp nhất về các cơ chế xử lý exception và error của Java, làm nổi bật các câu hỏi phỏng vấn chính để kiểm tra sự thành thạo của bạn, và trình bày một dự án nhỏ để áp dụng các khái niệm này trong một ứng dụng đa tầng thực tế.

---

#### **1. Bảng tóm tắt các khái niệm chính**

| Khái niệm | Điểm chính & Thực hành tốt nhất |
| :--- | :--- |
| **Hệ thống phân cấp `Throwable`** | `Throwable` là gốc. `Error` dành cho các lỗi hệ thống không thể phục hồi (đừng bắt). `Exception` dành cho các điều kiện cấp ứng dụng. |
| **Checked Exceptions** | Các lớp con của `Exception` (nhưng không phải `RuntimeException`). Đại diện cho các điều kiện bên ngoài, có thể phục hồi. **Phải được bắt hoặc khai báo (`throws`).** Sử dụng cho các lỗi API có thể dự đoán (`IOException`, `SQLException`). |
| **Unchecked Exceptions** | Các lớp con của `RuntimeException`. Đại diện cho các lỗi/bug lập trình. **Trình biên dịch không thực thi việc xử lý.** Sử dụng cho các vi phạm điều kiện tiên quyết (`IllegalArgumentException`, `NullPointerException`). |
| **`try-catch-finally`** | `try` bảo vệ mã. `catch` xử lý exception. `finally` *luôn* chạy và được sử dụng để dọn dẹp tài nguyên. Tránh `return` trong một khối `finally`. |
| **`throw` vs. `throws`** | `throw` là một hành động ném một object exception. `throws` là một khai báo trong chữ ký của một method cho các checked exception. |
| **Sự lan truyền Exception** | Nếu một exception không được bắt trong một method, JVM sẽ tháo dỡ call stack, lan truyền exception đến method gọi cho đến khi tìm thấy một trình xử lý hoặc luồng kết thúc. |
| **Custom Exceptions** | Tạo của riêng bạn bằng cách kế thừa `Exception` (checked) hoặc `RuntimeException` (unchecked). Sử dụng chúng để cung cấp thông tin lỗi cụ thể, có ý nghĩa liên quan đến miền ứng dụng của bạn. |
| **Nối chuỗi Exception** | Bao bọc một exception cấp thấp bên trong một exception tùy chỉnh cấp cao hơn (`throw new DataAccessException(e)`). Bảo toàn nguyên nhân gốc rễ trong khi che giấu các chi tiết triển khai. |
| **`try-with-resources`** | Cách hiện đại, được ưu tiên để xử lý các tài nguyên triển khai `AutoCloseable`. Tự động gọi `close()` và xử lý các exception bị chặn một cách chính xác, ngăn chặn rò rỉ tài nguyên. |
| **Suppressed Exceptions** | Trong một khối `try-with-resources`, nếu cả khối `try` và lời gọi `close()` tự động đều ném ra exception, thì exception `close()` bị "chặn" và được đính kèm vào exception chính. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Sự khác biệt giữa một checked và một unchecked exception là gì? Cho một ví dụ về khi bạn sẽ sử dụng mỗi loại."**
    *   *Trả lời:* Một checked exception được trình biên dịch thực thi; bạn phải xử lý nó hoặc khai báo nó. Nó được sử dụng cho các lỗi có thể dự đoán, có thể phục hồi bên ngoài mã, như một `IOException` khi một tệp bị thiếu. Một unchecked exception (một `RuntimeException`) không được trình biên dịch thực thi và thường đại diện cho một bug lập trình. Bạn sẽ sử dụng nó cho các vi phạm điều kiện tiên quyết, như một `IllegalArgumentException` nếu một method nhận một số âm khi nó mong đợi một số dương.

2.  **"Mục đích của khối `finally` là gì? Điều gì xảy ra nếu một câu lệnh `return` có mặt trong cả hai khối `try` và `finally`?"**
    *   *Trả lời:* Mục đích của khối `finally` là để đảm bảo việc thực thi mã dọn dẹp, như đóng tài nguyên, bất kể một exception có được ném ra hay không. Nếu một câu lệnh `return` tồn tại trong cả hai khối `try` và `finally`, method sẽ thực thi khối `finally` và câu lệnh `return` của nó sẽ ghi đè lên cái từ khối `try`. Giá trị từ khối `try` sẽ bị loại bỏ. Điều này được coi là một thực hành tồi.

3.  **"Giải thích `try-with-resources` là gì và nó giải quyết vấn đề gì."**
    *   *Trả lời:* `try-with-resources` là một câu lệnh tự động quản lý vòng đời của các tài nguyên triển khai interface `AutoCloseable`. Nó giải quyết hai vấn đề chính với cách tiếp cận `try-finally` truyền thống để quản lý tài nguyên: nó giảm đáng kể mã soạn sẵn, và nó xử lý chính xác các exception bị chặn, ngăn chặn nguyên nhân gốc rễ của một lỗi bị mất nếu một exception khác xảy ra trong quá trình dọn dẹp tài nguyên.

4.  **"Khi nào bạn sẽ tạo một custom exception?"**
    *   *Trả lời:* Bạn tạo một custom exception để mô hình hóa một kịch bản lỗi cụ thể trong miền ứng dụng của bạn. Điều này làm cho mã dễ đọc hơn và cho phép xử lý lỗi cụ thể hơn. Ví dụ, một `UserNotFoundException` mô tả rõ ràng hơn một `Exception` chung chung. Các custom exception cũng có thể mang theo dữ liệu ngữ cảnh bổ sung (như một ID đơn hàng không hợp lệ) để giúp chẩn đoán vấn đề.

5.  **"Bạn có nên bắt `Throwable` không? Tại sao có hoặc tại sao không?"**
    *   *Trả lời:* Không, bạn gần như không bao giờ nên bắt `Throwable`. `Throwable` là lớp cha của cả `Exception` và `Error`. Việc bắt nó có nghĩa là bạn cũng đang cố gắng xử lý các `Error` như `OutOfMemoryError` hoặc `StackOverflowError`, là các lỗi cấp JVM không thể phục hồi mà ứng dụng của bạn không thể và không nên cố gắng xử lý. Việc bắt `Throwable` có thể che giấu các vấn đề nghiêm trọng và để lại ứng dụng trong một trạng thái không ổn định.

---

#### **3. Dự án nhỏ cuối cùng: Xử lý Exception theo tầng trong một trình phân tích cú pháp tệp**

Dự án này sẽ áp dụng xử lý exception theo tầng, custom exception, và `try-with-resources` để xây dựng một dịch vụ phân tích cú pháp tệp mạnh mẽ.

**🎯 Mục tiêu:** Tạo một dịch vụ đọc dữ liệu người dùng từ một tệp, phân tích cú pháp và xác thực nó. Việc xử lý exception nên được phân tầng, có nghĩa là mỗi thành phần xử lý các lỗi liên quan đến mức độ trừu tượng của nó.

**Các thành phần dự án:**

1.  **Custom Exceptions:**
    *   `DataAccessException` (checked): Cho các vấn đề cấp thấp khi đọc tệp (ví dụ: không tìm thấy tệp). Sẽ được sử dụng trong tầng repository.
    *   `DataParsingException` (checked): Cho các lỗi trong giai đoạn phân tích cú pháp (ví dụ: các dòng bị định dạng sai). Sẽ được sử dụng trong tầng parser.
    *   `ValidationException` (unchecked): Cho các vi phạm quy tắc nghiệp vụ (ví dụ: một định dạng email không hợp lệ). Điều này đại diện cho một bug về chất lượng dữ liệu, vì vậy nó là unchecked.

2.  **Tầng 1: `UserRepository` (Tầng truy cập dữ liệu)**
    *   Tạo một lớp `UserRepository` với một method: `List<String> readLines(String filePath) throws DataAccessException`.
    *   Method này nên sử dụng `try-with-resources` với `java.nio.file.Files.newBufferedReader()` để đọc tất cả các dòng từ một tệp.
    *   Nếu một `IOException` xảy ra, nó nên được **bắt** và **bao bọc** trong một `DataAccessException`.

3.  **Tầng 2: `UserParser` (Tầng phân tích cú pháp)**
    *   Tạo một lớp `UserParser` với một method: `User parseLine(String line) throws DataParsingException`.
    *   Giả sử một dòng người dùng là một chuỗi được phân tách bằng dấu phẩy như `"123,Alice,alice@example.com"`.
    *   Method này nên tách chuỗi. Nếu dòng không có chính xác 3 phần, nó nên ném ra một `DataParsingException`.
    *   Nó nên trả về một object `User` (một POJO đơn giản với id, name, email).

4.  **Tầng 3: `UserService` (Tầng logic nghiệp vụ)**
    *   Tạo một lớp `UserService` sử dụng hai thành phần kia.
    *   Nó sẽ có một method: `List<User> processUsers(String filePath)`.
    *   Method này sẽ là điểm vào cấp cao nhất. Nó nên điều phối quá trình:
        *   Gọi `UserRepository` để lấy các dòng. Nó phải xử lý `DataAccessException`. Nếu điều này xảy ra, nó nên ghi lại lỗi và trả về một danh sách rỗng.
        *   Lặp qua các dòng và gọi `UserParser` cho mỗi dòng. Nó phải xử lý `DataParsingException`. Nếu một dòng bị định dạng sai, nó nên ghi lại lỗi cho dòng đó và tiếp tục xử lý các dòng tiếp theo.
        *   Sau khi phân tích cú pháp, nó nên xác thực object `User` (ví dụ: kiểm tra xem email có chứa ký hiệu "@" hay không). Nếu xác thực thất bại, nó nên ném ra một `ValidationException` (vì đây là một vấn đề chất lượng dữ liệu không mong đợi).

5.  **Lớp `Main`:**
    *   Method `main` sẽ hoạt động như một client.
    *   Nó nên gọi `userService.processUsers()` bên trong một khối `try-catch` để xử lý `ValidationException` unchecked tiềm ẩn.
    *   Bạn sẽ cần tạo một tệp văn bản mẫu với một số dòng hợp lệ và một số dòng bị định dạng sai để kiểm tra tất cả các đường dẫn exception.

Cấu trúc dự án này buộc bạn phải suy nghĩ về tầng nào chịu trách nhiệm cho loại lỗi nào, cách dịch các exception cấp thấp thành các exception cấp ứng dụng có ý nghĩa, và khi nào nên phục hồi so với khi nào nên thất bại nhanh.

