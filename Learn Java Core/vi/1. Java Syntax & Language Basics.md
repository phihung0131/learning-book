### **Bài 1: Quy trình thực thi Java: Từ Source Code đến ứng dụng đang chạy**

Chào mừng đến với bài học đầu tiên của bạn! Trước khi chúng ta đi sâu vào cú pháp và các object, chúng ta phải hiểu "phép màu" xảy ra ở hậu trường. Trả lời các câu hỏi về JVM và quy trình thực thi là một cách phổ biến để người phỏng vấn đánh giá chiều sâu kiến thức của một ứng viên.

#### **1. Các thành phần cốt lõi: JDK vs. JRE vs. JVM**

Đầu tiên, hãy làm rõ các từ viết tắt mà bạn sẽ thấy ở khắp mọi nơi.

*   **JDK (Java Development Kit):** Đây là **bộ công cụ dành cho lập trình viên**. Nó chứa mọi thứ bạn cần để viết, biên dịch và debug các ứng dụng Java. Quan trọng nhất, JDK bao gồm cả JRE.
    *   **Nội dung chính:** Compiler (`javac`), debugger, archiver (`jar`), trình tạo tài liệu (`javadoc`), và JRE.

*   **JRE (Java Runtime Environment):** Đây là **môi trường dành cho người dùng**. Nó cung cấp các yêu cầu tối thiểu để *chạy* một ứng dụng Java đã được biên dịch. Bạn không cần JDK để chạy một chương trình Java, nhưng bạn cần JRE.
    *   **Nội dung chính:** JVM và các thư viện Java cốt lõi (như `java.lang`, `java.util`, v.v.).

*   **JVM (Java Virtual Machine):** Đây là trái tim của Java. JVM là một **máy tính trừu tượng** cho phép một máy tính chạy chương trình Java. Nó cung cấp một cách thực thi code độc lập với nền tảng. Khi bạn biên dịch code Java của mình, bạn tạo ra bytecode, là một tập hợp các chỉ thị cho JVM, chứ không phải cho CPU bên dưới. Đây là nền tảng của triết lý "Write Once, Run Anywhere" (Viết một lần, chạy mọi nơi) của Java.

**Ví dụ tương tự:** Hãy nghĩ về nó như việc xây dựng bằng LEGO.
*   **JDK:** Toàn bộ nhà máy LEGO, với các nhà thiết kế, máy làm gạch (compilers), và bản hướng dẫn.
*   **JRE:** Một hộp LEGO với tất cả các viên gạch cần thiết và một sách hướng dẫn (core libraries) để xây dựng một mô hình cụ thể.
*   **JVM:** Người (hoặc robot) đọc sách hướng dẫn và thực sự lắp ráp các viên gạch LEGO.

---

#### **2. Quy trình thực thi: Hành trình từng bước**

Làm thế nào tệp `.java` của bạn trở thành một ứng dụng đang chạy? Đó là một quy trình ba bước.

**Bước 1: Viết Code**
Bạn viết source code Java của mình trong một tệp `.java`. Đây là văn bản mà con người có thể đọc được.

```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

**Bước 2: Biên dịch (Source Code → Bytecode)**
Bạn sử dụng trình biên dịch Java (`javac`), là một phần của JDK, để biên dịch tệp `.java` của bạn.

```bash
javac HelloWorld.java
```

Trình biên dịch thực hiện hai việc chính:
1.  **Kiểm tra cú pháp (Syntax Checking):** Nó kiểm tra code của bạn để tìm bất kỳ lỗi cú pháp nào. Nếu tìm thấy lỗi, quá trình biên dịch sẽ thất bại.
2.  **Tạo Bytecode (Bytecode Generation):** Nếu cú pháp chính xác, trình biên dịch sẽ dịch source code của bạn thành một tập hợp các chỉ thị được tối ưu hóa cao gọi là **Java Bytecode**. Bytecode này được lưu trong một tệp `.class` (`HelloWorld.class`).

Bytecode độc lập với nền tảng. Cùng một tệp `.class` có thể chạy trên Windows, macOS, hoặc Linux, miễn là máy đó có JRE tương thích.

**Bước 3: Thực thi (Chạy Bytecode)**
Đây là lúc JVM tiếp quản. Bạn sử dụng lệnh `java` để thực thi bytecode đã được biên dịch.

```bash
java HelloWorld
```

Đây là những gì xảy ra bên trong JVM ở giai đoạn này:

*   **Class Loading:** **Class Loader** của JVM tìm và tải các tệp `.class` vào bộ nhớ của JVM. Nó tải `HelloWorld.class` của bạn và bất kỳ lớp nào khác từ Java API cần thiết (như `String` và `System`).
*   **Bytecode Verification:** **Bytecode Verifier** kiểm tra bytecode để đảm bảo nó hợp lệ và không vi phạm các quy tắc bảo mật của Java (ví dụ: nó sẽ không làm hỏng bộ nhớ). Đây là một bước bảo mật quan trọng.
*   **Interpretation / JIT Compilation:** **Execution Engine** đọc bytecode và dịch nó thành mã máy gốc (native machine code - các chỉ thị mà CPU bên dưới có thể hiểu được). Điều này có thể xảy ra theo hai cách:
    *   **Interpreter:** Đọc và thực thi bytecode từng chỉ thị một. Cách này chậm hơn nhưng khởi động nhanh hơn.
    *   **JIT (Just-In-Time) Compiler:** Nếu một đoạn code được thực thi thường xuyên (một "hotspot"), JIT compiler sẽ biên dịch toàn bộ khối bytecode đó thành mã máy gốc cùng một lúc. Mã máy gốc đã biên dịch này sau đó được lưu vào cache và tái sử dụng, làm cho các lần gọi tiếp theo nhanh hơn nhiều. Các JVM hiện đại sử dụng kết hợp cả hai.

Đây là một biểu diễn trực quan của quá trình:

```
+----------------+      +------------------+      +----------------------+
|  Your Code     |      |  Java Compiler   |      |  Bytecode            |
| (HelloWorld.java)|----->|     (javac)      |----->| (HelloWorld.class)   |
+----------------+      +------------------+      +----------------------+
      |                                                     |
      | (Human-Readable)                                    | (Platform-Independent)
      v                                                     v
+--------------------------------------------------------------------------+
| Java Virtual Machine (JVM)                                               |
|                                                                          |
|  +-----------------+   +--------------------+   +---------------------+  |
|  | Class Loader    |-->| Bytecode Verifier  |-->|   Execution Engine  |  |
|  +-----------------+   +--------------------+   | (Interpreter & JIT) |  |
|                                                 +---------------------+  |
|                                                          |               |
|                                                          v               |
|                                                 +---------------------+  |
|                                                 | Operating System & CPU|  |
|                                                 +---------------------+  |
+--------------------------------------------------------------------------+
```

---

#### **Bài tập nhỏ**

1.  Tạo một tệp có tên `SimpleMath.java`.
2.  Viết một chương trình đơn giản trong đó khai báo hai biến integer, `a` và `b`, khởi tạo chúng với hai số bất kỳ, và sau đó in ra tổng của chúng.
3.  Mở một terminal hoặc command prompt, điều hướng đến thư mục của tệp, và biên dịch tệp bằng lệnh `javac`. Quan sát tệp `.class` được tạo ra.
4.  Chạy code đã biên dịch bằng lệnh `java` và xác minh rằng tổng chính xác được in ra.

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Đầu ra chính của lệnh `javac` là gì, và đặc điểm chính của nó là gì?

A) Native machine code; nó phụ thuộc vào nền tảng.
B) Một tệp `.jar`; nó là một kho lưu trữ có thể thực thi.
C) Java Bytecode (một tệp `.class`); nó độc lập với nền tảng.
D) Một phiên bản tối ưu hóa của tệp nguồn `.java`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Java Bytecode (một tệp `.class`); nó độc lập với nền tảng.

### **Bài 2: Mô hình bộ nhớ JVM: Nơi dữ liệu của bạn tồn tại**

Hiểu cách JVM tổ chức bộ nhớ là nền tảng để viết code Java hiệu quả, không có lỗi. Nó giải thích tại sao một số biến hoạt động khác với những biến khác và là chìa khóa để debug các vấn đề như `StackOverflowError` và `OutOfMemoryError`.

Khi một chương trình Java chạy, JVM tạo ra một số vùng bộ nhớ riêng biệt, được gọi là Runtime Data Areas. Mỗi vùng có một mục đích cụ thể. Những vùng quan trọng nhất mà một lập trình viên cần hiểu là **Stack** và **Heap**.

---

#### **1. Các vùng bộ nhớ cốt lõi**

JVM định nghĩa năm vùng dữ liệu runtime chính. Một số được tạo cho mỗi thread (nghĩa là mỗi thread có vùng riêng), trong khi những vùng khác được chia sẻ giữa tất cả các thread.

**Chia sẻ giữa tất cả các Thread:**
1.  **Heap Space:** Đây là nơi tất cả các object và các biến instance của chúng được lưu trữ. Khi bạn sử dụng từ khóa `new` (ví dụ: `new MyObject()`), bộ nhớ cho object đó được cấp phát trên Heap. Heap là vùng bộ nhớ lớn nhất và được quản lý bởi Garbage Collector (GC).
2.  **Method Area (hoặc Metaspace từ Java 8):** Vùng này lưu trữ dữ liệu cấp độ class, chẳng hạn như runtime constant pool, dữ liệu về field và method, và code cho các method và constructor. Nói một cách đơn giản, nó giữ "bản thiết kế" cho các class của bạn. Các biến static cũng được lưu trữ ở đây.

**Tạo ra cho mỗi Thread:**
3.  **Stack:** Mỗi thread có JVM Stack riêng, được tạo cùng lúc với thread. Stack lưu trữ các **frame**. Một frame mới được tạo cho mỗi method được gọi. Khi method hoàn thành, frame của nó bị hủy. Frame lưu trữ các biến cục bộ (local variables), tham số (parameters), và giá trị trả về (return values).
4.  **PC (Program Counter) Register:** Mỗi thread có PC Register riêng. Nó chứa địa chỉ của chỉ thị JVM đang được thực thi.
5.  **Native Method Stack:** Đây là một stack đặc biệt cho native code (ví dụ: C/C++), được sử dụng khi code Java của bạn gọi một method được triển khai bằng ngôn ngữ khác.

**Hình dung các vùng:**
```
+---------------------------------------------------+
|               JVM Memory                          |
|                                                   |
| +-----------------------------------------------+ |
| |        Heap (Shared by all threads)           | |
| |  [Object 1] [Object 2] [Array 1] ...          | |
| +-----------------------------------------------+ |
| +-----------------------------------------------+ |
| |    Method Area / Metaspace (Shared)           | |
| |  [Class A data] [Static vars] [Class B data]  | |
| +-----------------------------------------------+ |
|                                                   |
| +-----------+  +-----------+  +-----------+       |
| | Thread 1  |  | Thread 2  |  | Thread 3  |       |
| | +-------+ |  | +-------+ |  | +-------+ |       |
| | | Stack | |  | | Stack | |  | | Stack | |       |
| | +-------+ |  | +-------+ |  | +-------+ |       |
| | | PC    | |  | | PC    | |  | | PC    | |       |
| | +-------+ |  | +-------+ |  | +-------+ |       |
| +-----------+  +-----------+  +-----------+       |
+---------------------------------------------------+```

```

#### **2. Sự khác biệt quan trọng: Stack vs. Heap**

Đây là một trong những khái niệm quan trọng nhất trong các cuộc phỏng vấn Java. Hiểu rõ nó sẽ làm sáng tỏ cách các biến hoạt động.

*   **Stack Memory:**
    *   **Nó lưu trữ gì:** Các kiểu nguyên thủy (primitive types - `int`, `double`, `boolean`, v.v.) và **tham chiếu** (references - địa chỉ bộ nhớ) đến các object.
    *   **Vòng đời:** Dữ liệu trên stack chỉ tồn tại trong suốt thời gian của lời gọi method. Khi một method được gọi, một "stack frame" mới được đẩy vào stack của thread. Khi method trả về, frame đó được bật ra, và nội dung của nó bị hủy.
    *   **Tốc độ:** Truy cập rất nhanh (LIFO - Last-In, First-Out).
    *   **Kích thước:** Tương đối nhỏ và có kích thước cố định.

*   **Heap Memory:**
    *   **Nó lưu trữ gì:** Chính các **object**.
    *   **Vòng đời:** Các object trên heap tồn tại miễn là chúng còn được tham chiếu từ đâu đó (ví dụ: từ một tham chiếu trên stack hoặc một object khác). Chúng được dọn dẹp bởi Garbage Collector khi không còn có thể truy cập được.
    *   **Tốc độ:** Chậm hơn để cấp phát và truy cập so với stack memory.
    *   **Kích thước:** Lớn hơn nhiều so với stack, và kích thước của nó có thể tăng hoặc giảm.

##### **Ví dụ: Kiểu nguyên thủy vs. Object trong bộ nhớ**

Hãy phân tích một đoạn code đơn giản.

```java
public class MemoryExample {

    public static void main(String[] args) {
        int age = 30; // Một kiểu primitive
        Person person = new Person("Alice"); // Một object
        person.setAge(age);
    }
}

class Person {
    private String name; // Đây sẽ là một tham chiếu đến một object String
    private int personAge; // Đây là một biến instance kiểu primitive

    public Person(String name) {
        this.name = name;
    }
    public void setAge(int age) {
        this.personAge = age;
    }
}
```

**Giải thích mô hình bộ nhớ:**

Khi `main` được gọi, một frame mới được đẩy vào stack của main thread.

1.  `int age = 30;`
    *   Một biến `age` được tạo trực tiếp bên trong stack frame của method `main`.
    *   Giá trị `30` được lưu trữ trực tiếp tại vị trí đó trên stack.

2.  `Person person = new Person("Alice");`
    *   **`new Person("Alice")`**: Đây là phần quan trọng. JVM cấp phát bộ nhớ trên **Heap** cho một object `Person` mới. Khối được cấp phát này chứa không gian cho các biến instance của nó (`name` và `personAge`). Constructor của `Person` được gọi. Bên trong object này, trường `name` sẽ giữ một tham chiếu đến object `String` "Alice" (cũng tồn tại trên heap, có thể trong String Pool).
    *   **`Person person = ...`**: Một biến `person` được tạo trên **Stack** bên trong frame của method `main`. Biến này *không* giữ chính object đó. Nó giữ **địa chỉ bộ nhớ** (một tham chiếu) trỏ đến object `Person` trên Heap.

**Sơ đồ đơn giản hóa:**

```
          STACK                                       HEAP
+---------------------------+             +-------------------------------+
| main() Frame              |             |                               |
|   +-------------------+   |             |  +--------------------------+ |
|   | int age = 30      |   |             |  | Person Object             | |
|   +-------------------+   |             |  |  (tại địa chỉ 0x500)       | |
|   | Person person     | --|----------- > |  +--------------------------+ |
|   | (ref đến 0x500)    |   |             |  |  - name (ref đến 0x999)  | |
|   +-------------------+   |             |  |  - personAge = 0        | |
+---------------------------+             |  +--------------------------+ |
                                          |                               |
                                          |  +--------------------------+ |
                                          |  | String Object "Alice"    | |
                                          |  | (tại địa chỉ 0x999)      | |
                                          |  +--------------------------+ |
                                          |                               |
                                          +-------------------------------+
```

---

#### **3. Các cạm bẫy phổ biến liên quan đến bộ nhớ**

*   **`StackOverflowError`:** Điều này xảy ra khi stack hết dung lượng. Vì mỗi lời gọi method tạo ra một frame mới, nguyên nhân phổ biến nhất là đệ quy vô hạn hoặc rất sâu. Stack của thread phát triển cho đến khi đạt đến giới hạn và lỗi được ném ra.

*   **`OutOfMemoryError: Java heap space`:** Điều này xảy ra khi heap hết dung lượng. Nó thường được gây ra bởi việc tạo quá nhiều object mà không để chúng được garbage collect. Ví dụ, tạo hàng triệu object lớn trong một vòng lặp và giữ tham chiếu đến tất cả chúng.

---

#### **Bài tập nhỏ**

Phân tích đoạn code sau. Sau khi method `change` được gọi, giá trị của `x` và `myCar.name` trong method `main` sẽ là gì? Giải thích tại sao, tham chiếu đến Stack và Heap.

```java
public class MemoryExercise {

    public static void main(String[] args) {
        int x = 10;
        Car myCar = new Car("BMW");

        change(x, myCar);

        System.out.println("x = " + x);
        System.out.println("myCar.name = " + myCar.name);
    }

    public static void change(int number, Car car) {
        number = 20;
        car.name = "Audi";
    }
}

class Car {
    public String name;
    public Car(String name) { this.name = name; }
}
```

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Một biến cục bộ kiểu `long` được khai báo bên trong một method được lưu trữ ở đâu?

A) Trong Method Area
B) Trên Heap
C) Trên Stack
D) Trong một PC Register

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Trên Stack. `long` là một kiểu primitive, và các biến cục bộ (primitives hoặc references) luôn được lưu trữ trên stack của thread.

### **Bài 3: Kiểu Primitive vs. Kiểu Tham chiếu (Reference)**

Bài học này đi sâu hơn vào sự khác biệt cơ bản giữa hai loại kiểu dữ liệu chính của Java. Hiểu rõ sự khác biệt này là rất quan trọng để dự đoán chương trình của bạn sẽ hoạt động như thế nào, đặc biệt là khi truyền dữ liệu vào các method.

---

#### **1. Hai thế giới: Primitives và References**

Java phân tách rõ ràng các kiểu dữ liệu của nó thành hai nhóm.

**Kiểu Primitive (Nguyên thủy):**
Đây là những kiểu dữ liệu cơ bản nhất có sẵn trong Java. Chúng không phải là object. Chúng giữ một giá trị đơn, giản đơn trực tiếp tại vị trí bộ nhớ được cấp phát cho chúng (trên stack đối với các biến cục bộ).

Có chính xác **tám** kiểu primitive:
*   **Kiểu số nguyên:** `byte` (8-bit), `short` (16-bit), `int` (32-bit), `long` (64-bit)
*   **Kiểu dấu phẩy động:** `float` (32-bit), `double` (64-bit)
*   **Kiểu ký tự:** `char` (16-bit, đại diện cho một ký tự Unicode)
*   **Kiểu Boolean:** `boolean` (đại diện cho `true` hoặc `false`; kích thước của nó không được định nghĩa chính xác bởi đặc tả JVM nhưng thường được coi là 1 byte hoặc 1 bit trong nội bộ)

**Đặc điểm chính của Primitives:**
*   Chúng lưu trữ giá trị trực tiếp.
*   Chúng là immutable (bạn không thể thay đổi chính giá trị `5`, bạn chỉ có thể gán một giá trị mới cho biến đang giữ nó).
*   Chúng có giá trị mặc định nếu là biến instance (ví dụ: `0` cho các kiểu số, `false` cho `boolean`). Các biến cục bộ không có giá trị mặc định và phải được khởi tạo.
*   Chúng không có method.

**Kiểu Tham chiếu (Reference Types):**
Một kiểu tham chiếu là bất kỳ kiểu nào không phải là primitive. Điều này bao gồm tất cả các class (như `String`, `Object`, hoặc bất kỳ class nào bạn tạo ra), interface, array, và enum.

**Đặc điểm chính của Kiểu Tham chiếu:**
*   Một biến của kiểu tham chiếu **không** giữ chính object đó. Nó giữ một **tham chiếu** (một địa chỉ bộ nhớ hoặc con trỏ) đến vị trí của object trên Heap.
*   Chúng có giá trị mặc định là `null` nếu là biến instance.
*   Chúng có thể có method và field.
*   Khi bạn sử dụng toán tử `==` trên các biến tham chiếu, bạn đang so sánh địa chỉ bộ nhớ của chúng, không phải nội dung của các object mà chúng trỏ đến.

---

#### **2. Java luôn là Pass-by-Value (Truyền bằng giá trị)**

Đây là một chủ đề phỏng vấn thường xuyên và quan trọng. Nhiều người hiểu sai khi cho rằng Java là "pass-by-reference" (truyền bằng tham chiếu) đối với các object. **Điều đó không đúng.** Java hoàn toàn là **pass-by-value**.

Hãy xem điều này có ý nghĩa gì đối với cả primitives và references.

**Truyền Primitives:**
Khi bạn truyền một biến primitive vào một method, một **bản sao của giá trị của nó** được tạo ra và đưa cho tham số của method. Bất kỳ thay đổi nào được thực hiện đối với tham số bên trong method đều **không** ảnh hưởng đến biến gốc.

**Ví dụ:**
```java
public class PassByValuePrimitives {
    public static void main(String[] args) {
        int originalValue = 10;
        System.out.println("Trước khi gọi method: " + originalValue); // In ra 10
        modify(originalValue);
        System.out.println("Sau khi gọi method: " + originalValue);  // Vẫn in ra 10
    }

    public static void modify(int valueCopy) {
        valueCopy = 20; // Điều này chỉ thay đổi bản sao bên trong stack frame của method này
    }
}
```

**Giải thích mô hình bộ nhớ:**
1.  Trong `main()`, `originalValue` (giá trị `10`) được tạo trên stack.
2.  Khi `modify()` được gọi, một biến *mới* `valueCopy` được tạo trên stack cho frame của method `modify()`.
3.  Giá trị của `originalValue` (`10`) được **sao chép** vào `valueCopy`.
4.  Bên trong `modify()`, `valueCopy` được thay đổi thành `20`. Điều này không ảnh hưởng đến `originalValue` trong frame của `main()`.
5.  Khi `modify()` trả về, stack frame của nó bị hủy, và `valueCopy` biến mất.

**Truyền Tham chiếu (References):**
Khi bạn truyền một biến tham chiếu vào một method, một **bản sao của tham chiếu (địa chỉ bộ nhớ)** được tạo ra. Cả tham chiếu gốc và bản sao của method bây giờ đều trỏ đến **cùng một object** trên Heap.

*   Điều này có nghĩa là bạn **không thể** thay đổi nơi mà tham chiếu *gốc* trỏ tới.
*   Nhưng bạn **có thể** thay đổi *trạng thái bên trong* của object duy nhất trên heap mà cả hai tham chiếu đang trỏ tới.

**Ví dụ:**
```java
public class PassByValueReferences {
    public static void main(String[] args) {
        StringBuilder originalRef = new StringBuilder("Hello");
        System.out.println("Trước khi gọi method: " + originalRef); // In ra "Hello"
        modify(originalRef);
        System.out.println("Sau khi gọi method: " + originalRef);  // In ra "Hello World"
    }

    public static void modify(StringBuilder refCopy) {
        // refCopy trỏ đến CÙNG MỘT object như originalRef
        refCopy.append(" World"); // Sửa đổi object trên heap

        // Điều gì sẽ xảy ra nếu chúng ta làm điều này?
        refCopy = new StringBuilder("Goodbye"); // Điều này tạo ra một object MỚI trên heap
                                                // và làm cho refCopy trỏ đến nó.
                                                // Nó KHÔNG ảnh hưởng đến originalRef.
    }
}
```

**Giải thích mô hình bộ nhớ:**
1.  Trong `main()`, một object `StringBuilder` ("Hello") được tạo trên **Heap**. Biến `originalRef` trên **Stack** giữ địa chỉ bộ nhớ của nó (ví dụ: `0x123`).
2.  Khi `modify()` được gọi, một biến *mới* `refCopy` được tạo trên stack cho `modify()`.
3.  Giá trị của `originalRef` (địa chỉ `0x123`) được **sao chép** vào `refCopy`. Bây giờ cả hai biến đều trỏ đến cùng một object `StringBuilder` trên heap.
4.  `refCopy.append(" World")` đi theo tham chiếu `0x123` và sửa đổi object thực tế trên heap.
5.  Vì `originalRef` cũng trỏ đến cùng một object đó, sự thay đổi có thể được nhìn thấy bên ngoài method.
6.  Dòng `refCopy = new StringBuilder("Goodbye")` tạo ra một object *mới* và làm cho `refCopy` trỏ đến nó. Biến `originalRef` không bị ảnh hưởng và vẫn trỏ đến object đầu tiên.

---

#### **3. Giá trị mặc định**

Sự khác biệt giữa primitives và references cũng quan trọng đối với việc khởi tạo mặc định.

| Phạm vi             | Primitives (`int`, `double`, v.v.) | Kiểu Tham chiếu (`String`, `Object`, v.v.) |
| ----------------- | ---------------------------------- | ------------------------------------------ |
| **Biến Instance** (field trong một class) | `0`, `0.0`, `\u0000`, `false`     | `null`                                     |
| **Biến Cục bộ** (bên trong một method)  | **Không có giá trị mặc định**. Phải được khởi tạo trước khi sử dụng. Gây ra lỗi biên dịch. | **Không có giá trị mặc định**. Phải được khởi tạo trước khi sử dụng. Gây ra lỗi biên dịch. |


---

#### **Bài tập nhỏ**

Xem xét đoạn code dưới đây. Dự đoán đầu ra cuối cùng và vẽ một sơ đồ stack/heap đơn giản để chứng minh câu trả lời của bạn.

```java
public class SwapExercise {

    public static void main(String[] args) {
        Dog dog1 = new Dog("Charlie");
        Dog dog2 = new Dog("Buddy");

        swap(dog1, dog2);

        System.out.println("dog1 name: " + dog1.name);
        System.out.println("dog2 name: " + dog2.name);
    }

    public static void swap(Dog a, Dog b) {
        Dog temp = a;
        a = b;
        b = temp;
    }
}

class Dog {
    public String name;
    public Dog(String name) { this.name = name; }
}
```

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Đầu ra của đoạn code sau là gì?
```java
public class Quiz {
    public static void main(String[] args) {
        String str = "Initial";
        changeString(str);
        System.out.println(str);
    }
    public static void changeString(String s) {
        s = "Changed";
    }
}
```

A) Changed
B) Initial
C) Nó sẽ ném ra một `NullPointerException`.
D) Nó sẽ gây ra lỗi biên dịch.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Initial. Đây là một câu hỏi mẹo kinh điển. `String` là immutable. Dòng `s = "Changed"` không sửa đổi object string ban đầu. Thay vào đó, nó tạo ra một string mới "Changed" trên heap và làm cho tham chiếu cục bộ `s` trỏ đến nó. Tham chiếu gốc `str` trong `main` không bị ảnh hưởng và vẫn trỏ đến "Initial".

### **Bài 4: Lớp `String`, Tính bất biến (Immutability), và String Pool**

Lớp `String` là một trong những lớp được sử dụng thường xuyên nhất trong Java. Mặc dù nó là một kiểu tham chiếu (một object), JVM đối xử đặc biệt với nó, điều này có thể là nguồn gây nhầm lẫn và là một chủ đề nóng trong các cuộc phỏng vấn. Bài học này bao gồm hai đặc điểm quan trọng nhất của nó: tính bất biến (immutability) và String Pool.

---

#### **1. `String` là một Object hạng nhất**

Đầu tiên, hãy luôn nhớ rằng `String` là một class, `java.lang.String`, không phải là một primitive. Một biến `String` giữ một tham chiếu đến một object trên heap, giống như bất kỳ object nào khác.

Tuy nhiên, Java cung cấp "cú pháp tiện lợi" (syntactic sugar) để tạo chuỗi, làm cho chúng có cảm giác giống như primitive:

```java
// Cách "literal" thông thường
String literal = "Hello Java";

// Cách tạo object tiêu chuẩn
String obj = new String("Hello Java");
```

Mặc dù hai dòng này có vẻ làm điều tương tự, chúng có một sự khác biệt sâu sắc trong cách chúng được xử lý trong bộ nhớ, mà chúng ta sẽ khám phá tiếp theo.

---

#### **2. Sức mạnh của tính bất biến (Immutability)**

Một tính năng chính của các object `String` là chúng **bất biến (immutable)**. Điều này có nghĩa là một khi một object `String` được tạo ra, trạng thái của nó (chuỗi ký tự mà nó giữ) không bao giờ có thể thay đổi.

Nếu bạn thực hiện một thao tác có vẻ như sửa đổi một chuỗi, thực chất bạn đang tạo ra một object `String` **mới** với nội dung đã được sửa đổi, trong khi chuỗi ban đầu vẫn không bị ảnh hưởng.

**Ví dụ:**
```java
String s1 = "Welcome";
s1.toUpperCase(); // Method này trả về một chuỗi MỚI "WELCOME" nhưng không thay đổi s1

System.out.println(s1); // Output: Welcome

// Để nắm bắt sự thay đổi, bạn phải gán chuỗi mới cho một tham chiếu
String s2 = s1.toUpperCase();
System.out.println(s1); // Output: Welcome
System.out.println(s2); // Output: WELCOME
```

**Tại sao tính bất biến lại quan trọng đến vậy?**
*   **An toàn cho Thread (Thread Safety):** Vì các chuỗi không bao giờ thay đổi, chúng có thể được chia sẻ tự do giữa nhiều thread mà không có nguy cơ xung đột dữ liệu. Không cần đồng bộ hóa (synchronization).
*   **Bảo mật (Security):** Nhiều phần của Java API dựa vào chuỗi cho các thông tin quan trọng như đường dẫn tệp, tên máy chủ và thông tin đăng nhập cơ sở dữ liệu. Nếu chuỗi có thể thay đổi, một method độc hại có thể thay đổi nội dung của chuỗi sau khi kiểm tra bảo mật, có khả năng cấp quyền truy cập trái phép.
*   **Hiệu suất và Caching:** Việc đảm bảo giá trị của một chuỗi sẽ không bao giờ thay đổi cho phép Java thực hiện một tối ưu hóa lớn: **String Pool**. Nó cũng cho phép mã hash của chuỗi được tính một lần và được lưu vào cache, làm cho nó rất nhanh khi sử dụng trong các collection dựa trên hash như `HashMap`.

---

#### **3. String Pool (String Constant Pool)**

Để tiết kiệm bộ nhớ và tăng hiệu suất, JVM duy trì một vùng bộ nhớ đặc biệt trong Heap được gọi là **String Pool**.

**Cách hoạt động:**
1.  Khi bạn tạo một chuỗi bằng cách sử dụng một **literal** (ví dụ: `String s = "Hello";`), JVM sẽ tìm kiếm trong String Pool một chuỗi có giá trị chính xác đó.
2.  **Nếu tìm thấy một chuỗi trùng khớp**, JVM sẽ trả về một tham chiếu đến chuỗi *đã tồn tại* đó từ pool.
3.  **Nếu không tìm thấy chuỗi trùng khớp**, JVM sẽ tạo một object `String` *mới* trong pool với giá trị đó và trả về một tham chiếu đến nó.

Điều này có nghĩa là tất cả các string literal có cùng nội dung sẽ trỏ đến **cùng một object** trong bộ nhớ.

Bây giờ, hãy xem xét việc tạo một chuỗi bằng từ khóa `new`:
*   `String s = new String("Hello");` **luôn luôn** tạo ra một object `String` mới trên heap, **bên ngoài** String Pool.

**Giải thích mô hình bộ nhớ:**
Hãy phân tích đoạn code này:
```java
String s1 = "Java"; // Đi vào pool
String s2 = "Java"; // Trỏ đến CÙNG MỘT object trong pool như s1
String s3 = new String("Java"); // Tạo một object MỚI trên heap
```

**Sơ đồ:**
```
            STACK                                   HEAP
+---------------------------+        +-----------------------------------+
| main() Frame              |        |   +---------------------------+   |
|   +-------------------+   |        |   | String Pool               |   |
|   | String s1 (ref)   | --|------> |   |  +--------------------+   |   |
|   +-------------------+   |  |     |   |  | String "Java"      |   |   |
|   | String s2 (ref)   | --|--|     |   |  | (tại địa chỉ 0x555) |   |   |
|   +-------------------+   |        |   |  +--------------------+   |   |
|   | String s3 (ref)   | --|--+     |   +---------------------------+   |
|   +-------------------+   |  |     |                                   |
+---------------------------+  |     |   +--------------------+          |
                             |     |   | String "Java"      |          |
                             +-----> |   | (tại địa chỉ 0x888) |          |
                                   |   +--------------------+          |
                                   +-----------------------------------+
```

---

#### **4. Câu hỏi phỏng vấn kinh điển: `==` vs. `.equals()`**

Khái niệm này trực tiếp kiểm tra sự hiểu biết của bạn về String Pool và bộ nhớ.

*   `==` **(So sánh tham chiếu - Reference Equality):** Toán tử này kiểm tra xem hai biến tham chiếu có trỏ đến **cùng một object** trong bộ nhớ hay không (tức là nó so sánh địa chỉ bộ nhớ của chúng).

*   `.equals()` **(So sánh giá trị - Value Equality):** Đây là một method trên lớp `String` kiểm tra xem hai object chuỗi có **cùng một chuỗi ký tự** hay không.

**Ví dụ:**
```java
String s1 = "Test"; // Từ pool
String s2 = "Test"; // Từ pool, cùng object với s1
String s3 = new String("Test"); // Object mới trên heap
String s4 = "Different"; // Từ pool

// So sánh s1 và s2
System.out.println(s1 == s2);       // true (cả hai đều trỏ đến cùng một object trong pool)
System.out.println(s1.equals(s2));  // true (giá trị giống nhau)

// So sánh s1 và s3
System.out.println(s1 == s3);       // false (các object khác nhau trong bộ nhớ)
System.out.println(s1.equals(s3));  // true (giá trị giống nhau)

// So sánh s1 và s4
System.out.println(s1 == s4);       // false (các object khác nhau trong bộ nhớ)
System.out.println(s1.equals(s4));  // false (giá trị khác nhau)
```

**Nguyên tắc tốt nhất:** **Luôn luôn** sử dụng method `.equals()` để so sánh nội dung của các chuỗi. Chỉ sử dụng `==` nếu bạn thực sự cần kiểm tra xem hai biến có tham chiếu đến cùng một instance object hay không.

---

#### **Bài tập nhỏ**

Dự đoán đầu ra của đoạn code sau *trước khi* chạy nó. Giải thích lý do của bạn cho mỗi trong ba câu lệnh `println`.

```java
public class StringExercise {
    public static void main(String[] args) {
        String a = "hello";
        String b = new String("hello");
        String c = b.intern(); // Method intern() trả về chuỗi từ pool.

        System.out.println("a == b: " + (a == b));
        System.out.println("b == c: " + (b == c));
        System.out.println("a == c: " + (a == c));
    }
}
```

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Sau khi thực thi đoạn code sau, có bao nhiêu object `String` được tạo ra trên heap tổng cộng (bao gồm cả String Pool)?

```java
String x = "abc";
String y = new String("abc");
String z = "abc";
```

A) 1
B) 2
C) 3
D) 4

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) 2.
1.  `String x = "abc";` tạo một object cho "abc" trong String Pool.
2.  `String y = new String("abc");` tạo một object thứ hai, riêng biệt trên heap (bên ngoài pool).
3.  `String z = "abc";` tìm thấy "abc" đã tồn tại trong String Pool và tái sử dụng nó. Không có object mới nào được tạo ở đây.

### **Bài 5: Ép kiểu (Type Casting), Thăng hạng (Promotion), và Tràn số (Overflow)**

Bây giờ chúng ta đã đề cập đến các loại dữ liệu khác nhau trong Java, điều quan trọng là phải hiểu cách Java xử lý các phép toán liên quan đến các kiểu *hỗn hợp*. Bài học này bao gồm các quy tắc mà Java tuân theo để làm cho chúng tương thích, những nguy hiểm của việc ép buộc chuyển đổi, và cạm bẫy phổ biến của việc tràn dữ liệu.

---

#### **1. Chuyển đổi ngầm định (Widening hoặc Promotion)**

Chuyển đổi ngầm định, còn được gọi là widening (mở rộng), xảy ra tự động khi bạn gán một giá trị từ một kiểu dữ liệu "nhỏ hơn" cho một biến của kiểu dữ liệu "lớn hơn". Nó được coi là an toàn vì không có nguy cơ mất thông tin.

Trình biên dịch Java thực hiện chuyển đổi này cho bạn mà không cần bạn phải viết bất kỳ mã đặc biệt nào.

**Thứ bậc Widening:**
Java tuân theo một con đường rõ ràng cho việc thăng hạng. Một kiểu có thể được mở rộng an toàn sang bất kỳ kiểu nào ở bên phải nó.

`byte` → `short` → `int` → `long` → `float` → `double`

Lưu ý rằng `char` cũng có thể được thăng hạng lên `int`.

**Ví dụ:**
```java
int myInt = 100;
long myLong = myInt;  // Chuyển đổi ngầm định từ int sang long
float myFloat = myLong; // Chuyển đổi ngầm định từ long sang float

System.out.println("myInt: " + myInt);     // Output: 100
System.out.println("myLong: " + myLong);   // Output: 100
System.out.println("myFloat: " + myFloat); // Output: 100.0
```

**Thăng hạng trong phép toán (Arithmetic Promotion):**
Đây là một kịch bản rất phổ biến. Khi bạn thực hiện một phép toán số học trên hai kiểu primitive khác nhau, Java sẽ thăng hạng kiểu nhỏ hơn lên kiểu lớn hơn *trước khi* thực hiện phép toán, và kết quả sẽ là của kiểu lớn hơn.

**Quy tắc chung:**
*   Nếu một toán hạng là `double`, toán hạng kia được chuyển đổi thành `double`.
*   Nếu không, nếu một toán hạng là `float`, toán hạng kia được chuyển đổi thành `float`.
*   Nếu không, nếu một toán hạng là `long`, toán hạng kia được chuyển đổi thành `long`.
*   Nếu không, **cả hai toán hạng đều được chuyển đổi thành `int`**. Điểm cuối cùng này là một cái bẫy phổ biến! Các phép toán trên `byte`, `short`, hoặc `char` trước tiên được thăng hạng lên `int`.

**Ví dụ:**
```java
int i = 5;
double d = 2.5;
double result = i + d; // i được thăng hạng lên double (5.0) trước khi cộng. Kết quả là một double.
System.out.println(result); // Output: 7.5

byte b1 = 10;
byte b2 = 20;
// byte b3 = b1 + b2; // LỖI BIÊN DỊCH!
// Tại sao? b1 và b2 được thăng hạng lên 'int' trước khi cộng. Kết quả là một 'int'.
// Bạn không thể gán một 'int' cho một 'byte' mà không có ép kiểu tường minh.
int i_result = b1 + b2;
System.out.println(i_result); // Output: 30```
```

#### **2. Chuyển đổi tường minh (Narrowing hoặc Casting)**

Narrowing (thu hẹp) là quá trình chuyển đổi một kiểu dữ liệu "lớn hơn" sang một kiểu "nhỏ hơn". Điều này có khả năng không an toàn vì bạn có thể mất dữ liệu hoặc độ chính xác. Do đó, trình biên dịch Java yêu cầu bạn phải xác nhận rằng bạn đang làm điều này một cách có chủ ý bằng cách sử dụng một **ép kiểu tường minh (explicit cast)**.

Ép kiểu được thực hiện bằng cách đặt kiểu dữ liệu đích trong dấu ngoặc đơn trước giá trị.

**Ví dụ:**
```java
double myDouble = 9.78;
// int myInt = myDouble; // LỖI BIÊN DỊCH! Không thể chuyển đổi ngầm định double sang int.

int myInt = (int) myDouble; // Ép kiểu tường minh. Bạn đang nói với trình biên dịch "Tôi biết điều này có thể mất dữ liệu."
System.out.println("myDouble: " + myDouble); // Output: 9.78
System.out.println("myInt: " + myInt);     // Output: 9 (Phần thập phân bị cắt bỏ, không làm tròn)

long bigNum = 130L;
byte smallNum = (byte) bigNum; // Ép kiểu long sang byte
System.out.println("smallNum: " + smallNum); // Output: -126 (Đây là tràn số!)```
```

#### **3. Cạm bẫy phổ biến: Tràn số nguyên (Integer Overflow) và Underflow**

Các kiểu primitive có một kích thước cố định trong bộ nhớ và chỉ có thể chứa một phạm vi giá trị nhất định. Overflow xảy ra khi bạn thực hiện một phép toán dẫn đến một số quá lớn để vừa với phạm vi của kiểu dữ liệu. Underflow là khái niệm tương tự cho các số quá nhỏ.

Java **không** ném ra lỗi hoặc exception khi một số nguyên bị tràn. Thay vào đó, nó "quay vòng" đến đầu kia của phạm vi.

**Giải thích mô hình bộ nhớ:**
Một `byte` là một số nguyên có dấu 8-bit. Phạm vi của nó là từ -128 đến 127.
*   `127` trong hệ nhị phân là `0111 1111`.
*   Khi bạn cộng 1 vào nó (`127 + 1`), hệ nhị phân trở thành `1000 0000`.
*   Trong biểu diễn bù hai của Java, mẫu nhị phân này đại diện cho giá trị **-128**.

**Ví dụ:**
```java
int maxInt = Integer.MAX_VALUE; // int lớn nhất có thể: 2,147,483,647
System.out.println("Max int: " + maxInt);

int overflowedInt = maxInt + 1;
System.out.println("Max int + 1: " + overflowedInt); // Output: -2,147,483,648 (quay vòng về Integer.MIN_VALUE)

byte b = 127;
b = (byte) (b + 1); // Chúng ta phải ép kiểu vì (b+1) là một int
System.out.println("Byte 127 + 1: " + b); // Output: -128
```

**Nguyên tắc tốt nhất:** Khi thực hiện các phép tính mà có khả năng xảy ra tràn số (ví dụ: tính toán tài chính, làm việc với các ID lớn), hãy sử dụng một kiểu dữ liệu lớn hơn cho chính phép tính đó để ngăn chặn tràn số trung gian.

```java
int a = 2_000_000_000;
int b = 2_000_000_000;

// Điều này sẽ bị tràn số vì kết quả của (a+b) được tính như một int trước.
int wrongSum = a + b;
System.out.println("Wrong sum: " + wrongSum); // Xuất ra một số âm

// Đây là cách đúng. Thăng hạng một trong các toán hạng lên long.
long correctSum = (long) a + b;
System.out.println("Correct sum: " + correctSum); // Xuất ra 4000000000
```

---

#### **Bài tập nhỏ**

Kiểu dữ liệu của biến `result` trong biểu thức sau là gì, và giá trị cuối cùng của nó là gì? Giải thích các bước thăng hạng và ép kiểu liên quan.

```java
public class TypeExercise {
    public static void main(String[] args) {
        byte b = 10;
        short s = 5;
        float f = 2.5f;
        long l = 100L;

        double result = (l / b) * (s - f);

        System.out.println("Result is: " + result);
    }
}
```

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Đầu ra của đoạn code này là gì?
```java
short x = 10;
short y = 20;
// short z = x + y; // Giả sử dòng này gây ra lỗi biên dịch và đã bị xóa.
int z = x + y;
System.out.println(z);
```

A) 30, và dòng bị chú thích sẽ biên dịch tốt.
B) Nó sẽ không biên dịch vì bạn không thể cộng hai giá trị `short`.
C) 30, và dòng bị chú thích thất bại vì kết quả của `x + y` được thăng hạng lên `int`.
D) 30.0, vì kết quả được thăng hạng lên một kiểu dấu phẩy động.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) 30, và dòng bị chú thích thất bại vì kết quả của `x + y` được thăng hạng lên `int`. Đây là một bài kiểm tra trực tiếp về quy tắc thăng hạng số học, nơi các toán hạng nhỏ hơn `int` luôn được thăng hạng lên `int` trước khi thực hiện phép toán.

### **Bài 6: Các thành viên của Class và Từ khóa: `static`, `final`, `this`, và `super`**

Chào mừng đến với bài học tiếp theo! Bây giờ chúng ta sẽ chuyển từ các kiểu dữ liệu sang các khối xây dựng cơ bản của các class. Các từ khóa `static`, `final`, `this`, và `super` định nghĩa mối quan hệ giữa dữ liệu, method và object, và việc nắm vững chúng là điều cần thiết để viết mã Hướng đối tượng đúng đắn.

---

#### **1. Từ khóa `static`: Thuộc về Class**

Từ khóa `static` có nghĩa là một thành viên (một biến hoặc một method) thuộc về **chính class đó**, chứ không phải thuộc về bất kỳ instance (object) riêng lẻ nào của class đó.

**Biến `static` (Biến của Class):**
*   Một biến `static` được chia sẻ giữa tất cả các instance của một class. Chỉ có **một bản sao** của biến static, bất kể bạn tạo ra bao nhiêu object.
*   Chúng được lưu trữ trong **Method Area / Metaspace** của bộ nhớ JVM, không phải trên heap cùng với các object riêng lẻ.
*   Chúng chỉ được khởi tạo một lần, khi class được tải vào JVM.

**Ví dụ:**
```java
class Car {
    // biến instance: mỗi object Car có bản sao riêng
    public String model;

    // biến static: chỉ có một bản sao tồn tại cho toàn bộ class Car
    public static int carCount = 0;

    public Car(String model) {
        this.model = model;
        Car.carCount++; // Tăng bộ đếm được chia sẻ
    }
}

public class StaticVariableDemo {
    public static void main(String[] args) {
        System.out.println("Số lượng xe ban đầu: " + Car.carCount); // Truy cập bằng tên class

        Car car1 = new Car("BMW");
        System.out.println("Số lượng xe sau car1: " + Car.carCount);

        Car car2 = new Car("Audi");
        System.out.println("Số lượng xe sau car2: " + Car.carCount); // Cùng một biến đã được tăng
    }
}
```
**Đầu ra:**
```
Initial car count: 0
Car count after car1: 1
Car count after car2: 2
```

**Method `static`:**
*   Một method `static` có thể được gọi trực tiếp trên class, mà không cần phải tạo một instance.
*   **Quy tắc quan trọng:** Bởi vì một method `static` không chạy trong ngữ cảnh của một object cụ thể, nó **không thể** truy cập trực tiếp các biến instance hoặc method instance. Nó chỉ có thể truy cập các thành viên `static` khác. Bạn sẽ nhận được lỗi biên dịch nếu cố gắng làm vậy.
*   Method `main` là ví dụ nổi tiếng nhất của một method `static`. JVM cần gọi nó để bắt đầu chương trình *trước khi* bất kỳ object nào được tạo ra.

**Ví dụ:**
```java
class MathUtils {
    // biến instance
    public int value;

    // method static
    public static int add(int a, int b) {
        // System.out.println(value); // LỖI BIÊN DỊCH! Không thể truy cập biến instance 'value'
        return a + b;
    }
}

// Cách sử dụng:
int sum = MathUtils.add(5, 10); // Được gọi trên class, không phải một object
```

---

#### **2. Từ khóa `final`: Làm cho mọi thứ không đổi**

Từ khóa `final` là một modifier có thể được áp dụng cho các biến, method và class. Nó có nghĩa là mục đó không thể được thay đổi.

**Biến `final` (Hằng số):**
*   Một khi một biến `final` đã được gán, giá trị của nó không thể thay đổi.
*   Đối với các kiểu primitive, điều này có nghĩa là giá trị là hằng số.
*   Đối với các biến tham chiếu, điều này có nghĩa là **tham chiếu** không thể được thay đổi để trỏ đến một object khác. Tuy nhiên, trạng thái bên trong của object mà nó trỏ tới *có thể* được thay đổi (nếu object đó có thể thay đổi - mutable).

**Ví dụ:**
```java
class Circle {
    // primitive final: một hằng số thực sự
    public final double PI = 3.14159;

    // tham chiếu final: tham chiếu 'center' không thể thay đổi
    public final Point center;

    public Circle(int x, int y) {
        center = new Point(x, y); // Có thể được gán một lần, trong constructor
    }

    public void someMethod() {
        // PI = 3.14; // LỖI BIÊN DỊCH! Không thể gán lại một biến final.
        // center = new Point(5, 5); // LỖI BIÊN DỊCH! Không thể gán lại tham chiếu final.

        center.x = 10; // ĐIỀU NÀY ĐƯỢC PHÉP! Chúng ta đang thay đổi trạng thái bên trong của object Point.
    }
}
```

**Method `final`:**
*   Một method được khai báo là `final` không thể bị **override** (ghi đè) bởi một subclass. Điều này được sử dụng để đảm bảo rằng hành vi của một method cụ thể sẽ không bị thay đổi bởi các class con.

**Class `final`:**
*   Một class được khai báo là `final` không thể được **extend** (kế thừa). Lớp `String`, ví dụ, là một lớp final. Điều này thường được thực hiện vì lý do bảo mật và tính bất biến.

---

#### **3. Từ khóa `this`: Một tham chiếu đến Object hiện tại**

Bên trong một method instance hoặc một constructor, `this` là một tham chiếu đến **object hiện tại** — object mà trên đó method được gọi.

**Các trường hợp sử dụng phổ biến:**
1.  **Phân biệt các biến Instance:** Được sử dụng khi một tham số hoặc biến cục bộ có cùng tên với một biến instance.

    ```java
    public class Employee {
        private String name;

        public void setName(String name) {
            this.name = name; // this.name là biến instance, name là tham số
        }
    }
    ```
2.  **Gọi Constructor nối chuỗi (Constructor Chaining):** Để gọi một constructor từ một constructor khác trong cùng một class. Nếu được sử dụng, `this(...)` **phải** là câu lệnh đầu tiên trong constructor.

    ```java
    public class Rectangle {
        private int width, height;

        public Rectangle() {
            this(1, 1); // Gọi constructor khác với các giá trị mặc định
        }

        public Rectangle(int width, int height) {
            this.width = width;
            this.height = height;
        }
    }
    ```

---

#### **4. Từ khóa `super`: Một tham chiếu đến Class cha**

Từ khóa `super` được sử dụng để truy cập các thành viên của superclass (lớp cha) của một class từ bên trong một subclass.

**Các trường hợp sử dụng phổ biến:**
1.  **Gọi Constructor của Superclass:** Một constructor của subclass phải gọi một constructor của superclass của nó. Nếu bạn không gọi `super(...)` một cách tường minh, trình biên dịch sẽ tự động chèn một lời gọi đến constructor không có đối số của superclass `super()`. Nếu superclass không có constructor không có đối số, bạn sẽ nhận được lỗi biên dịch. `super(...)` **phải** là câu lệnh đầu tiên trong constructor.

    ```java
    class Animal {
        String name;
        Animal(String name) {
            this.name = name;
        }
    }

    class Dog extends Animal {
        Dog(String name) {
            super(name); // Phải gọi constructor của cha và truyền tên
        }
    }
    ```
2.  **Truy cập các Method đã bị Override:** Để gọi một method từ lớp cha đã bị override trong lớp hiện tại.

    ```java
    class Vehicle {
        public void start() {
            System.out.println("Vehicle is starting.");
        }
    }

    class Car extends Vehicle {
        @Override
        public void start() {
            super.start(); // Gọi method start() từ Vehicle
            System.out.println("Car is starting.");
        }
    }
    ```

---

#### **Bài tập nhỏ**

Tạo một lớp `Counter`.
1.  Nó nên có một biến integer `static` là `instanceCount` để theo dõi có bao nhiêu object `Counter` đã được tạo.
2.  Nó nên có một biến integer `instance` là `count` bắt đầu từ 0 cho mỗi object mới.
3.  Constructor nên tăng `instanceCount` và in ra tổng số hiện tại.
4.  Tạo một method `increment()` để tăng biến `instance` là `count`.
5.  Tạo một method static `getStaticCount()` để trả về `instanceCount`.
6.  Trong một method `main`, tạo ba object `Counter`, tăng count trên object đầu tiên hai lần, và sau đó in ra static count và instance count của cả ba object.

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào sau đây là **sai**?

A) Một method `static` có thể gọi các method `static` khác.
B) Một class `final` có thể có các method không phải final.
C) `this()` có thể được sử dụng ở bất kỳ đâu bên trong một constructor để gọi một constructor khác.
D) Một method `static` không thể sử dụng từ khóa `this`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `this()` có thể được sử dụng ở bất kỳ đâu bên trong một constructor để gọi một constructor khác. Điều này là sai. Lời gọi constructor `this()` hoặc `super()` phải là **câu lệnh đầu tiên** trong một constructor.

### **Bài 7: Constructors, Khối khởi tạo, và Thứ tự tạo Object**

Trong bài học này, chúng ta sẽ làm sáng tỏ vòng đời hoàn chỉnh của một object, từ lúc bạn viết `new` cho đến khi nó được khởi tạo hoàn toàn và sẵn sàng để sử dụng. Java Virtual Machine tuân theo một thứ tự hoạt động nghiêm ngặt, có thể dự đoán được, và việc hiểu rõ chuỗi này là chìa khóa để viết mã không lỗi và vượt qua các cuộc phỏng vấn kỹ thuật.

---

#### **1. Constructors: Điểm khởi đầu cho việc khởi tạo Object**

Một constructor là một khối mã đặc biệt được thực thi khi một object của một class được tạo ra. Mục đích chính của nó là để khởi tạo các biến instance của object.

**Các quy tắc và tính năng chính:**
*   Một constructor phải có **cùng tên** với class.
*   Một constructor **không thể có kiểu trả về**, ngay cả `void`.
*   Nếu bạn không định nghĩa bất kỳ constructor nào, trình biên dịch Java sẽ tự động cung cấp một **constructor không đối số mặc định** cho bạn. Constructor mặc định này gọi constructor không đối số của lớp cha (`super()`).
*   Nếu bạn định nghĩa *bất kỳ* constructor nào, trình biên dịch sẽ **không** cung cấp constructor mặc định.

**Ví dụ (Nạp chồng Constructor - Constructor Overloading):**
Giống như các method, các constructor có thể được nạp chồng để cung cấp nhiều cách tạo một object. Chúng ta có thể sử dụng `this()` để nối chuỗi chúng lại với nhau, giảm thiểu sự trùng lặp mã.

```java
public class User {
    private final String username; // các trường final phải được khởi tạo
    private final String email;
    private int age;

    // 1. Constructor chính
    public User(String username, String email, int age) {
        this.username = username;
        this.email = email;
        this.age = age;
    }

    // 2. Một constructor hai đối số nối chuỗi đến constructor chính
    public User(String username, String email) {
        this(username, email, 0); // Gọi constructor 3 đối số với tuổi mặc định
    }

    // 3. Một constructor một đối số
    public User(String username) {
        this(username, "default@example.com"); // Nối chuỗi đến constructor 2 đối số
    }
}
```

---

#### **2. Khối khởi tạo: Mã chạy trước Constructors**

Java cung cấp hai loại khối khởi tạo (hay "initializers") cho phép bạn thực thi mã trong giai đoạn khởi tạo.

**Khối khởi tạo Instance:**
*   **Cú pháp:** Một khối mã được bao bọc trong dấu ngoặc nhọn `{}` bên trong một class, nhưng bên ngoài bất kỳ method nào.
*   **Thực thi:** Mã bên trong một instance initializer chạy **mỗi khi một object được tạo ra**, sau lời gọi đến `super()` và *trước khi* phần mã còn lại trong constructor chạy.
*   **Trường hợp sử dụng:** Hữu ích để chia sẻ logic khởi tạo giữa nhiều constructor nếu bạn không thể sử dụng chuỗi `this()`, hoặc cho các khởi tạo lớp ẩn danh phức tạp.

**Khối khởi tạo Static:**
*   **Cú pháp:** Một instance block được đặt trước bởi từ khóa `static` `static { ... }`.
*   **Thực thi:** Mã bên trong một static initializer chỉ chạy **một lần**, khi class được tải lần đầu vào JVM bởi ClassLoader.
*   **Trường hợp sử dụng:** Hoàn hảo để khởi tạo các biến `static` đòi hỏi logic phức tạp, chẳng hạn như thiết lập kết nối cơ sở dữ liệu hoặc tải tệp cấu hình.

---

#### **3. Màn kết: Thứ tự khởi tạo hoàn chỉnh**

Đây là điểm quan trọng nhất của bài học. Khi bạn tạo một object của một subclass (ví dụ: `new Child()`), chuỗi sau đây xảy ra một cách chính xác.

**Giai đoạn 1: Tải Class (chỉ xảy ra một lần)**
*Giai đoạn này được thực thi lần đầu tiên `Parent` hoặc `Child` được tham chiếu.*

1.  **Khởi tạo Static của Class Parent:**
    *   Các thành viên `static` (biến) của `Parent` được khởi tạo.
    -   Các khối khởi tạo `static` của `Parent` được thực thi.
2.  **Khởi tạo Static của Class Child:**
    *   Các thành viên `static` của `Child` được khởi tạo.
    *   Các khối khởi tạo `static` của `Child` được thực thi.

**Giai đoạn 2: Tạo Instance Object (xảy ra cho mỗi lần gọi `new Child()`)**

3.  **Khởi tạo Instance của Class Parent:**
    *   Constructor cho `Child` được gọi.
    *   Dòng đầu tiên (ngầm định hoặc tường minh) là `super()`, gọi constructor của `Parent`.
    *   Các biến instance của `Parent` được khởi tạo về giá trị mặc định của chúng (`0`, `null`, `false`).
    *   **Các khối khởi tạo instance của `Parent` được thực thi.**
    *   Phần còn lại của mã constructor `Parent` được thực thi.
4.  **Khởi tạo Instance của Class Child:**
    *   Các biến instance của `Child` được khởi tạo về giá trị mặc định của chúng.
    *   **Các khối khởi tạo instance của `Child` được thực thi.**
    *   Phần còn lại của mã constructor `Child` được thực thi.

**Ví dụ minh họa thứ tự đầy đủ:**
```java
class Parent {
    // Static initializer
    static { System.out.println("1. Parent: static initializer"); }

    // Instance initializer
    { System.out.println("3. Parent: instance initializer"); }

    // Constructor
    Parent() {
        System.out.println("4. Parent: constructor");
    }
}

class Child extends Parent {
    // Static initializer
    static { System.out.println("2. Child: static initializer"); }

    // Instance initializer
    { System.out.println("5. Child: instance initializer"); }

    // Constructor
    Child() {
        super(); // Lời gọi này là ngầm định nếu không được viết
        System.out.println("6. Child: constructor");
    }
}

public class InitializationOrderDemo {
    public static void main(String[] args) {
        System.out.println("--- Creating first Child object ---");
        new Child();
        System.out.println("\n--- Creating second Child object ---");
        new Child();
    }
}
```

**Đầu ra dự đoán:**
```
--- Creating first Child object ---
1. Parent: static initializer
2. Child: static initializer
3. Parent: instance initializer
4. Parent: constructor
5. Child: instance initializer
6. Child: constructor

--- Creating second Child object ---
3. Parent: instance initializer
4. Parent: constructor
5. Child: instance initializer
6. Child: constructor
```
*(Lưu ý các khối static chỉ chạy một lần!)*

---

#### **Bài tập nhỏ**

Tạo một lớp `DatabaseConnection`.
1.  Sử dụng một khối khởi tạo `static` để in "Loading database driver..." (mô phỏng một thiết lập một lần).
2.  Sử dụng một khối khởi tạo `instance` để gán một ID kết nối duy nhất (ví dụ: từ một bộ đếm static) cho một biến instance và in "Initializing new connection with ID: ...".
3.  Tạo hai constructor nạp chồng: một nhận URL cơ sở dữ liệu (`String`) và một nhận cả URL và thời gian chờ (`int`). Cả hai nên in ra các chi tiết mà chúng nhận được.
4.  Trong `main`, tạo hai object `DatabaseConnection` sử dụng cả hai constructor để quan sát luồng khởi tạo đầy đủ.

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Khi tạo một instance của một subclass, điều gì được thực thi *cuối cùng*?

A) Constructor của superclass.
B) Khối khởi tạo instance của subclass.
C. Khối khởi tạo static của subclass.
D) Constructor của subclass.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Constructor của subclass. Đoạn mã bên trong phần thân của constructor của subclass (sau lời gọi ngầm định hoặc tường minh đến `super()`) là bước cuối cùng trong quá trình tạo instance object.

### **Bài 8: Nạp chồng (Overloading) vs. Ghi đè (Overriding) Method: Các trụ cột của tính đa hình**

Chào mừng! Bài học này giải quyết hai khái niệm trông giống nhau nhưng về cơ bản lại khác nhau: overloading và overriding. Chúng là những cơ chế chính mà qua đó Java đạt được **tính đa hình (polymorphism)**, một nguyên tắc cốt lõi của lập trình hướng đối tượng cho phép một giao diện duy nhất đại diện cho các hình thức cơ bản khác nhau (kiểu dữ liệu).

---

#### **1. Nạp chồng Method (Compile-Time Polymorphism)**

Nạp chồng method (Method overloading) cho phép một class có nhiều method với **cùng tên**, miễn là **danh sách tham số của chúng khác nhau**. Trình biên dịch có thể xác định được method nào sẽ gọi dựa trên các đối số bạn cung cấp.

Điều này còn được gọi là **đa hình tĩnh (static polymorphism)** hoặc **liên kết tại thời điểm biên dịch (compile-time binding)** vì quyết định thực thi method nào được đưa ra tại thời điểm biên dịch.

**Các quy tắc của Overloading:**
Để nạp chồng một method, danh sách tham số phải khác nhau ít nhất một trong các cách sau:
1.  **Số lượng tham số.**
2.  **Kiểu dữ liệu của tham số.**
3.  **Thứ tự của các kiểu dữ liệu của tham số.**

*Lưu ý: Kiểu trả về và access modifier có thể khác nhau, nhưng chúng **không** góp phần làm cho một method bị nạp chồng. Bạn không thể có hai method chỉ khác nhau về kiểu trả về.*

**Ví dụ:**
```java
class Calculator {
    // Các method add được nạp chồng

    // 1. Hai int
    public int add(int a, int b) {
        System.out.println("Called add(int, int)");
        return a + b;
    }

    // 2. Ba int (số lượng tham số khác nhau)
    public int add(int a, int b, int c) {
        System.out.println("Called add(int, int, int)");
        return a + b + c;
    }

    // 3. Hai double (kiểu dữ liệu khác nhau)
    public double add(double a, double b) {
        System.out.println("Called add(double, double)");
        return a + b;
    }

    // Đây sẽ là LỖI BIÊN DỊCH - không thể nạp chồng chỉ dựa trên kiểu trả về
    // public double add(int a, int b) { return a + b; }
}

public class OverloadingDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        calc.add(5, 10);        // Gọi phiên bản 1
        calc.add(5, 10, 15);    // Gọi phiên bản 2
        calc.add(2.5, 3.5);     // Gọi phiên bản 3
    }
}
```

---

#### **2. Ghi đè Method (Run-Time Polymorphism)**

Ghi đè method (Method overriding) xảy ra khi một subclass (lớp con) cung cấp một triển khai cụ thể cho một method đã được định nghĩa trong superclass (lớp cha) của nó.

Đây là nền tảng của **đa hình động (dynamic polymorphism)** hoặc **liên kết tại thời điểm chạy (run-time binding)** (late binding). JVM xác định method nào sẽ gọi tại *thời điểm chạy*, dựa trên **kiểu thực tế của object**, chứ không phải kiểu của biến tham chiếu.

**Các quy tắc của Overriding (Hợp đồng `@Override`):**
Để ghi đè một method một cách chính xác, method của subclass phải tuân thủ các quy tắc sau:
1.  Nó phải có **cùng tên** với method của superclass.
2.  Nó phải có **cùng danh sách tham số** (số lượng, kiểu, và thứ tự).
3.  Kiểu trả về phải giống nhau hoặc là một **kiểu hiệp biến (covariant type)** (một subtype của kiểu trả về ban đầu).
4.  Access modifier **không được hạn chế hơn** so với method được ghi đè (ví dụ: bạn không thể ghi đè một method `public` bằng một method `protected`, nhưng bạn có thể đi từ `protected` lên `public`).
5.  Bạn **không thể** ghi đè các method `final` hoặc `static`. Các method `private` cũng không được ghi đè theo nghĩa truyền thống vì chúng không hiển thị với subclass.

**Ví dụ:**
```java
class Animal {
    public void makeSound() {
        System.out.println("The animal makes a generic sound.");
    }
}

class Dog extends Animal {
    @Override // Thói quen tốt là sử dụng annotation này!
    public void makeSound() {
        System.out.println("The dog barks: Woof!");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("The cat meows: Meow!");
    }
}

public class OverridingDemo {
    public static void main(String[] args) {
        // Kiểu tham chiếu là Animal, nhưng kiểu object là Dog
        Animal myPet = new Dog();
        myPet.makeSound(); // JVM kiểm tra object tại thời điểm chạy. Đó là Dog -> gọi method của Dog.

        // Bây giờ tham chiếu trỏ đến một object Cat
        myPet = new Cat();
        myPet.makeSound(); // JVM thấy một object Cat -> gọi method của Cat.
    }
}
```

**Đầu ra:**
```
The dog barks: Woof!
The cat meows: Meow!
```

---

#### **3. Bảng tóm tắt: Overloading vs. Overriding**

| Tính năng              | Nạp chồng Method (Method Overloading)                    | Ghi đè Method (Method Overriding)                           |
| ----------------------- | -------------------------------------------------------- | ----------------------------------------------------------- |
| **Mục đích**            | Để cung cấp nhiều cách để thực hiện một hành động tương tự.| Để cung cấp một triển khai cụ thể của một method được kế thừa.|
| **Vị trí**              | Có thể ở trong cùng một class hoặc một subclass.          | Phải ở trong một subclass.                                  |
| **Chữ ký Method**       | Cùng tên, nhưng **danh sách tham số khác nhau**.         | Cùng tên và **cùng danh sách tham số**.                      |
| **Kiểu trả về**         | Có thể giống hoặc khác nhau.                             | Phải giống nhau hoặc là một kiểu hiệp biến.                  |
| **Loại đa hình**        | Thời gian biên dịch (Đa hình tĩnh).                      | Thời gian chạy (Đa hình động).                              |
| **Liên kết (Binding)**  | **Static Binding**: Quyết định được đưa ra bởi trình biên dịch.| **Dynamic Binding**: Quyết định được đưa ra bởi JVM tại thời gian chạy.|
| **Từ khóa liên quan**   | Không có gì cụ thể.                                      | `extends` (cho kế thừa), `super` (để gọi method của cha). |
| **Annotation `@Override`**| Không thể sử dụng.                                      | Được khuyến nghị để kiểm tra tại thời gian biên dịch.       |

---

#### **Bài tập nhỏ**

1.  Tạo một lớp cơ sở `Logger`.
2.  Bên trong `Logger`, tạo ba method **nạp chồng** có tên `log`:
    *   `log(String message)`
    *   `log(String message, int level)`
    *   `log(String message, String category)`
    *   Mỗi method nên in ra các đối số mà nó nhận được.
3.  Tạo một subclass có tên `FileLogger` kế thừa từ `Logger`.
4.  Trong `FileLogger`, **ghi đè** method `log(String message)` để in "Logging to file: " trước thông điệp.
5.  Trong một method `main`, tạo một object của `FileLogger` với một tham chiếu `Logger`: `Logger myLogger = new FileLogger();`.
6.  Gọi cả ba method `log` trên `myLogger` và quan sát phiên bản nào (cơ sở hay con) được thực thi.

---

#### **Câu hỏi trắc nghiệm**

**Câu hỏi:** Xem xét đoạn mã sau. Nó có biên dịch được không? Nếu không, tại sao?
```java
class SuperClass {
    public void show(int a) {
        System.out.println("SuperClass show");
    }
}

class SubClass extends SuperClass {
    @Override
    public void show(long a) { // Lưu ý sự thay đổi từ int sang long
        System.out.println("SubClass show");
    }
}
```

A) Có, nó sẽ biên dịch và đó là một ghi đè hợp lệ.
B) Không, nó sẽ không biên dịch vì kiểu trả về khác nhau.
C) Không, nó sẽ không biên dịch vì annotation `@Override` không chính xác; đây là nạp chồng, không phải ghi đè.
D) Có, nó sẽ biên dịch và đó là một nạp chồng hợp lệ.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Không, nó sẽ không biên dịch vì annotation `@Override` không chính xác; đây là nạp chồng, không phải ghi đè. Danh sách tham số (`int a` vs. `long a`) khác nhau, điều này làm cho nó trở thành một nạp chồng. Tuy nhiên, annotation `@Override` nói với trình biên dịch "Tôi định ghi đè một method từ superclass." Vì không có method nào với chữ ký `show(long a)` tồn tại trong superclass để ghi đè, trình biên dịch báo đây là một lỗi. Đây là một lợi ích chính của việc sử dụng annotation `@Override`.

### **Bài 9: Tóm tắt chủ đề, Câu hỏi phỏng vấn và Dự án cuối cùng**

Chúc mừng bạn đã đến bài học cuối cùng về Cú pháp và Ngôn ngữ cơ bản của Java! Chúng ta đã đi qua toàn bộ hành trình từ cách mã Java chạy đến sự phức tạp của việc tạo đối tượng và tính đa hình. Bài học này sẽ giúp bạn củng cố kiến thức đó và chuẩn bị bạn để áp dụng nó.

---

#### **1. Bảng tóm tắt các điểm chính**

| Khái niệm | Điểm chính |
| :--- | :--- |
| **JVM, JRE, JDK** | **JDK** dành cho phát triển (trình biên dịch `javac`). **JRE** dành cho việc chạy (lệnh `java`). **JVM** là máy ảo thực thi bytecode độc lập với nền tảng. |
| **Mô hình bộ nhớ JVM** | **Stack**: Lưu trữ các kiểu primitive và tham chiếu cho các biến cục bộ. Nhanh, LIFO, cho mỗi thread. **Heap**: Lưu trữ tất cả các object. Được quản lý bởi Garbage Collector, được chia sẻ bởi tất cả các thread. **Metaspace**: Lưu trữ định nghĩa class và các thành viên static. |
| **Primitives vs. Reference Types** | **Primitives** (`int`, `char`, v.v.) giữ giá trị trực tiếp. **References** giữ địa chỉ bộ nhớ của một object trên Heap. Java luôn là **pass-by-value** (một bản sao của giá trị hoặc một bản sao của tham chiếu được truyền đi). |
| **`String` Immutability & Pool** | Các object `String` là immutable (không thể thay đổi). Các string literal (`"abc"`) được lưu trữ trong một **String Pool** được chia sẻ để tiết kiệm bộ nhớ. `new String("abc")` tạo một object mới trên heap. Sử dụng `.equals()` để so sánh nội dung, `==` để so sánh tham chiếu. |
| **Type Casting & Promotion** | **Widening (Promotion)** là ngầm định từ kiểu nhỏ hơn sang kiểu lớn hơn (ví dụ: `int` sang `long`). **Narrowing (Casting)** là tường minh từ lớn hơn sang nhỏ hơn và có thể gây mất dữ liệu (ví dụ: `(int) myDouble`). Các phép toán trên `byte`/`short` được thăng hạng lên `int`. |
| **`static` vs. Instance** | Các thành viên **`static`** thuộc về class (một bản sao, được chia sẻ). Các thành viên **Instance** thuộc về object (mỗi object có bản sao riêng). Các method static không thể truy cập trực tiếp các thành viên instance. |
| **`final`, `this`, `super`** | **`final`**: Làm cho các biến thành hằng số, các method không thể ghi đè, và các class không thể kế thừa. **`this`**: Tham chiếu đến instance object hiện tại. **`super`**: Tham chiếu đến lớp cha, được sử dụng để gọi các constructor và method của cha. |
| **Thứ tự khởi tạo** | 1. Các khối & biến Static của Cha. 2. Các khối & biến Static của Con. 3. Các khối & biến Instance của Cha. 4. Constructor của Cha. 5. Các khối & biến Instance của Con. 6. Constructor của Con. (Các phần static chỉ chạy một lần cho mỗi lần tải class). |
| **Overloading vs. Overriding** | **Overloading**: Cùng tên method, danh sách tham số khác nhau (Đa hình tại thời điểm biên dịch). **Overriding**: Subclass cung cấp một triển khai mới cho một method được kế thừa; cùng tên và tham số (Đa hình tại thời điểm chạy). |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

Dưới đây là một số câu hỏi thường gặp và đầy thách thức kiểm tra các khái niệm chúng ta đã học.

1.  **"Giải thích sự khác biệt giữa JDK, JRE, và JVM."**
    *   *Trả lời:* JDK là Java Development Kit, một bộ công cụ đầy đủ cho các nhà phát triển bao gồm trình biên dịch và trình gỡ lỗi. JRE là Java Runtime Environment, cung cấp các thư viện và JVM cần thiết để *chạy* các ứng dụng Java. JVM là Java Virtual Machine, một máy trừu tượng thực thi bytecode, cho phép Java độc lập với nền tảng.

2.  **"Java là pass-by-value hay pass-by-reference?"**
    *   *Trả lời:* Java hoàn toàn là pass-by-value. Đối với các kiểu primitive, một bản sao của giá trị được truyền đi. Đối với các kiểu tham chiếu, một bản sao của *tham chiếu* (địa chỉ bộ nhớ) được truyền đi. Điều này có nghĩa là bạn không thể thay đổi tham chiếu gốc để trỏ đến một object mới, nhưng bạn có thể sửa đổi trạng thái bên trong của object duy nhất mà cả tham chiếu gốc và bản sao đều trỏ tới.

3.  **"Từ khóa `static` làm gì? Tại sao method `main` lại là static?"**
    *   *Trả lời:* Từ khóa `static` chỉ ra rằng một thành viên thuộc về chính class đó, không thuộc về một instance riêng lẻ. Chỉ có một bản sao của một thành viên static. Method `main` là static để JVM có thể gọi nó để bắt đầu chương trình mà không cần phải tạo một instance của class trước.

4.  **"String Pool là gì và nó liên quan đến `==` vs `.equals()` như thế nào?"**
    *   *Trả lời:* String Pool là một vùng bộ nhớ đặc biệt nơi Java lưu trữ các string literal. Khi bạn tạo một string literal, Java sẽ kiểm tra pool trước và tái sử dụng một chuỗi hiện có nếu tìm thấy. Toán tử `==` so sánh địa chỉ bộ nhớ, vì vậy nó sẽ là `true` đối với hai literal có cùng nội dung vì chúng trỏ đến cùng một object trong pool. `.equals()` so sánh nội dung ký tự thực tế. `new String("...")` luôn tạo một object bên ngoài pool, vì vậy `==` sẽ là false khi so sánh nó với một literal. Bạn nên luôn sử dụng `.equals()` để so sánh nội dung chuỗi cho đáng tin cậy.

5.  **"Bạn có thể override một method `private` hoặc `final` không?"**
    *   *Trả lời:* Không. Một method `final` không thể bị override theo thiết kế; đây là một cách để ngăn các subclass thay đổi hành vi quan trọng. Một method `private` không hiển thị với subclass, vì vậy nó không thể bị override theo nghĩa truyền thống. Nếu bạn định nghĩa một method có cùng chữ ký trong subclass, đó là một method mới, không phải là một override.

6.  **"Mô tả thứ tự thực thi của các constructor và initializer khi tạo một object subclass."**
    *   *Trả lời:* Đầu tiên, tất cả các static initializer chạy, từ lớp cha xuống lớp con (điều này chỉ xảy ra một lần khi lớp được tải lần đầu). Sau đó, đối với mỗi lần tạo object: các instance initializer của lớp cha chạy, tiếp theo là constructor của lớp cha. Sau khi lớp cha được khởi tạo hoàn toàn, các instance initializer của lớp con chạy, tiếp theo là constructor của lớp con.

---

#### **3. Dự án nhỏ cuối cùng: Hệ thống phân cấp công ty**

Dự án này sẽ yêu cầu bạn áp dụng gần như tất cả các khái niệm chúng ta đã học để xây dựng một ứng dụng console đơn giản để quản lý nhân viên.

**🎯 Mục tiêu:** Tạo một hệ thống có thể đăng ký các loại nhân viên khác nhau (Managers, Developers), gán cho họ các ID duy nhất, và tính toán tiền thưởng hàng năm của họ dựa trên vai trò của họ.

**Yêu cầu dự án:**

1.  **`Employee` (Lớp cơ sở):**
    *   `private static int employeeCounter`: Một biến static để theo dõi số lượng nhân viên được tạo và gán ID duy nhất.
    *   `private final int employeeId`: Một biến instance final, chỉ được đặt một lần trong constructor bằng `employeeCounter`.
    *   `private String name`: Tên của nhân viên.
    *   `protected double baseSalary`: Một biến protected cho mức lương.
    *   Một constructor chấp nhận tên và lương cơ bản, và tự động đặt `employeeId`.
    *   Một method `double calculateBonus()` trả về tiền thưởng mặc định là 10% lương cơ bản.
    *   Một method `getDetails()` để trả về một chuỗi được định dạng với ID, tên và lương của nhân viên.

2.  **`Manager` (Subclass của `Employee`):**
    *   `private double managementBonus`: Một khoản thưởng thêm cho các quản lý.
    *   Một constructor chấp nhận tên, lương cơ bản, và tiền thưởng quản lý. Nó phải gọi constructor của lớp cha bằng `super()`.
    *   **Override** method `calculateBonus()`. Tổng tiền thưởng của một quản lý là tiền thưởng nhân viên tiêu chuẩn *cộng với* `managementBonus`.
    *   **Override** method `getDetails()` để bao gồm "Role: Manager" trong chuỗi đầu ra.

3.  **`Developer` (Subclass của `Employee`):**
    *   `private String programmingLanguage`: Ngôn ngữ lập trình chính của nhà phát triển.
    *   Một constructor chấp nhận tên, lương cơ bản, và ngôn ngữ lập trình.
    *   **Override** method `getDetails()` để bao gồm ngôn ngữ lập trình trong chuỗi đầu ra. (Các nhà phát triển nhận được tiền thưởng 10% tiêu chuẩn, vì vậy không cần override `calculateBonus`).

4.  **`Company` (Lớp Main):**
    *   Một method `main` để chạy mô phỏng.
    *   Tạo một mảng các tham chiếu `Employee`.
    *   Tạo ít nhất hai object `Manager` và hai object `Developer` và lưu chúng vào mảng (điều này thể hiện tính đa hình).
    *   Lặp qua mảng và đối với mỗi nhân viên, in ra chi tiết và tiền thưởng đã tính của họ bằng cách sử dụng các method.

**Ví dụ đầu ra:**
```
--- Employee Details ---
ID: 1, Name: Alice, Salary: 80000.0, Role: Manager
Bonus for Alice: 13000.0

ID: 2, Name: Bob, Salary: 60000.0, Role: Developer, Language: Java
Bonus for Bob: 6000.0

... and so on ...
```

Điều này kết thúc phần tìm hiểu sâu về Cú pháp và Ngôn ngữ cơ bản của Java. Hoàn thành dự án này sẽ củng cố sự hiểu biết của bạn và cung cấp cho bạn kinh nghiệm thực tế với các khái niệm cốt lõi này.