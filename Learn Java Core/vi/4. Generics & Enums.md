### **Bài 1: Giới thiệu về Generics**

#### **1. Giải thích khái niệm**

##### **Động lực: Vấn đề trước khi có Generics**
Trước Java 5, các collection lưu trữ các phần tử có kiểu `Object`. Cách tiếp cận này có hai nhược điểm lớn:
1.  **Thiếu an toàn kiểu (Type Safety):** Bạn có thể vô tình thêm một object sai kiểu vào một collection. Lỗi sẽ chỉ được phát hiện tại thời điểm chạy khi object được lấy ra và ép kiểu.
2.  **Ép kiểu thủ công tẻ nhạt:** Bạn phải ép kiểu tường minh mọi object được lấy ra từ một collection về kiểu ban đầu của nó. Điều này làm lộn xộn mã và là một nguồn tiềm ẩn liên tục của các lỗi `ClassCastException`.

**Mã không có Generics (Cách "cũ"):**
```java
List list = new ArrayList();
list.add("hello");
list.add(123); // Không có lỗi biên dịch, nhưng đây là một sai lầm logic.

// Sau đó trong mã...
for (Object obj : list) {
    // Chúng ta phải ép kiểu, nhưng nếu obj là Integer thì sao?
    String str = (String) obj; // Ném ra ClassCastException tại thời điểm chạy đối với số nguyên.
}
```

##### **Giải pháp Generic: An toàn kiểu và Tái sử dụng**
Generics giải quyết vấn đề này bằng cách cho phép bạn tạo các lớp, interface và method hoạt động trên các kiểu như là các tham số. Một kiểu generic là một trình giữ chỗ được thay thế bằng một kiểu thực tế khi được sử dụng.

1.  **An toàn kiểu tại thời điểm biên dịch (Compile-Time Type Safety):** Trình biên dịch thực thi các ràng buộc về kiểu. Nếu bạn khai báo một `List<String>`, trình biên dịch sẽ chỉ cho phép bạn thêm các object `String` vào đó, bắt lỗi trong quá trình biên dịch, không phải tại thời điểm chạy.
2.  **Loại bỏ ép kiểu:** Vì trình biên dịch đảm bảo kiểu của các phần tử trong collection, bạn không còn cần phải ép kiểu nữa. Mã trở nên sạch hơn và an toàn hơn.
3.  **Tái sử dụng mã:** Bạn có thể viết một thuật toán hoặc cấu trúc dữ liệu generic duy nhất (như `ArrayList<T>`) và sử dụng nó với nhiều kiểu khác nhau (`ArrayList<String>`, `ArrayList<Integer>`, v.v.) mà không cần viết lại mã.

##### **Cú pháp Generic**
*   **Lớp/Interface Generic:** Tham số kiểu, được đặt trong dấu ngoặc nhọn `<>`, được chỉ định sau tên lớp/interface.
    ```java
    // Một lớp generic 'Box' có thể chứa bất kỳ kiểu 'T' nào
    public class Box<T> {
        private T content;
        public void set(T content) { this.content = content; }
        public T get() { return content; }
    }
    ```
*   **Method Generic:** Tham số kiểu được khai báo trước kiểu trả về của method. Điều này hữu ích cho các method static hoặc khi kiểu của method độc lập với kiểu của lớp.
    ```java
    public <U> void inspect(U item) {
        System.out.println("Item's class: " + item.getClass().getName());
    }
    ```

##### **Suy luận kiểu và Toán tử kim cương (`<>`)**
Kể từ Java 7, bạn có thể bỏ qua kiểu generic ở vế phải của một phép gán nếu trình biên dịch có thể suy ra nó từ vế trái. Điều này được gọi là toán tử kim cương.

```java
// Trước Java 7 (dài dòng)
Box<Integer> integerBox = new Box<Integer>();

// Java 7+ với Toán tử kim cương (ngắn gọn)
Box<Integer> integerBox = new Box<>(); // Trình biên dịch suy ra <Integer>
```

##### **Raw Types: Một liên kết đến quá khứ**
Một raw type là tên của một lớp hoặc interface generic được sử dụng mà không có bất kỳ đối số kiểu nào.
`Box rawBox = new Box(); // 'rawBox' là một raw type`

Raw types tồn tại chủ yếu để tương thích ngược với mã trước khi có generics. **Bạn không bao giờ nên sử dụng chúng trong mã mới.** Sử dụng một raw type thực chất là vô hiệu hóa tất cả các kiểm tra an toàn tại thời điểm biên dịch cho instance đó, quay trở lại hành vi trước generics là lưu trữ các `Object` và yêu cầu ép kiểu thủ công. Trình biên dịch sẽ đưa ra các cảnh báo "unchecked" khi bạn trộn lẫn các raw type với các parameterized type.

---

#### **2. Ví dụ mã nguồn**

```java
// Một lớp generic để chứa một giá trị của bất kỳ kiểu nào.
class Container<T> {
    private T item;

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return item;
    }
}

public class GenericsIntroDemo {
    public static void main(String[] args) {
        // --- Cách Generic an toàn kiểu ---
        System.out.println("--- Generic Container Demo ---");
        // Tạo một Container cho Integer
        Container<Integer> intContainer = new Container<>();
        intContainer.setItem(42);
        // intContainer.setItem("hello"); // LỖI BIÊN DỊCH! An toàn kiểu đang hoạt động.

        // Không cần ép kiểu, và kiểu được đảm bảo.
        Integer value = intContainer.getItem();
        System.out.println("Integer value: " + value);

        // --- Sử dụng Raw Type (Đừng làm điều này trong mã mới!) ---
        System.out.println("\n--- Raw Type Demo ---");
        Container rawContainer = new Container(); // Cảnh báo chuyển đổi không kiểm tra
        rawContainer.setItem("Some Text"); // Điều này ổn
        rawContainer.setItem(123);         // Điều này cũng ổn, nhưng mất thông tin kiểu

        // Chúng ta nghĩ nó là một Integer, nhưng không phải. Điều này sẽ biên dịch...
        // ...nhưng sẽ ném ra một ClassCastException tại thời điểm chạy.
        try {
            // Chúng ta đã mất an toàn tại thời điểm biên dịch và phải ép kiểu.
            String text = (String) rawContainer.getItem();
        } catch (ClassCastException e) {
            System.out.println("ERROR: Using a raw type led to a ClassCastException!");
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp generic có tên `Pair<K, V>`.
2.  Nó nên có hai trường private: `key` kiểu `K` và `value` kiểu `V`.
3.  Tạo một constructor chấp nhận một key và một value để khởi tạo các trường.
4.  Tạo các method getter public `getKey()` và `getValue()`.
5.  Trong một method `main`, khởi tạo lớp này để tạo một cặp của một `String` và một `Integer` (ví dụ: `Pair<String, Integer> studentGrade = new Pair<>("Alice", 95);`).
6.  In ra key và value bằng cách sử dụng các getter.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Lợi ích chính của việc sử dụng generics trong Java là gì?

A) Chúng cải thiện hiệu suất thời gian chạy của các collection bằng cách loại bỏ các kiểm tra kiểu.
B) Chúng cho phép một lớp kế thừa nhiều lớp cha.
C) Chúng thực thi an toàn kiểu tại thời điểm biên dịch, ngăn chặn `ClassCastException` tại thời điểm chạy.
D) Chúng cho phép sử dụng các kiểu nguyên thủy như `int` và `double` trong các collection.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Chúng thực thi an toàn kiểu tại thời điểm biên dịch, ngăn chặn `ClassCastException` tại thời điểm chạy. Mục đích cốt lõi của generics là chuyển các lỗi kiểu từ thời gian chạy sang thời gian biên dịch, làm cho mã an toàn và mạnh mẽ hơn.

### **Bài 2: Tham số kiểu và Giới hạn (Bounds)**

#### **1. Giải thích khái niệm**

Trong khi các generics cơ bản đã mạnh mẽ, sự linh hoạt thực sự của chúng đến từ khả năng ràng buộc các kiểu có thể được sử dụng làm tham số. Điều này đạt được thông qua **giới hạn (bounds)** và **ký tự đại diện (wildcards)**.

##### **Quy ước đặt tên tham số kiểu**
Theo quy ước, tên tham số kiểu là các chữ cái đơn, viết hoa để phân biệt chúng với tên lớp thông thường.
*   `T` - Type (một kiểu generic)
*   `E` - Element (được sử dụng rộng rãi bởi Collections Framework)
*   `K` - Key (được sử dụng trong map)
*   `V` - Value (được sử dụng trong map)
*   `N` - Number
*   `S`, `U`, `V` v.v. - các kiểu thứ 2, 3, 4

##### **Tham số kiểu có giới hạn (`<T extends Type>`)**
Đôi khi bạn cần đảm bảo rằng một tham số kiểu là một subtype của một lớp cụ thể hoặc triển khai một interface cụ thể. Điều này được gọi là một **tham số kiểu có giới hạn (bounded type parameter)**. Nó hạn chế "vũ trụ" các kiểu có thể được thay thế cho tham số.

*   **Cú pháp:** `<T extends SomeClass>`, `<T extends SomeInterface>`.
*   **Từ khóa `extends`:** Trong ngữ cảnh của generics, `extends` được sử dụng cho cả lớp và interface. Nó có nghĩa là "là một subtype của".
*   **Lợi ích:** Bên trong mã generic, bây giờ bạn có thể gọi một cách an toàn các method được định nghĩa trong kiểu giới hạn.

**Nhiều giới hạn:** Một tham số kiểu có thể có nhiều giới hạn, nhưng lớp phải đứng trước, theo sau là các interface, được phân tách bằng một dấu và (`&`).
`<T extends Number & Comparable<T> & Serializable>`

##### **Ký tự đại diện (`?`) cho sự linh hoạt của API**
Một ký tự đại diện đại diện cho một "kiểu không xác định." Nó được sử dụng để làm cho các API linh hoạt hơn, đặc biệt là khi xử lý các collection. Có ba loại ký tự đại diện.

1.  **Ký tự đại diện có giới hạn trên (`? extends Type`)**
    *   **Ý nghĩa:** Một kiểu không xác định là một subtype của `Type` (hoặc chính `Type`).
    *   **Ví dụ:** `List<? extends Number>` có thể là một `List<Integer>`, `List<Double>`, `List<Number>`, v.v.
    *   **Hạn chế:** Bạn có thể **đọc** từ cấu trúc này (bạn được đảm bảo sẽ nhận được ít nhất là một `Type`), nhưng bạn **không thể ghi** vào nó (ngoại trừ `null`). Trình biên dịch không biết subtype chính xác, vì vậy nó không thể đảm bảo rằng việc thêm một `Integer` sẽ an toàn cho một `List<Double>`. Đây là vai trò "Producer".

2.  **Ký tự đại diện có giới hạn dưới (`? super Type`)**
    *   **Ý nghĩa:** Một kiểu không xác định là một supertype của `Type` (hoặc chính `Type`).
    *   **Ví dụ:** `List<? super Integer>` có thể là một `List<Integer>`, `List<Number>`, hoặc `List<Object>`.
    *   **Hạn chế:** Bạn có thể **ghi** các object `Type` (hoặc các subtype của nó) vào cấu trúc này, nhưng bạn **không được đảm bảo về kiểu khi bạn đọc** từ nó (bạn chỉ biết đó là một `Object`). Đây là vai trò "Consumer".

3.  **Ký tự đại diện không giới hạn (`?`)**
    *   **Ý nghĩa:** Một kiểu không xác định thuộc bất kỳ loại nào. Nó là viết tắt của `? extends Object`.
    *   **Ví dụ:** `List<?>`.
    *   **Hạn chế:** Bạn có thể đọc các phần tử và được đảm bảo chúng là các `Object`. Bạn không thể ghi bất cứ thứ gì vào nó (ngoại trừ `null`). Nó hữu ích cho các method hoạt động trên cấu trúc của một collection mà không phụ thuộc vào kiểu phần tử (ví dụ: một method `printList(List<?> list)` chỉ gọi `list.size()` hoặc lặp và in).

##### **Nguyên tắc PECS: Producer Extends, Consumer Super**
Đây là một câu ghi nhớ quan trọng nhất để hiểu khi nào nên sử dụng `extends` và `super`.
*   "**P**roducer **E**xtends": Nếu một cấu trúc generic là một **producer** của các mục (bạn chỉ lấy các mục *ra* khỏi nó), hãy sử dụng `? extends T`.
*   "**C**onsumer **S**uper": Nếu một cấu trúc generic là một **consumer** của các mục (bạn chỉ đặt các mục *vào* nó), hãy sử dụng `? super T`.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa các tham số kiểu có giới hạn và nguyên tắc PECS trong một method `copy`.

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class BoundsAndWildcardsDemo {

    // Tham số kiểu có giới hạn: Method này chỉ hoạt động trên các danh sách của Number (hoặc các subtype của nó).
    // Vì có giới hạn, chúng ta có thể gọi một cách an toàn method doubleValue().
    public static <T extends Number> double sumOfList(List<T> list) {
        double sum = 0.0;
        for (Number n : list) {
            sum += n.doubleValue();
        }
        return sum;
    }

    // PECS đang hoạt động:
    // 'source' là một producer, vì vậy chúng ta sử dụng 'extends'. Chúng ta đọc từ nó.
    // 'dest' là một consumer, vì vậy chúng ta sử dụng 'super'. Chúng ta ghi vào nó.
    public static <T> void copy(List<? extends T> source, List<? super T> dest) {
        for (T item : source) {
            dest.add(item);
        }
    }

    public static void main(String[] args) {
        // --- Demo Tham số kiểu có giới hạn ---
        List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);
        System.out.println("Sum of integers: " + sumOfList(integers));

        List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
        System.out.println("Sum of doubles: " + sumOfList(doubles));

        // List<String> strings = Arrays.asList("a", "b");
        // sumOfList(strings); // LỖI BIÊN DỊCH! String không kế thừa Number.

        // --- Demo PECS ---
        List<Number> numbers = new ArrayList<>();
        // Bạn có thể sao chép một List<Integer> (producer) vào một List<Number> (consumer).
        copy(integers, numbers);
        System.out.println("Copied list: " + numbers);
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một method generic `findMax` với chữ ký `<T extends Comparable<T>> T findMax(List<T> list)`.
2.  Giới hạn `extends Comparable<T>` là rất quan trọng vì nó đảm bảo rằng bất kỳ object nào thuộc kiểu `T` sẽ có một method `compareTo()`, mà bạn cần để so sánh.
3.  Triển khai method. Nó nên lặp qua danh sách và sử dụng `compareTo()` để tìm và trả về phần tử lớn nhất.
4.  Trong `main`, kiểm tra method của bạn với một `List<Integer>` và một `List<String>`.
5.  Thử gọi nó với một `List` các object từ một lớp không triển khai `Comparable` và quan sát lỗi tại thời điểm biên dịch.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang viết một method tiện ích nhận một `List` và thêm một vài object `Dog` mới vào đó. Lớp `Dog` kế thừa `Animal`. Chữ ký method nào sau đây là linh hoạt và đúng nhất theo nguyên tắc PECS?

A) `void addDogs(List<Dog> list)`
B) `void addDogs(List<? extends Animal> list)`
C) `void addDogs(List<? super Dog> list)`
D) `void addDogs(List<Animal> list)`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `void addDogs(List<? super Dog> list)`. Danh sách là một **consumer** của các object `Dog` (bạn đang đặt chó *vào* nó), vì vậy `super` là lựa chọn đúng. Chữ ký này cho phép method hoạt động với một `List<Dog>`, một `List<Animal>`, hoặc một `List<Object>`, tất cả đều là các consumer hợp lệ của các object `Dog`. Chữ ký B (`extends`) sẽ không đúng vì bạn không thể ghi vào một danh sách có giới hạn `extends`. Các chữ ký A và D kém linh hoạt hơn C.

### **Bài 3: Type Erasure và Hành vi Runtime**

#### **1. Giải thích khái niệm**

Một sự hiểu biết sâu sắc về generics đòi hỏi phải biết "bí mật" lớn nhất của chúng: **generics là một cấu trúc tại thời điểm biên dịch**. Java Virtual Machine (JVM) gần như không biết gì về các kiểu generic bạn sử dụng trong mã của mình. Cơ chế này được gọi là **Type Erasure**.

##### **Type Erasure là gì?**

Để duy trì khả năng tương thích ngược với các phiên bản cũ hơn của Java, trình biên dịch triển khai generics bằng cách thực hiện các bước sau trong quá trình biên dịch:

1.  **Thay thế các tham số kiểu có giới hạn:** Nó thay thế tất cả các tham số kiểu có giới hạn bằng giới hạn đầu tiên của chúng. Đối với `<T extends Number>`, `T` trở thành `Number`. Đối với một giới hạn lớp và interface `<T extends Number & Runnable>`, `T` cũng trở thành `Number`.
2.  **Thay thế các tham số kiểu không giới hạn:** Nó thay thế tất cả các tham số kiểu không giới hạn (như `<T>`, `<E>`) bằng `Object`.
3.  **Chèn các ép kiểu:** Nó chèn các ép kiểu cần thiết ở những nơi cần thiết để duy trì an toàn kiểu. Ví dụ, khi bạn `get()` một phần tử từ một `List<String>`, trình biên dịch âm thầm chèn một ép kiểu `(String)` cho bạn.
4.  **Tạo các Bridge Method:** Nó tạo ra các method "cầu nối" đặc biệt để đảm bảo rằng tính đa hình hoạt động chính xác với các method generic được ghi đè trong các lớp con.

**Ví dụ tương tự:** Hãy nghĩ về type erasure như một công thức làm bánh sử dụng một cái khuôn. Tại thời điểm thiết kế (thời điểm biên dịch), bạn sử dụng một cái khuôn "Hình ngôi sao" (`<String>`) để lên kế hoạch cho những chiếc bánh quy của mình. Bạn biết mình sẽ chỉ làm những chiếc bánh quy hình ngôi sao. Nhưng khi bạn thực sự nướng (thời điểm chạy), bạn sử dụng một cái cắt bánh quy tròn, chung chung (`Object`). JVM chỉ thấy những chiếc bánh quy tròn. Tuy nhiên, người làm bánh (trình biên dịch) đã để lại một ghi chú: "Mỗi chiếc bánh quy từ lô này nên được coi như một ngôi sao." Khi ai đó lấy một chiếc bánh quy, người làm bánh đảm bảo rằng nó được trao đi *như thể* nó là một ngôi sao (ép kiểu được chèn vào).

##### **Hậu quả và Hạn chế của Generics**

Type erasure là nguyên nhân gốc rễ của hầu hết các hạn chế của generics trong Java.

1.  **Không thể sử dụng Primitives:** Bạn không thể sử dụng các kiểu nguyên thủy làm tham số kiểu (`List<int>` là bất hợp pháp). Điều này là do `int` không phải là một subtype của `Object`, là kiểu đã bị xóa cho các generics không giới hạn. Bạn phải sử dụng các lớp bao bọc của chúng (`List<Integer>`).

2.  **Không thể tạo các Instance của Tham số kiểu (`new T()`):** Bạn không thể viết `new T()` vì tại thời điểm chạy, `T` bị xóa thành `Object`. Trình biên dịch không biết constructor nào để gọi. `new Object()` sẽ không chính xác và vô dụng.

3.  **Không thể tạo các Mảng Generic (`new T[]`):** `new T[10]` là bất hợp pháp. Các mảng trong Java lưu trữ thông tin kiểu tại thời điểm chạy để thực hiện các kiểm tra lưu trữ mảng. Bởi vì `T` bị xóa, thời gian chạy sẽ không biết loại object nào được phép trong mảng, phá vỡ sự an toàn của mảng.

4.  **Không thể sử dụng `instanceof` với các Kiểu Generic:** Việc kiểm tra `if (myList instanceof ArrayList<String>)` là bất hợp pháp. Tại thời điểm chạy, tất cả những gì JVM thấy là `ArrayList`. Nó không có thông tin về phần `<String>` để thực hiện việc kiểm tra. Bạn chỉ có thể kiểm tra với raw type: `if (myList instanceof ArrayList)`.

##### **Bridge Methods**

Đây là một thủ thuật thông minh mà trình biên dịch sử dụng để bảo toàn tính đa hình. Hãy xem xét kịch bản này:

```java
class Node<T> {
    public void setData(T data) { /* ... */ }
}

class MyNode extends Node<Integer> {
    @Override
    public void setData(Integer data) { /* ... */ }
}
```
Sau khi type erasure, lớp `Node` trông như thế này: `class Node { public void setData(Object data) { ... } }`.
Lớp `MyNode` trông như thế này: `class MyNode extends Node { public void setData(Integer data) { ... } }`.

Khoan đã! Chữ ký của method `setData(Object)` và `setData(Integer)` là khác nhau. Điều này có nghĩa là phiên bản `MyNode` là một **nạp chồng (overload)**, không phải là một **ghi đè (override)**. Tính đa hình sẽ bị phá vỡ.

Để khắc phục điều này, trình biên dịch tạo ra một **bridge method** tổng hợp trong `MyNode`:
```java
class MyNode extends Node<Integer> {
    // Method bạn đã viết
    public void setData(Integer data) { /* ... */ }

    // Bridge method do trình biên dịch tạo ra
    public void setData(Object data) {
        // Nó ép kiểu object và gọi method cụ thể của bạn
        setData((Integer) data);
    }
}
```
Bridge method này ghi đè đúng method `setData(Object)` từ lớp cha, và sau đó ủy thác cuộc gọi đến method `setData(Integer)` cụ thể về kiểu của bạn, bảo toàn tính đa hình.

---

#### **2. Ví dụ mã nguồn: Type Erasure đang hoạt động**

Ví dụ này cho thấy rằng tại thời điểm chạy, hai danh sách với các kiểu generic khác nhau có cùng một lớp chính xác.

```java
import java.util.ArrayList;
import java.util.List;

public class TypeErasureDemo {

    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();
        List<Integer> integerList = new ArrayList<>();

        System.out.println("Class of stringList: " + stringList.getClass().getName());
        System.out.println("Class of integerList: " + integerList.getClass().getName());

        // Tại thời điểm chạy, thông tin kiểu bị xóa. Cả hai danh sách chỉ là ArrayList.
        if (stringList.getClass() == integerList.getClass()) {
            System.out.println("True: At runtime, List<String> and List<Integer> are the same class.");
        } else {
            System.out.println("False: They are different classes.");
        }

        // --- Minh họa một hạn chế ---
        // Dòng sau sẽ gây ra lỗi tại thời điểm biên dịch:
        // if (stringList instanceof ArrayList<String>) {
        //     System.out.println("This check is illegal due to type erasure.");
        // }

        // Việc kiểm tra tại thời điểm chạy đúng, nhưng ít cụ thể hơn:
        if (stringList instanceof ArrayList) {
            System.out.println("This 'instanceof' check is legal.");
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một method generic `public static <T> void createArray(T item)`.
2.  Bên trong method này, hãy thử tạo một mảng mới có kiểu `T`: `T[] myArray = new T[10];`.
3.  Quan sát rằng điều này dẫn đến một lỗi tại thời điểm biên dịch ("generic array creation").
4.  Bây giờ, hãy thử tạo một mảng `Object` và ép kiểu nó: `T[] myArray = (T[]) new Object[10];`.
5.  Quan sát cảnh báo "unchecked cast". Điều này minh họa vấn đề ô nhiễm heap (heap pollution) và tại sao việc tạo mảng generic bị cấm. (Chúng ta sẽ đề cập đến ô nhiễm heap chi tiết hơn sau).

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Đoạn mã Java sau sẽ in ra gì?
```java
List<String> list1 = new ArrayList<>();
List<Integer> list2 = new ArrayList<>();
System.out.println(list1.getClass() == list2.getClass());
```

A) `true`
B) `false`
C) Nó sẽ không biên dịch.
D) Nó sẽ ném ra một `ClassCastException` tại thời điểm chạy.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** A) `true`. Do type erasure, thông tin kiểu generic (`<String>` và `<Integer>`) bị trình biên dịch loại bỏ. Tại thời điểm chạy, cả `list1` và `list2` đều chỉ là các instance của lớp `ArrayList`, vì vậy các method `getClass()` của chúng trả về cùng một object `Class`.

### **Bài 4: Enums và Cơ chế nội bộ của chúng**

#### **1. Giải thích khái niệm**

Một **enum** (viết tắt của enumeration) là một kiểu Java đặc biệt cho phép một biến là một tập hợp các hằng số được xác định trước. Việc sử dụng enum làm cho mã dễ đọc hơn, an toàn về kiểu và ít bị lỗi hơn so với việc sử dụng các hằng số số nguyên hoặc hằng số chuỗi.

**Động lực: Vấn đề với các hằng số Static**
Trước khi có enum (trước Java 5), cách phổ biến để biểu diễn một tập hợp các giá trị cố định là "mẫu enum int" hoặc "mẫu enum chuỗi".

```java
// Cách cũ, không an toàn
public class OldCard {
    public static final int SUIT_SPADES = 0;
    public static final int SUIT_HEARTS = 1;
    // ...
    private final int suit;
    public OldCard(int suit) { this.suit = suit; }
}

// Các vấn đề với mẫu này:
// 1. Không an toàn về kiểu: Bạn có thể truyền bất kỳ số nguyên nào vào constructor, ví dụ: new OldCard(99).
// 2. Không có không gian tên: Các hằng số thuộc về lớp Card, không phải là một kiểu "Suit" riêng biệt.
// 3. Tính dễ vỡ: Nếu các giá trị hằng số thay đổi, bạn phải biên dịch lại mã client.
// 4. Không dễ đọc: Việc in một biến suit chỉ in ra một con số (ví dụ: 1), không phải là "HEARTS".
```

##### **Giải pháp `enum`: An toàn về kiểu và mạnh mẽ**
Enums giải quyết tất cả các vấn đề này. Một enum là một kiểu tham chiếu đầy đủ, giống như một lớp.

```java
public enum Suit {
    SPADES, HEARTS, DIAMONDS, CLUBS
}

// Bây giờ mã đã an toàn về kiểu:
Card myCard = new Card(Suit.HEARTS);
// new Card(Suit.SPADES, 99); // LỖI BIÊN DỊCH! Không có constructor như vậy.
```

##### **Cách Enums hoạt động bên trong**
Đây là phần quan trọng nhất cần hiểu. Khi trình biên dịch gặp một khai báo `enum`, nó không chỉ tạo ra các hằng số. Nó tạo ra một **lớp Java đầy đủ** có các thuộc tính sau:

1.  **Ngầm định là `final`:** Bạn không thể tạo một lớp con của một enum.
2.  **Ngầm định kế thừa `java.lang.Enum`:** Mọi enum ngầm định kế thừa từ lớp `java.lang.Enum`, lớp này cung cấp một số method hữu ích.
3.  **Các hằng số Enum là các Instance `public static final`:** Mỗi hằng số bạn khai báo (ví dụ: `HEARTS`) thực ra là một trường `public static final` của chính kiểu enum đó. Mỗi hằng số là một **instance singleton** của lớp enum.

**Những gì trình biên dịch tạo ra (Về mặt khái niệm):**
Khi bạn viết `public enum Suit { SPADES, HEARTS }`, trình biên dịch tạo ra một cái gì đó tương tự về mặt khái niệm như sau:

```java
// Lớp khái niệm được tạo bởi trình biên dịch
public final class Suit extends java.lang.Enum<Suit> {

    // các instance public static final của lớp Suit
    public static final Suit SPADES = new Suit("SPADES", 0);
    public static final Suit HEARTS = new Suit("HEARTS", 1);

    // mảng private để chứa tất cả các instance cho values()
    private static final Suit[] $VALUES = { SPADES, HEARTS };

    // constructor private để ngăn chặn việc khởi tạo từ bên ngoài
    private Suit(String name, int ordinal) {
        super(name, ordinal);
    }

    // method public static để lấy tất cả các giá trị
    public static Suit[] values() {
        return $VALUES.clone();
    }

    // method public static để lấy một instance theo tên
    public static Suit valueOf(String name) {
        return Enum.valueOf(Suit.class, name);
    }
}
```

##### **Constructors, Fields, và Methods của Enum**
Bởi vì một enum là một lớp, nó có thể có tất cả các tính năng của một lớp:
*   **Constructors:** Constructor của Enum phải là `private` (hoặc package-private). Chúng được gọi một lần cho mỗi hằng số enum tại thời điểm lớp được tải. Bạn không thể tự mình gọi một constructor của enum.
*   **Instance Fields:** Bạn có thể thêm các trường để lưu trữ dữ liệu liên quan đến mỗi hằng số. Các trường này thường là `private` và `final`.
*   **Methods:** Bạn có thể thêm các method để cung cấp hành vi cho mỗi hằng số.

##### **Các Method cốt lõi được cung cấp bởi `java.lang.Enum`**
*   **`name()`:** Trả về tên của hằng số enum, chính xác như nó được khai báo trong mã của bạn (ví dụ: "HEARTS").
*   **`ordinal()`:** Trả về vị trí dựa trên 0 của hằng số trong thứ tự khai báo của nó (ví dụ: `SPADES.ordinal()` là 0, `HEARTS.ordinal()` là 1). **Thực hành tốt nhất:** Tránh sử dụng `ordinal()` cho logic nghiệp vụ, vì nó rất dễ vỡ. Nếu bạn sắp xếp lại các hằng số, các giá trị ordinal sẽ thay đổi, làm hỏng mã của bạn. Hãy sử dụng một trường instance thay thế nếu bạn cần liên kết một giá trị với một hằng số.
*   **`values()`:** Một method static được trình biên dịch thêm vào, trả về một mảng chứa tất cả các hằng số enum theo thứ tự khai báo của chúng.
*   **`valueOf(String name)`:** Một method static được trình biên dịch thêm vào, trả về hằng số enum có tên được chỉ định. Ném ra `IllegalArgumentException` nếu hằng số không tồn tại.

---

#### **2. Ví dụ mã nguồn: Enum với Fields và Methods**

Ví dụ này cho thấy một enum `Planet` với dữ liệu (khối lượng, bán kính) và hành vi (tính toán trọng lực bề mặt).

```java
public enum Planet {
    // Các hằng số Enum có thể gọi một constructor
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6),
    EARTH(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);

    // Các trường instance cho mỗi hằng số
    private final double mass;   // tính bằng kilogam
    private final double radius; // tính bằng mét
    public static final double G = 6.67300E-11; // Hằng số hấp dẫn vũ trụ

    // Constructor (phải là private)
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    // Method public để cung cấp hành vi
    public double surfaceGravity() {
        return G * mass / (radius * radius);
    }

    public double getMass() { return mass; }
    public double getRadius() { return radius; }
}

class EnumDemo {
    public static void main(String[] args) {
        Planet earth = Planet.EARTH;
        System.out.printf("Surface gravity on %s is %.2f m/s^2\n",
                          earth.name(), earth.surfaceGravity());

        // Sử dụng method values() do trình biên dịch tạo ra
        System.out.println("\nAll planets in order of declaration (ordinal):");
        for (Planet p : Planet.values()) {
            System.out.printf("- %s (ordinal %d)\n", p.name(), p.ordinal());
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một enum có tên `Tier` với ba hằng số: `BRONZE`, `SILVER`, và `GOLD`.
2.  Thêm một trường `private final int minPoints` vào enum.
3.  Tạo một constructor private chấp nhận một số nguyên cho số điểm tối thiểu.
4.  Liên kết các điểm sau với các bậc: `BRONZE(0)`, `SILVER(1000)`, `GOLD(5000)`.
5.  Tạo một method `public static Tier forPoints(int points)` lặp qua `Tier.values()` và trả về bậc cao nhất mà một người dùng đủ điều kiện dựa trên điểm của họ. Ví dụ, nếu một người dùng có 2500 điểm, nó nên trả về `SILVER`.
6.  Kiểm tra method `forPoints` của bạn trong `main`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào sau đây về enum trong Java là **sai**?

A) Một enum có thể triển khai một interface.
B) Bạn có thể tạo một instance mới của một enum bằng cách sử dụng từ khóa `new` (ví dụ: `new Planet()`).
C) Constructor của một enum phải là `private` hoặc package-private.
D) Mỗi hằng số enum là một instance `public static final` của kiểu enum.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Bạn có thể tạo một instance mới của một enum bằng cách sử dụng từ khóa `new` (ví dụ: `new Planet()`). Điều này là sai. Trình biên dịch chịu trách nhiệm duy nhất trong việc tạo ra các instance của các hằng số enum. Constructor ngầm định là private để ngăn chặn bất kỳ việc khởi tạo nào từ bên ngoài, đảm bảo rằng chỉ có tập hợp các instance được xác định trước tồn tại.

### **Bài 5: `EnumMap`, `EnumSet`, và Cách sử dụng Enum nâng cao**

#### **1. Giải thích khái niệm**

Bởi vì enum là một kiểu đặc biệt được trình biên dịch biết đến, Java Collections Framework cung cấp hai triển khai được tối ưu hóa cao, `EnumSet` và `EnumMap`, hiệu quả hơn đáng kể so với các đối tác đa năng của chúng (`HashSet` và `HashMap`).

##### **`EnumSet` - `Set` hiệu suất cao cho Enums**

*   **Cấu trúc nội bộ:** Một `EnumSet` **không** được hỗ trợ bởi một bảng băm. Bên trong, nó thường được biểu diễn dưới dạng một **vector bitwise**, thường là một `long` duy nhất (hoặc một mảng `long` cho các enum có hơn 64 hằng số).
*   **Cách hoạt động:** Mỗi bit trong `long` tương ứng với `ordinal()` của một hằng số enum. Nếu một hằng số có trong tập hợp, bit tương ứng của nó được đặt thành `1`; nếu không, nó là `0`.
    **Ví dụ tương tự:** Nếu `Tier` là `BRONZE(0), SILVER(1), GOLD(2)`, một tập hợp chứa `BRONZE` và `GOLD` sẽ được biểu diễn bằng giá trị nhị phân `...0101`, trong đó các bit thứ 0 và thứ 2 được bật.
*   **Hiệu suất:** Tất cả các hoạt động cơ bản của nó (`add`, `contains`, `remove`) được thực hiện trong **thời gian không đổi O(1)** và cực kỳ nhanh. Điều này là do chúng là các phép toán số học bitwise đơn giản, nhanh hơn nhiều so với việc tính toán mã băm và xử lý các bucket mảng.
*   **Tạo:** Bạn không thể tạo một `EnumSet` bằng `new`. Bạn phải sử dụng một trong các phương thức factory tĩnh của nó, chẳng hạn như:
    *   `EnumSet.of(E... elements)`: Tạo một tập hợp với các phần tử được chỉ định.
    *   `EnumSet.allOf(Class<E> elementType)`: Tạo một tập hợp chứa tất cả các hằng số của enum.
    *   `EnumSet.noneOf(Class<E> elementType)`: Tạo một tập hợp rỗng cho kiểu enum được chỉ định.
    *   `EnumSet.range(E from, E to)`: Tạo một tập hợp chứa tất cả các hằng số trong phạm vi từ `from` đến `to`, bao gồm cả hai.
*   **Thứ tự:** Iterator cho một `EnumSet` luôn trả về các phần tử theo **thứ tự tự nhiên** của chúng (thứ tự chúng được khai báo trong enum).

##### **`EnumMap` - `Map` hiệu suất cao cho các khóa Enum**

*   **Cấu trúc nội bộ:** Một `EnumMap` **không** được hỗ trợ bởi một bảng băm. Bên trong, nó được biểu diễn dưới dạng một **mảng đơn giản**.
*   **Cách hoạt động:** `ordinal()` của khóa được sử dụng làm chỉ số trực tiếp vào mảng nội bộ. Giá trị được lưu trữ tại `array[key.ordinal()]`.
*   **Hiệu suất:** Bởi vì nó sử dụng chỉ số mảng trực tiếp thay vì băm, tất cả các hoạt động cơ bản (`put`, `get`, `containsKey`) được thực hiện trong **thời gian không đổi O(1)** và nhanh hơn và dễ dự đoán hơn nhiều so với `HashMap`.
*   **Tạo:** Bạn phải cung cấp đối tượng `Class` của enum cho constructor để nó biết kích thước của mảng cần tạo. `Map<MyEnum, String> map = new EnumMap<>(MyEnum.class);`
*   **Thứ tự:** Các collection view của map (`keySet()`, `entrySet()`, `values()`) lặp qua các phần tử theo **thứ tự tự nhiên** của các khóa enum.

##### **Triển khai Interfaces và Abstract Methods**
Enum có thể cung cấp hành vi khác nhau cho mỗi hằng số. Điều này có thể đạt được theo hai cách chính:

1.  **Câu lệnh Switch trong một Method:** Một cách đơn giản là có một method trong enum chuyển đổi trên `this`. Điều này sạch sẽ cho logic đơn giản nhưng có thể vi phạm Nguyên tắc Đóng/Mở nếu bạn thường xuyên thêm các hằng số mới.

2.  **Triển khai Method cụ thể cho hằng số:** Một cách tiếp cận mạnh mẽ và hướng đối tượng hơn là khai báo một method `abstract` trong enum và để mỗi hằng số cung cấp triển khai cụ thể của riêng nó. Điều này buộc mọi hằng số phải định nghĩa hành vi của nó.

---

#### **2. Ví dụ mã nguồn: `EnumMap` và các Method cụ thể cho hằng số**

Ví dụ này minh họa việc sử dụng một `EnumMap` để theo dõi các giai đoạn của một dự án và một enum `Operation` nơi mỗi hằng số triển khai method `apply` của riêng nó.

```java
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;

// 1. Enum cho EnumSet và EnumMap
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

// 2. Enum với triển khai method cụ thể cho hằng số
enum Operation {
    PLUS {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE {
        public double apply(double x, double y) { return x / y; }
    };

    // Abstract method mà mỗi hằng số PHẢI triển khai
    public abstract double apply(double x, double y);
}


public class AdvancedEnumDemo {
    public static void main(String[] args) {
        // --- Demo EnumSet ---
        // Một tập hợp nhỏ gọn và hiệu quả của các ngày cuối tuần
        EnumSet<Day> weekend = EnumSet.of(Day.SATURDAY, Day.SUNDAY);
        System.out.println("Weekend days: " + weekend);
        System.out.println("Does the weekend include MONDAY? " + weekend.contains(Day.MONDAY)); // false

        // --- Demo EnumMap ---
        // Một map hiệu suất cao từ Ngày đến lịch trình công việc
        Map<Day, String> schedule = new EnumMap<>(Day.class);
        schedule.put(Day.MONDAY, "Team Meeting");
        schedule.put(Day.FRIDAY, "Code Freeze");
        schedule.put(Day.WEDNESDAY, "Deployment");
        System.out.println("\nSchedule for WEDNESDAY: " + schedule.get(Day.WEDNESDAY));

        // --- Demo Method cụ thể cho hằng số ---
        double x = 4.0;
        double y = 2.0;
        System.out.println("\n--- Operations ---");
        for (Operation op : Operation.values()) {
            System.out.printf("%.1f %s %.1f = %.1f\n", x, op, y, op.apply(x, y));
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn đang mô hình hóa một hệ thống đèn giao thông.
1.  Tạo một `enum` có tên `TrafficLight`.
2.  Các hằng số nên là `RED`, `AMBER`, và `GREEN`.
3.  Mỗi hằng số cần biết `duration` (tính bằng giây) mà nó nên sáng. `RED(30)`, `AMBER(5)`, `GREEN(45)`. Thêm một trường và một constructor cho việc này.
4.  Thêm một method `abstract` vào enum có tên `next()`.
5.  Triển khai method `next()` cho mỗi hằng số để trả về đèn tiếp theo trong chuỗi (ví dụ: `GREEN.next()` trả về `AMBER`, `AMBER.next()` trả về `RED`, và `RED.next()` trả về `GREEN`).
6.  Trong `main`, bắt đầu với `GREEN`, sau đó lặp 10 lần, in ra tên và thời lượng của đèn hiện tại, và sau đó chuyển sang đèn `next()`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Tại sao một `EnumMap` thường nhanh hơn một `HashMap` khi sử dụng một enum làm khóa?

A) `EnumMap` luôn được đồng bộ hóa, điều này cải thiện hiệu suất.
B) `EnumMap` sử dụng một cây nhị phân cân bằng, nhanh hơn so với băm.
C) `EnumMap` sử dụng giá trị `ordinal()` của enum làm chỉ số trực tiếp vào một mảng, tránh được chi phí tính toán `hashCode()` và xử lý xung đột.
D) `EnumMap` sử dụng một thuật toán băm hiệu quả hơn được thiết kế đặc biệt cho các enum.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `EnumMap` sử dụng giá trị `ordinal()` của enum làm chỉ số trực tiếp vào một mảng, tránh được chi phí tính toán `hashCode()` và xử lý xung đột. Việc truy cập mảng trực tiếp này là một hoạt động O(1) đơn giản, nhanh hơn và hiệu quả về bộ nhớ hơn đáng kể so với quá trình băm, tính toán chỉ số và giải quyết xung đột tiềm năng phức tạp hơn được sử dụng bởi `HashMap`.

### **Bài 6: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Bài học cuối cùng này củng cố sự tìm hiểu sâu của chúng ta về Java Generics và Enums. Chúng ta sẽ tóm tắt các khái niệm chính, xem lại các câu hỏi phỏng vấn phổ biến, và áp dụng mọi thứ trong một dự án nhỏ thực tế kết hợp cả hai tính năng.

---

#### **1. Bảng tóm tắt các điểm chính**

| Khái niệm | Điểm chính & Cú pháp |
| :--- | :--- |
| **Generics** | Cung cấp an toàn kiểu tại thời điểm biên dịch và tái sử dụng mã. Loại bỏ sự cần thiết của việc ép kiểu tường minh. |
| **Lớp/Interface Generic** | `class MyClass<T> { ... }` |
| **Method Generic** | `<T> T myMethod(T arg) { ... }` |
| **Tham số kiểu có giới hạn** | `class MyClass<T extends Number> { ... }` (Hạn chế `T` là `Number` hoặc các subtype của nó). |
| **Nhiều giới hạn** | `<T extends ClassA & InterfaceB & InterfaceC>` |
| **Wildcard: Giới hạn trên** | `void process(List<? extends Number> list)` - **Producer Extends**: Truy cập chỉ đọc. |
| **Wildcard: Giới hạn dưới** | `void addInts(List<? super Integer> list)` - **Consumer Super**: Truy cập chỉ ghi cho các `Integer`. |
| **Wildcard: Không giới hạn** | `void printSize(List<?> list)` - Cho các hoạt động không phụ thuộc vào kiểu. |
| **Type Erasure** | Generics là một tính năng tại thời điểm biên dịch. Thông tin kiểu bị xóa tại thời điểm chạy. `List<String>` trở thành `List`. Dẫn đến các hạn chế như `new T()` và `instanceof T` là bất hợp pháp. |
| **Enums** | Một lớp đặc biệt đại diện cho một tập hợp các hằng số cố định. Cung cấp an toàn kiểu so với các hằng số `int` hoặc `String` tĩnh. |
| **Khai báo Enum** | `public enum Status { PENDING, ACTIVE, INACTIVE }` |
| **Nội bộ Enum** | Mỗi hằng số là một instance singleton `public static final` của lớp enum, lớp này ngầm kế thừa `java.lang.Enum`. |
| **Enums với Trạng thái/Hành vi**| Enums có thể có các constructor `private`, các trường `final`, và các method. Mỗi hằng số thậm chí có thể ghi đè một method `abstract` cho hành vi cụ thể. |
| **`EnumSet` & `EnumMap`** | Các triển khai `Set` và `Map` được tối ưu hóa cao cho các kiểu enum. Sử dụng các vector bitwise (`EnumSet`) và các mảng (`EnumMap`) thay vì băm, cung cấp hiệu suất O(1) vượt trội. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Type erasure là gì và tại sao nó tồn tại trong Java?"**
    *   *Trả lời:* Type erasure là quá trình trong đó trình biên dịch loại bỏ thông tin kiểu generic tại thời điểm biên dịch, thay thế các tham số kiểu bằng các giới hạn của chúng hoặc bằng `Object`. Tại thời điểm chạy, JVM chỉ thấy các raw type. Điều này được thực hiện để đảm bảo khả năng tương thích ngược, cho phép mã generic mới tương tác với mã và thư viện kế thừa cũ, không generic.

2.  **"Giải thích nguyên tắc PECS (Producer Extends, Consumer Super). Cho một ví dụ."**
    *   *Trả lời:* PECS là một câu ghi nhớ để sử dụng các ký tự đại diện trong các API generic. "Producer Extends" có nghĩa là nếu một collection generic là một *producer* mà từ đó bạn chỉ đọc các mục, hãy sử dụng `? extends T`. Ví dụ: danh sách nguồn của một method `copy`. "Consumer Super" có nghĩa là nếu một collection là một *consumer* mà bạn chỉ ghi các mục vào, hãy sử dụng `? super T`. Ví dụ: danh sách đích của method `copy`. Điều này làm cho API linh hoạt hơn. Một method `copy(List<? extends Number> src, List<? super Number> dest)` có thể sao chép một `List<Integer>` vào một `List<Object>`.

3.  **"Bạn có thể tạo một mảng generic như `new T[10]` không? Tại sao có hoặc tại sao không?"**
    *   *Trả lời:* Không, bạn không thể. Đây là một hạn chế gây ra bởi type erasure. Các mảng trong Java là reifiable, có nghĩa là chúng biết kiểu thành phần của chúng tại thời điểm chạy để thực thi an toàn lưu trữ mảng. Nếu bạn có thể tạo `new T[10]`, `T` sẽ bị xóa thành `Object` tại thời điểm chạy, tạo ra một `Object[]`. Nếu mảng này sau đó được gán cho một tham chiếu `String[]`, bạn có thể thêm một `Integer` vào nó mà không có `ArrayStoreException`, phá vỡ hệ thống kiểu.

4.  **"Mô tả cách một `EnumMap` hoạt động bên trong và tại sao nó hiệu quả hơn một `HashMap` đối với các khóa enum."**
    *   *Trả lời:* Một `EnumMap` được hỗ trợ bởi một mảng đơn giản, không phải là một bảng băm. Nó sử dụng `ordinal()` của khóa enum làm chỉ số trực tiếp vào mảng này. Điều này tránh được toàn bộ chi phí tính toán mã băm, xử lý xung đột băm, và thay đổi kích thước một bảng băm. Kết quả là một hiệu suất O(1) được đảm bảo, có thể dự đoán được cho tất cả các hoạt động cơ bản, nhanh hơn và hiệu quả về bộ nhớ hơn đáng kể so với `HashMap`.

5.  **"Làm thế nào bạn có thể làm cho mỗi hằng số enum có một hành vi khác nhau cho một method?"**
    *   *Trả lời:* Cách mạnh mẽ và hướng đối tượng nhất là khai báo một method `abstract` trong enum, và sau đó cung cấp một triển khai cụ thể cho method đó trong phần thân của mỗi hằng số enum riêng lẻ. Điều này buộc mọi hằng số phải định nghĩa hành vi và tránh các câu lệnh `switch` lộn xộn, tuân thủ Nguyên tắc Đóng/Mở.

---

#### **3. Dự án nhỏ cuối cùng: Một Registry Command an toàn về kiểu**

Dự án này kết hợp generics và enums để tạo ra một hệ thống linh hoạt, an toàn về kiểu để đăng ký và thực thi các loại command khác nhau.

**🎯 Mục tiêu:** Xây dựng một `CommandRegistry` có thể lưu trữ và truy xuất các trình xử lý command dựa trên một khóa enum, nơi mỗi trình xử lý chịu trách nhiệm cho một loại object command cụ thể.

**Yêu cầu dự án:**

1.  **Interface `Command` (Generic):**
    *   Tạo một interface đánh dấu generic, đơn giản: `interface Command<R> { }`. `R` sẽ đại diện cho kiểu trả về của command.

2.  **Các lớp Command cụ thể:**
    *   Tạo hai lớp command đơn giản triển khai interface `Command`:
        *   `CreateUserCommand implements Command<UUID>`: Nên chứa các trường như `username` và `password`.
        *   `GetUserCommand implements Command<User>`: Nên chứa một trường `userId`.
    *   (Bạn có thể tạo các lớp giả `User` và `UUID` hoặc sử dụng `java.util.UUID`).

3.  **Interface `CommandHandler` (Generic):**
    *   Tạo một interface generic: `interface CommandHandler<C extends Command<R>, R>`.
    *   Nó nên có một method: `R handle(C command)`. Trình xử lý này nhận một loại command cụ thể và trả về một loại kết quả cụ thể.

4.  **Enum `CommandType`:**
    *   Tạo một enum `CommandType` với các hằng số cho mỗi command: `CREATE_USER`, `GET_USER`.
    *   Enum này sẽ hoạt động như khóa trong registry của chúng ta.

5.  **Lớp `CommandRegistry` (Cốt lõi của dự án):**
    *   Lớp này sẽ giữ ánh xạ từ một `CommandType` đến `CommandHandler` tương ứng của nó.
    *   Bộ nhớ trong nên là một `Map`. Vì khóa là một enum, triển khai `Map` tối ưu nhất là gì? **`EnumMap`**.
    *   Registry sẽ cần hai method:
        *   `register(CommandType type, CommandHandler<?, ?> handler)`: Method này sẽ đăng ký một trình xử lý cho một loại command đã cho.
        *   `<R, C extends Command<R>> R execute(C command)`: Đây là phần phức tạp nhất. Method generic này sẽ:
            *   Đầu tiên, xác định `CommandType` dựa trên lớp của object `command` được truyền vào.
            *   Sau đó, tra cứu trình xử lý chính xác trong `EnumMap`.
            *   Cuối cùng, thực thi trình xử lý với command và trả về kết quả. Điều này sẽ yêu cầu một số ép kiểu, cần được xử lý cẩn thận (đây là một mẫu phổ biến trong loại hệ thống điều phối này).

**Ví dụ sử dụng:**

```java
public static void main(String[] args) {
    CommandRegistry registry = new CommandRegistry();

    // Đăng ký các trình xử lý (sử dụng lambda cho đơn giản)
    registry.register(CommandType.CREATE_USER, (CreateUserCommand cmd) -> {
        System.out.println("Creating user: " + cmd.getUsername());
        return UUID.randomUUID();
    });

    registry.register(CommandType.GET_USER, (GetUserCommand cmd) -> {
        System.out.println("Getting user: " + cmd.getUserId());
        return new User(cmd.getUserId(), "Mock User");
    });

    // Thực thi các command một cách an toàn về kiểu
    CreateUserCommand createUser = new CreateUserCommand("alice", "password123");
    UUID newUserId = registry.execute(createUser);
    System.out.println("New user ID: " + newUserId);

    GetUserCommand getUser = new GetUserCommand(newUserId);
    User user = registry.execute(getUser);
    System.out.println("Fetched user: " + user.getName());
}
```

Dự án này sẽ buộc bạn phải vật lộn với các method generic, các ký tự đại diện (trong map của method `register`), các enum làm khóa, và cách kết hợp tất cả chúng lại với nhau thành một thiết kế thực tế, an toàn về kiểu.