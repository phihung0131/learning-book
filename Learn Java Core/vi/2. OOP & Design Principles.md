### **Bài 1: Hiểu về Abstraction trong Java**

#### **1. Giải thích khái niệm**

**Abstraction** (tính trừu tượng) là nguyên tắc ẩn đi các chi tiết triển khai phức tạp và chỉ hiển thị các tính năng thiết yếu của một object. Nó tập trung vào **"cái gì"** một object làm thay vì **"làm thế nào"** nó thực hiện điều đó. Điều này giúp giảm độ phức tạp và cô lập tác động của các thay đổi.

**Ví dụ tương tự:** Hãy nghĩ về bảng điều khiển của một chiếc ô tô. Nó cung cấp một giao diện đơn giản (vô lăng, bàn đạp, đồng hồ tốc độ) để điều khiển một cỗ máy rất phức tạp. Bạn không cần phải biết động cơ, hộp số hay quá trình đốt cháy hoạt động như thế nào để lái xe. Sự phức tạp đã được trừu tượng hóa.

Trong Java, abstraction chủ yếu được thực hiện thông qua hai cơ chế: **Abstract Classes** và **Interfaces**.

##### **Abstract Classes**

Một abstract class là một bản thiết kế cho các class khác. Nó có thể có sự kết hợp của các method có triển khai (method cụ thể) và các method không có triển khai (abstract method).

*   **Từ khóa:** Được khai báo với từ khóa `abstract`.
*   **Khởi tạo:** Nó **không thể** được khởi tạo trực tiếp bằng từ khóa `new`.
*   **Nội dung:** Có thể chứa các method `abstract`, method cụ thể, constructor, biến instance, method `static`, và method `final`.
*   **Mục đích:** Cung cấp một nền tảng chung với trạng thái được chia sẻ (biến instance) và/hoặc hành vi được chia sẻ (method cụ thể) cho một nhóm các subclass có liên quan. Các subclass kế thừa một abstract class phải cung cấp triển khai cho tất cả các abstract method của nó.

##### **Interfaces**

Một interface là một "hợp đồng" thuần túy hoặc một đặc tả về hành vi. Nó định nghĩa một tập hợp các method mà một class phải triển khai.

*   **Từ khóa:** Được khai báo với từ khóa `interface`.
*   **Khởi tạo:** Nó không thể được khởi tạo trực tiếp.
*   **Nội dung (Trước Java 8):** Chỉ có thể chứa các method `public abstract` và các hằng số `public static final`.
*   **Nội dung (Java 8+):** Bây giờ có thể chứa các `default` method (method có triển khai mặc định) và `static` method, cho phép linh hoạt hơn và tương thích ngược.
*   **Mục đích:** Định nghĩa một khả năng hoặc vai trò mà các class không liên quan có thể áp dụng. Một class có thể `implement` nhiều interface, cho phép nó đảm nhận các vai trò khác nhau.

##### **Khi nào nên dùng cái nào: Một quyết định quan trọng**

| Tính năng | Abstract Class | Interface |
| :--- | :--- | :--- |
| **Mối quan hệ** | Định nghĩa mối quan hệ **"is-a"** (là một). (ví dụ: một `Dog` là một `Animal`). | Định nghĩa mối quan hệ **"can-do"** (có thể làm). (ví dụ: một `Bird` và một `Plane` đều có thể là `Flyable`). |
| **Đa kế thừa** | Một class chỉ có thể `extend` **một** abstract class. | Một class có thể `implement` **nhiều** interface. |
| **Trạng thái (Biến)** | Có thể có các biến instance (không-final, không-static). | Các biến ngầm định là `public static final` (hằng số). |
| **Constructors** | Có thể có constructor (được gọi bởi các subclass thông qua `super()`). | Không thể có constructor. |
| **Triển khai** | Có thể chứa sự kết hợp của các method abstract và cụ thể. | Chủ yếu để định nghĩa một hợp đồng. Có thể có các triển khai `default` từ Java 8. |
| **Trường hợp sử dụng** | Sử dụng khi bạn muốn chia sẻ code và trạng thái giữa các class có liên quan chặt chẽ. | Sử dụng khi bạn muốn định nghĩa một hợp đồng cho hành vi có thể được triển khai bởi các class không liên quan. |

---

#### **2. Ví dụ mã nguồn**

Ví dụ này cho thấy một abstract class `Vehicle` chia sẻ trạng thái (`brand`) và hành vi (`getBrand()`) và một interface `Alertable` định nghĩa một khả năng.

```java
// Interface: Một hợp đồng "can-do"
interface Alertable {
    void triggerAlarm(); // Mặc định là public abstract
}

// Abstract Class: Một bản thiết kế mối quan hệ "is-a"
abstract class Vehicle {
    private String brand; // Trạng thái được chia sẻ

    // Constructor để khởi tạo trạng thái
    public Vehicle(String brand) {
        this.brand = brand;
    }

    // Method cụ thể với triển khai được chia sẻ
    public String getBrand() {
        return brand;
    }

    // Abstract method: Phải được triển khai bởi các subclass
    public abstract void startEngine();
}

// Class cụ thể kế thừa một class và triển khai một interface
class Car extends Vehicle implements Alertable {
    public Car(String brand) {
        super(brand); // Gọi constructor của lớp cha
    }

    @Override
    public void startEngine() {
        System.out.println("The " + getBrand() + " car's engine is starting...");
    }

    @Override
    public void triggerAlarm() {
        System.out.println("The " + getBrand() + " car alarm is blaring: Honk! Honk!");
    }
}

public class AbstractionDemo {
    public static void main(String[] args) {
        // Vehicle myVehicle = new Vehicle("Ford"); // LỖI BIÊN DỊCH: Không thể khởi tạo một abstract class.

        Car myCar = new Car("Toyota");
        myCar.startEngine();
        myCar.triggerAlarm();
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một abstract class có tên `AudioPlayer`.
2.  Nó nên có một biến instance cho `volumeLevel` (một `int`) và một method cụ thể `displayVolume()` in ra âm lượng hiện tại.
3.  Thêm hai abstract method: `play()` và `stop()`.
4.  Tạo hai subclass cụ thể, `MP3Player` và `CDPlayer`, kế thừa từ `AudioPlayer`.
5.  Triển khai các method `play()` và `stop()` trong mỗi subclass với một câu lệnh in đơn giản (ví dụ: "MP3 is playing" hoặc "CD stopped").
6.  Trong một method main, tạo các instance của cả `MP3Player` và `CDPlayer` và kiểm tra các method của chúng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Đâu là lý do chính để chọn một interface thay vì một abstract class trong Java?

A) Để cung cấp một triển khai cơ sở cho một số method trong khi để lại các method khác là abstract.
B) Để cho phép một class kế thừa hành vi từ nhiều nguồn.
C) Để chia sẻ các biến instance qua một hệ thống phân cấp class.
D) Bởi vì một interface có thể có một constructor.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Để cho phép một class kế thừa hành vi từ nhiều nguồn. Java không hỗ trợ đa kế thừa của các class (một class chỉ có thể `extend` một lớp cha), nhưng một class có thể `implement` nhiều interface, làm cho interface trở thành giải pháp để kế thừa nhiều hợp đồng hành vi.

### **Bài 2: Encapsulation chuyên sâu**

#### **1. Giải thích khái niệm**

**Encapsulation** (tính đóng gói) là thực hành gộp dữ liệu của một object (các biến instance) và các method hoạt động trên dữ liệu đó vào một đơn vị duy nhất, khép kín: một class. Nó bao gồm việc hạn chế truy cập trực tiếp vào một số thành phần của một object, đây là một phần quan trọng của **data hiding** (che giấu dữ liệu).

Mục tiêu chính của encapsulation là để ngăn chặn mã bên ngoài thay đổi trạng thái nội bộ của một object một cách tùy tiện. Thay vào đó, quyền truy cập được cung cấp thông qua một giao diện công khai được kiểm soát (các method).

**Ví dụ tương tự:** Hãy xem xét một tài khoản ngân hàng. Số dư tài khoản của bạn là dữ liệu riêng tư. Bạn không thể tự mình truy cập vào cơ sở dữ liệu của ngân hàng và thay đổi con số đó. Thay vào đó, bạn tương tác thông qua một giao diện được xác định rõ ràng: các method `deposit()` và `withdraw()`. Các method này chứa logic (ví dụ: kiểm tra xem có đủ tiền không) để bảo vệ tính toàn vẹn của dữ liệu của bạn. Class là ngân hàng, dữ liệu là số dư của bạn, và các method là các giao dịch viên hoặc chức năng ATM.

**Lợi ích cốt lõi:**
*   **Kiểm soát & Bảo mật:** Class duy trì toàn quyền kiểm soát trạng thái của nó. Bạn có thể thực thi các quy tắc xác thực (ví dụ: tuổi không thể là số âm).
*   **Linh hoạt & Dễ bảo trì:** Bạn có thể thay đổi triển khai nội bộ của một class (ví dụ: thay đổi kiểu dữ liệu từ `ArrayList` sang `LinkedList`) mà không làm hỏng bất kỳ mã bên ngoài nào sử dụng nó, miễn là chữ ký của các method công khai vẫn giữ nguyên.
*   **Che giấu dữ liệu:** Ẩn đi sự phức tạp bên trong khỏi thế giới bên ngoài, làm cho class dễ sử dụng hơn.

#### **2. Các công cụ của Encapsulation: Access Modifiers**

Java sử dụng các access modifier để xác định mức độ hiển thị cho các class, field, và method.

| Modifier | Cùng Class | Cùng Package | Subclass (khác package) | Toàn cục (bất kỳ package) |
| :--- | :--- | :--- | :--- | :--- |
| **`public`** | Có | Có | Có | Có |
| **`protected`** | Có | Có | Có | Không |
| **`default` (package-private)** | Có | Có | Không | Không |
| **`private`** | Có | Không | Không | Không |

*   **`private`**: Mức độ nghiêm ngặt nhất. Thành viên chỉ có thể truy cập từ bên trong cùng một class. Đây là **thực hành tốt nhất** cho tất cả các biến instance.
*   **`default` (không có từ khóa)**: Còn được gọi là package-private. Thành viên có thể truy cập bởi bất kỳ class nào trong cùng một package.
*   **`protected`**: Giống như `default`, nhưng cũng có thể truy cập bởi các subclass, ngay cả khi chúng ở trong các package khác nhau.
*   **`public`**: Mức độ linh hoạt nhất. Thành viên có thể truy cập từ bất cứ đâu. Thường được sử dụng cho giao diện công khai của class (constructor và method).

---

#### **3. Truy cập được kiểm soát thông qua Getters và Setters**

Cơ chế tiêu chuẩn để cung cấp quyền truy cập được kiểm soát vào các field private là thông qua các method công khai được gọi là getters và setters (hoặc accessors và mutators).

*   **Getter (Accessor):** Một method lấy giá trị của một field private. Theo quy ước, nó được đặt tên là `getFieldName()` (hoặc `isFieldName()` cho boolean).
*   **Setter (Mutator):** Một method sửa đổi giá trị của một field private. Theo quy ước, nó được đặt tên là `setFieldName()`. Đây là nơi bạn đặt logic xác thực.

Bằng cách chỉ cung cấp một getter, bạn tạo ra một thuộc tính **chỉ đọc (read-only)**. Bằng cách không cung cấp một setter công khai, bạn ngăn chặn việc sửa đổi trực tiếp một field, buộc các thay đổi phải xảy ra thông qua các method nghiệp vụ khác (như `deposit()` trong ví dụ tài khoản ngân hàng).

---

#### **4. Ví dụ mã nguồn**

Class `Person` này đóng gói dữ liệu của nó một cách đúng đắn. `age` không thể được đặt thành một giá trị âm.

```java
public class Person {
    // 1. Dữ liệu được giữ private
    private String name;
    private int age;
    private final String socialSecurityNumber; // Chỉ đọc sau khi khởi tạo

    public Person(String name, int age, String ssn) {
        this.name = name;
        this.socialSecurityNumber = ssn;
        // Sử dụng setter trong quá trình khởi tạo để áp dụng xác thực
        setAge(age);
    }

    // 2. Các getter công khai cung cấp quyền đọc
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getSocialSecurityNumber() {
        return socialSecurityNumber;
    }

    // 3. Các setter công khai cung cấp quyền ghi được kiểm soát
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        }
    }

    public void setAge(int age) {
        // Logic xác thực bảo vệ trạng thái của object
        if (age > 0 && age < 130) {
            this.age = age;
        } else {
            System.out.println("Invalid age provided. Age not set.");
        }
    }
}

class EncapsulationDemo {
    public static void main(String[] args) {
        Person person1 = new Person("Alice", 30, "123-45-678");

        // Truy cập trực tiếp là LỖI BIÊN DỊCH
        // person1.age = -5;

        // Sửa đổi trạng thái thông qua giao diện công khai được kiểm soát
        System.out.println("Initial age: " + person1.getAge()); // 30
        person1.setAge(-5); // In ra "Invalid age provided."
        System.out.println("Age after invalid attempt: " + person1.getAge()); // Vẫn là 30
        person1.setAge(31);
        System.out.println("Age after valid attempt: " + person1.getAge()); // 31
    }
}
```

---

#### **5. Bài tập nhỏ**

1.  Tạo một class có tên `SmartThermostat`.
2.  Nó nên có hai biến instance `private`: `temperature` (double) và `isHeating` (boolean).
3.  Tạo một constructor khởi tạo `temperature`. Trạng thái `isHeating` nên phụ thuộc vào nhiệt độ ban đầu (ví dụ: `isHeating` là true nếu nhiệt độ dưới 20.0).
4.  Cung cấp một getter công khai `getTemperature()`.
5.  Thay vì một setter chung, hãy tạo một method `setTargetTemperature(double targetTemp)`. Method này nên:
    *   Đặt `temperature` thành `targetTemp`.
    *   Cập nhật trạng thái `isHeating` dựa trên nhiệt độ mới.
    *   In ra một thông báo như "Heating is now ON." hoặc "Heating is now OFF."
6.  Cung cấp một getter chỉ đọc `isHeating()` cho trường boolean.

---

#### **6. Câu hỏi trắc nghiệm**

**Câu hỏi:** Một biến instance được khai báo là `protected`. Ai có thể truy cập nó?

A) Chỉ class mà nó được khai báo.
B) Bất kỳ class nào trong cùng một package.
C) Bất kỳ subclass nào, bất kể package, và bất kỳ class nào trong cùng một package.
D) Bất kỳ class nào từ bất kỳ package nào.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Bất kỳ subclass nào, bất kể package, và bất kỳ class nào trong cùng một package. Đây là định nghĩa của quyền truy cập `protected`.

### **Bài 3: Inheritance và Polymorphism**

#### **1. Giải thích khái niệm**

##### **Inheritance (Tính kế thừa)**
Inheritance là một cơ chế trong đó một class mới (subclass hoặc child class) có được các thuộc tính (field) và hành vi (method) từ một class đã có (superclass hoặc parent class). Nó mô hình hóa mối quan hệ **"is-a"** (là một). Ví dụ, một `Car` là một `Vehicle`.

*   **Từ khóa `extends`**: Được sử dụng để thiết lập mối quan hệ kế thừa. `class Car extends Vehicle { ... }`
*   **Tái sử dụng mã (Code Reusability)**: Lợi ích chính. Bạn có thể viết mã chung một lần trong một superclass và tái sử dụng nó trên nhiều subclass.
*   **Constructor Chaining & `super`**: Nhiệm vụ đầu tiên của một constructor của subclass là gọi một constructor của superclass. Nếu bạn không viết rõ `super(...)`, trình biên dịch sẽ chèn một lời gọi đến `super()` không có đối số. Nếu lớp cha không có constructor không có đối số, bạn **phải** gọi một constructor khác một cách rõ ràng bằng `super(...)` làm dòng đầu tiên. Từ khóa `super` cũng được sử dụng để truy cập các method của lớp cha từ lớp con (`super.parentMethod()`).

##### **The Diamond Problem (Vấn đề kim cương)**
Vấn đề này xảy ra trong các ngôn ngữ hỗ trợ đa kế thừa *trạng thái* (class). Nếu class `D` kế thừa từ cả `B` và `C`, và cả `B` và `C` đều kế thừa từ `A`, thì `D` sẽ kế thừa phiên bản nào của một method từ `A` nếu cả `B` và `C` đều đã ghi đè nó? Java cố tình tránh sự phức tạp này bằng cách cho phép một class **chỉ `extend` một lớp cha**. Đa kế thừa *hành vi* được thực hiện bằng cách `implement` nhiều interface.

##### **Polymorphism (Tính đa hình)**
Polymorphism, có nghĩa là "nhiều hình dạng," là khả năng của một object có thể mang nhiều hình dạng. Trong Java, loại quan trọng nhất là **Runtime Polymorphism**, được thực hiện thông qua ghi đè method và dynamic binding.

Nó cho phép bạn viết mã hoạt động với một kiểu superclass, nhưng tại thời điểm chạy, triển khai của subclass đúng của một method bị ghi đè sẽ được thực thi.

*   **Dynamic Binding (Late Binding)**: JVM xác định triển khai method nào sẽ gọi tại thời điểm chạy, dựa trên **kiểu thực tế của object**, chứ không phải kiểu của biến tham chiếu trỏ đến nó. Đây là cơ chế cốt lõi của polymorphism.

##### **Casting và `instanceof`**
*   **Upcasting**: Gán một object subclass cho một tham chiếu superclass. Điều này luôn an toàn và xảy ra một cách ngầm định. `Vehicle v = new Car();`
*   **Downcasting**: Gán một tham chiếu superclass (trỏ đến một object subclass) trở lại một tham chiếu subclass. Điều này có thể không an toàn và phải được thực hiện một cách rõ ràng. Nó có thể thất bại với một `ClassCastException` nếu object không thực sự là một instance của subclass đích.

    ```java
    Vehicle v = new Car(); // Upcasting
    Car c = (Car) v;       // Downcasting (rõ ràng)
    ```
*   **Toán tử `instanceof`**: Một kiểm tra an toàn được sử dụng trước khi downcasting. Nó trả về `true` nếu một object là một instance của một class hoặc interface cụ thể.

    ```java
    if (v instanceof Car) {
        Car c = (Car) v; // Bây giờ điều này là an toàn
        c.openTrunk();   // Có thể gọi các method dành riêng cho Car
    }
    ```

---

#### **2. Ví dụ mã nguồn**

Ví dụ này minh họa polymorphism. Chúng ta có một mảng `Shape` chứa các loại hình dạng khác nhau. Khi chúng ta gọi `draw()` trên mỗi phần tử, JVM sử dụng dynamic binding để thực thi phiên bản đúng của method `draw()`.

```java
// Superclass
abstract class Shape {
    private String color;

    public Shape(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }

    // Abstract method để được ghi đè
    public abstract void draw();
}

// Subclass 1
class Circle extends Shape {
    private int radius;

    public Circle(String color, int radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " circle with radius " + radius);
    }
}

// Subclass 2
class Rectangle extends Shape {
    private int width, height;

    public Rectangle(String color, int width, int height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " rectangle of size " + width + "x" + height);
    }

    // Một method dành riêng cho Rectangle
    public void printDetails() {
        System.out.println("I am a rectangle.");
    }
}

public class PolymorphismDemo {
    public static void main(String[] args) {
        // Upcasting xảy ra ở đây
        Shape[] shapes = new Shape[3];
        shapes[0] = new Circle("Red", 10);
        shapes[1] = new Rectangle("Blue", 20, 30);
        shapes[2] = new Circle("Green", 5);

        // Polymorphism hoạt động
        for (Shape s : shapes) {
            // Dynamic binding: JVM quyết định draw() nào sẽ gọi tại thời điểm chạy
            s.draw();
        }

        // Downcasting với kiểm tra instanceof
        for (Shape s : shapes) {
            if (s instanceof Rectangle) {
                Rectangle r = (Rectangle) s; // Downcast an toàn
                r.printDetails();
            }
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp cơ sở `Weapon` với một trường `int damage` và một method `attack()` in ra một thông điệp tấn công chung.
2.  Tạo hai subclass, `Sword` và `Bow`, kế thừa từ `Weapon`.
3.  Constructor của `Sword` nên đặt một giá trị damage cao. Method `attack()` của nó nên được ghi đè để in "Swinging the sword!".
4.  Constructor của `Bow` nên đặt một giá trị damage thấp hơn. Method `attack()` của nó nên được ghi đè để in "Firing an arrow!".
5.  Trong `main`, tạo một mảng `Weapon` và điền nó với một `Sword` và một `Bow`.
6.  Lặp qua mảng và gọi method `attack()` trên mỗi vũ khí để minh họa polymorphism.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Đầu ra của đoạn mã sau là gì?
```java
class Animal {
    public void greet() { System.out.println("Animal greeting"); }
}
class Dog extends Animal {
    public void greet() { System.out.println("Dog greeting"); }
    public void bark() { System.out.println("Woof!"); }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.greet();
    }
}
```

A) `Animal greeting`
B) `Dog greeting`
C) Nó sẽ gây ra lỗi tại thời điểm biên dịch.
D) Nó sẽ gây ra lỗi tại thời điểm chạy.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) `Dog greeting`. Biến tham chiếu `a` có kiểu `Animal`, nhưng object mà nó trỏ đến có kiểu `Dog`. Do dynamic binding, JVM thực thi method `greet()` đã được ghi đè từ lớp `Dog` tại thời điểm chạy.

### **Bài 4: Lớp `Object` và các Method cốt lõi của nó**

#### **1. Giải thích khái niệm**

Trong Java, mọi class đều là hậu duệ, trực tiếp hoặc gián tiếp, của lớp `java.lang.Object`. Nếu một định nghĩa class không sử dụng từ khóa `extends`, nó ngầm kế thừa `Object`. Điều này có nghĩa là mọi object trong Java đều kế thừa các method của lớp `Object`.

Hiểu và ghi đè các method này một cách chính xác là rất quan trọng để tạo ra các object hoạt động tốt, có thể dự đoán được, đặc biệt là khi chúng được sử dụng trong các collection như `HashMap` hoặc `HashSet`.

##### **Method `toString()`**
*   **Mục đích:** Cung cấp một biểu diễn `String` có ý nghĩa, con người có thể đọc được của một object.
*   **Hành vi mặc định:** Triển khai mặc định trong lớp `Object` in ra tên lớp, theo sau là ký hiệu `@` và mã hash của object ở dạng thập lục phân (ví dụ: `com.example.Car@1a2b3c4d`). Điều này hiếm khi hữu ích.
*   **Thực hành tốt nhất:** Luôn ghi đè `toString()` trong các class của bạn để trả về một bản tóm tắt về trạng thái của object. Nó vô giá cho việc ghi log và gỡ lỗi.

##### **Method `equals()`**
*   **Mục đích:** Kiểm tra xem hai object có "bằng nhau" về mặt nội dung logic hoặc trạng thái của chúng hay không.
*   **Hành vi mặc định:** Toán tử `==` đối với các object so sánh địa chỉ bộ nhớ (reference equality). Method `equals()` mặc định trong lớp `Object` làm điều hoàn toàn giống hệt: `return (this == obj);`.
*   **Hợp đồng `equals()`:** Khi bạn ghi đè method này, bạn **phải** tuân thủ hợp đồng của nó:
    1.  **Phản xạ (Reflexive):** `x.equals(x)` phải là `true`.
    2.  **Đối xứng (Symmetric):** `x.equals(y)` là `true` khi và chỉ khi `y.equals(x)` là `true`.
    3.  **Bắc cầu (Transitive):** Nếu `x.equals(y)` là `true` và `y.equals(z)` là `true`, thì `x.equals(z)` phải là `true`.
    4.  **Nhất quán (Consistent):** Nhiều lần gọi `x.equals(y)` phải trả về cùng một giá trị một cách nhất quán (trừ khi trạng thái object bị sửa đổi).
    5.  **Không-null:** `x.equals(null)` phải là `false`.

##### **Method `hashCode()`**
*   **Mục đích:** Trả về một giá trị mã hash số nguyên cho object. Giá trị này được sử dụng bởi các collection dựa trên hash như `HashMap`, `HashSet`, và `Hashtable` để lưu trữ và truy xuất các object một cách hiệu quả.
*   **Hợp đồng `hashCode()`:**
    1.  **Nhất quán:** Nếu trạng thái của một object (các trường được sử dụng trong `equals()`) không thay đổi, `hashCode()` của nó phải trả về cùng một số nguyên một cách nhất quán.
    2.  **Quy tắc vàng:** **Nếu hai object bằng nhau theo method `equals()`, thì chúng PHẢI có cùng một mã hash.**
    3.  **Điều ngược lại KHÔNG đúng:** Nếu hai object có cùng một mã hash, chúng KHÔNG bắt buộc phải bằng nhau. Đây được gọi là "xung đột hash" (hash collision) và được xử lý bởi cấu trúc dữ liệu.

**Cạm bẫy:** Nếu bạn ghi đè `equals()`, bạn **PHẢI** ghi đè `hashCode()`. Nếu không, hai object mà bạn coi là bằng nhau có thể có các mã hash khác nhau, điều này sẽ làm hỏng chức năng của các collection dựa trên hash. Ví dụ, bạn có thể thêm một object vào `HashSet`, sau đó không thể tìm thấy nó sau này.

##### **`clone()` và `finalize()`**
*   **`clone()`:** Tạo và trả về một bản sao của một object. Khái niệm "bản sao" có thể là nông (shallow) hoặc sâu (deep). Method này nổi tiếng là khó triển khai đúng cách và thường được tránh trong Java hiện đại để thay thế bằng các constructor sao chép hoặc các factory method.
*   **`finalize()`:** Method này được gọi bởi Garbage Collector trên một object khi nó xác định rằng không còn tham chiếu nào đến object đó nữa. Việc sử dụng nó **hoàn toàn không được khuyến khích**. Nó không phải là một cơ chế đáng tin cậy để dọn dẹp tài nguyên (như đóng tệp hoặc kết nối cơ sở dữ liệu) vì không có gì đảm bảo *khi nào* hoặc thậm chí *liệu* nó sẽ được gọi. Hãy sử dụng `try-with-resources` hoặc các khối `finally` thay thế.

---

#### **2. Ví dụ mã nguồn**

Lớp `Book` này ghi đè `equals()` và `hashCode()` một cách chính xác. Lưu ý rằng cả hai method đều sử dụng cùng một tập hợp các trường (`isbn` và `title`).

```java
import java.util.Objects;

public class Book {
    private final String title;
    private final String isbn;
    private final int year;

    public Book(String title, String isbn, int year) {
        this.title = title;
        this.isbn = isbn;
        this.year = year;
    }

    // Một triển khai toString() hữu ích
    @Override
    public String toString() {
        return "Book{" +
               "title='" + title + '\'' +
               ", isbn='" + isbn + '\'' +
               ", year=" + year +
               '}';
    }

    // Một triển khai equals() đúng đắn
    @Override
    public boolean equals(Object o) {
        // 1. Tự kiểm tra
        if (this == o) return true;
        // 2. Kiểm tra null và kiểm tra class
        if (o == null || getClass() != o.getClass()) return false;
        // 3. Ép kiểu object
        Book book = (Book) o;
        // 4. So sánh các trường quan trọng
        return Objects.equals(title, book.title) &&
               Objects.equals(isbn, book.isbn);
    }

    // Một triển khai hashCode() đúng đắn
    @Override
    public int hashCode() {
        // Sử dụng các trường giống như trong equals()
        return Objects.hash(title, isbn);
    }
}

class ObjectMethodsDemo {
    public static void main(String[] args) {
        Book book1 = new Book("Effective Java", "978-0134685991", 2018);
        Book book2 = new Book("Effective Java", "978-0134685991", 2018);
        Book book3 = new Book("Clean Code", "978-0132350884", 2008);

        // --- Demo toString() ---
        System.out.println(book1); // Gọi toString() tùy chỉnh

        // --- Demo equals() ---
        System.out.println("book1.equals(book2): " + book1.equals(book2)); // true
        System.out.println("book1.equals(book3): " + book1.equals(book3)); // false

        // --- Demo hashCode() ---
        System.out.println("book1 hashCode: " + book1.hashCode());
        System.out.println("book2 hashCode: " + book2.hashCode());
        System.out.println("book3 hashCode: " + book3.hashCode());
        // book1 và book2 sẽ có cùng một mã hash.
    }
}
```

---

#### **3. Bài tập nhỏ**

1.  Tạo một lớp `Point` với hai trường `private int`: `x` và `y`.
2.  Cung cấp một constructor để khởi tạo các trường này.
3.  Ghi đè method `toString()` để trả về một chuỗi theo định dạng `"(x, y)"`.
4.  Ghi đè method `equals()`. Hai object `Point` được coi là bằng nhau nếu các giá trị `x` và `y` của chúng giống nhau.
5.  Ghi đè method `hashCode()`, đảm bảo nó tuân thủ hợp đồng với triển khai `equals()` của bạn. (Gợi ý: `Objects.hash(x, y)` là cách dễ nhất).
6.  Trong `main`, tạo hai object `Point` có cùng tọa độ và một object có tọa độ khác, sau đó kiểm tra các method `equals` và `hashCode` của bạn.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn có một lớp tùy chỉnh `Employee` mà bạn muốn sử dụng làm khóa trong `HashMap`. Bạn đã ghi đè method `equals()` một cách chính xác. Điều gì sẽ xảy ra nếu bạn **không** ghi đè `hashCode()`?

A) Mã sẽ không biên dịch.
B) Mã sẽ ném ra một ngoại lệ tại thời điểm chạy khi bạn đặt một `Employee` vào map.
C) Bạn có thể không truy xuất được một nhân viên từ map, ngay cả khi bạn sử dụng một khóa "bằng" với một khóa đã được chèn.
D) Mọi thứ sẽ hoạt động chính xác, vì `HashMap` chủ yếu sử dụng method `equals()`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Bạn có thể không truy xuất được một nhân viên từ map, ngay cả khi bạn sử dụng một khóa "bằng" với một khóa đã được chèn. `HashMap` đầu tiên sử dụng `hashCode()` để tìm "bucket" nơi object nên ở. Nếu hai object bằng nhau có các mã hash khác nhau (từ triển khai `Object` mặc định), map sẽ tìm trong bucket sai và không tìm thấy object.

### **Bài 5: Composition vs. Inheritance**

#### **1. Giải thích khái niệm**

Bài học này đề cập đến một trong những lựa chọn thiết kế cơ bản nhất trong lập trình hướng đối tượng: cách thiết lập mối quan hệ giữa các class. Trong khi Inheritance là một công cụ mạnh mẽ để tái sử dụng mã, nó thường bị lạm dụng ở những nơi mà một giải pháp thay thế linh hoạt hơn, Composition, lại tốt hơn.

##### **Ôn lại: Inheritance ("is-a")**
*   **Mối quan hệ:** Mô hình hóa một mối quan hệ phân cấp, cha-con. Một `Dog` *là một* loại chuyên biệt của `Animal`.
*   **Cơ chế:** Một subclass `extends` một superclass, kế thừa các thành viên public và protected của nó.
*   **Coupling:** Tạo ra **liên kết chặt chẽ (tight coupling)**. Subclass được liên kết mật thiết với việc triển khai của superclass.

##### **Composition ("has-a")**
*   **Mối quan hệ:** Mô hình hóa một mối quan hệ toàn thể-bộ phận. Một object được "bao gồm" từ các object khác. Một `Car` *có một* `Engine`.
*   **Cơ chế:** Một class chứa một biến instance là một tham chiếu đến một object khác. Object chứa (cái "toàn thể") chịu trách nhiệm về vòng đời của object được chứa (cái "bộ phận"). Bộ phận thường không thể tồn tại nếu không có toàn thể.
*   **Coupling:** Tạo ra **liên kết lỏng lẻo (loose coupling)**. Class "toàn thể" tương tác với class "bộ phận" chỉ thông qua giao diện công khai của nó, coi nó như một hộp đen.

##### **Aggregation (một kiểu "has-a" yếu hơn)**
*   **Mối quan hệ:** Một biến thể của composition nơi "bộ phận" có thể tồn tại độc lập với "toàn thể".
*   **Cơ chế:** Một class giữ một tham chiếu đến một object khác, nhưng nó không chịu trách nhiệm về vòng đời của nó. Object được tham chiếu được tạo và quản lý từ bên ngoài.
*   **Ví dụ:** Một `Professor` và một `University`. Lớp `University` có một danh sách các object `Professor`. `Professor` có thể tồn tại mà không cần trường đại học, và trường đại học có thể bị giải thể mà không làm các giáo sư ngừng tồn tại.

**Biểu diễn trên Sơ đồ UML:**
*   **Inheritance:** Một mũi tên rỗng, mở trỏ từ con đến cha.
*   **Composition:** Một hình thoi đen, đặc ở lớp "toàn thể" nối với lớp "bộ phận".
*   **Aggregation:** Một hình thoi trắng, rỗng ở lớp "toàn thể" nối với lớp "bộ phận".

---

#### **2. Nguyên tắc chỉ đạo: "Ưu tiên Composition hơn Inheritance"**

Đây là một nguyên tắc thiết kế nổi tiếng có lý do của nó. Inheritance, mặc dù mạnh mẽ, đi kèm với những nhược điểm đáng kể.

##### **Tại sao Composition thường tốt hơn:**

1.  **Linh hoạt tại Runtime:**
    *   **Inheritance là tĩnh và cố định tại thời điểm biên dịch.** Một `HondaCivic` sẽ luôn là một `Car`. Bạn không thể thay đổi mối quan hệ này sau khi mã được biên dịch.
    *   **Composition là động.** Bạn có thể thay đổi các "bộ phận" của một object tại runtime. Một object `Computer` có thể có thành phần `GraphicsCard` của nó được đổi từ một `NvidiaCard` sang một `AMDRadeonCard` chỉ bằng cách thay đổi tham chiếu object. Đây là nền tảng của **Strategy Design Pattern**.

2.  **Tránh liên kết chặt chẽ (Vấn đề Lớp cơ sở mong manh - Fragile Base Class Problem):**
    *   **Inheritance là mong manh.** Nếu bạn thay đổi việc triển khai của một method của superclass, bạn có thể vô tình làm hỏng tất cả các subclass kế thừa nó. Ví dụ, nếu một subclass `List` phụ thuộc vào method `add()` của cha nó, và method `addAll()` của cha được thay đổi để không còn gọi `add()` nữa, subclass sẽ bị hỏng.
    *   **Composition là mạnh mẽ.** Lớp chứa chỉ biết về giao diện công khai của các thành phần của nó. Việc triển khai nội bộ của một thành phần có thể được thay đổi tự do mà không có bất kỳ tác động nào, miễn là hợp đồng công khai của nó vẫn giữ nguyên.

3.  **Bảo toàn Encapsulation:**
    *   **Inheritance có thể phá vỡ encapsulation.** Các subclass thường có quyền truy cập vào các thành viên `protected` của lớp cha, tạo ra sự phụ thuộc vào các chi tiết triển khai nội bộ của lớp cha.
    *   **Composition tôn trọng encapsulation.** Lớp chứa không thể truy cập trạng thái private của các thành phần của nó. Đó là một mối quan hệ hộp đen thực sự.

4.  **Thiết kế đơn giản hơn, dễ kiểm thử hơn:**
    *   Các class được thiết kế cho composition thường nhỏ hơn, tập trung vào một trách nhiệm, và tương tác thông qua các giao diện rõ ràng. Điều này làm cho chúng dễ kiểm thử hơn rất nhiều khi đứng một mình (sử dụng mock hoặc stub cho các thành phần của chúng). Việc kiểm thử một hệ thống phân cấp kế thừa thường đòi hỏi phải kiểm thử toàn bộ hệ thống phân cấp cùng nhau.

---

#### **3. Ví dụ mã nguồn: Vấn đề con vịt**

Ví dụ kinh điển này cho thấy một thiết kế dựa trên kế thừa thất bại như thế nào và composition giải quyết nó một cách thanh lịch ra sao.

##### **Cách tiếp cận kế thừa có vấn đề:**

```java
// Lớp cơ sở với hành vi chung
abstract class Duck {
    public void swim() { System.out.println("All ducks float!"); }
    public abstract void display();
    // Các hành vi phổ biến nhưng không phải là toàn bộ
    public void quack() { System.out.println("Quack!"); }
    public void fly() { System.out.println("I'm flying!"); }
}

class MallardDuck extends Duck { /* ... hiển thị Vịt trời ... */ }
class RedheadDuck extends Duck { /* ... hiển thị Vịt đầu đỏ ... */ }

// VẤN ĐỀ 1: Còn vịt cao su thì sao? Nó kêu kít kít, không phải quack.
class RubberDuck extends Duck {
    @Override
    public void quack() { System.out.println("Squeak!"); } // Bắt buộc phải ghi đè
    @Override
    public void fly() { /* Không làm gì cả, vịt cao su không bay */ } // Ghi đè rỗng có vấn đề
}
```

##### **Cách tiếp cận Composition ưu việt hơn:**

```java
// 1. Tách các hành vi ra thành các interface riêng
interface FlyBehavior { void fly(); }
interface QuackBehavior { void quack(); }

// 2. Tạo các triển khai cụ thể của các hành vi
class FlyWithWings implements FlyBehavior {
    public void fly() { System.out.println("I'm flying with wings!"); }
}
class FlyNoWay implements FlyBehavior {
    public void fly() { System.out.println("I can't fly."); }
}
class Quack implements QuackBehavior {
    public void quack() { System.out.println("Quack!"); }
}
class Squeak implements QuackBehavior {
    public void quack() { System.out.println("Squeak!"); }
}

// 3. Lớp Duck bây giờ được COMPOSED (bao gồm) từ các hành vi
abstract class DuckV2 {
    // Composition: Mỗi con vịt HAS-A một hành vi bay và kêu
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    public void performFly() {
        flyBehavior.fly(); // Ủy thác hành động cho object hành vi
    }
    public void performQuack() {
        quackBehavior.quack(); // Ủy thác
    }
    public void swim() { System.out.println("All ducks float!"); }
    public abstract void display();
}

// 4. Tạo các con vịt cụ thể bằng cách cắm các hành vi mong muốn vào
class MallardDuckV2 extends DuckV2 {
    public MallardDuckV2() {
        flyBehavior = new FlyWithWings(); // Thiết lập các hành vi cụ thể
        quackBehavior = new Quack();
    }
    public void display() { System.out.println("Looks like a Mallard"); }
}

class RubberDuckV2 extends DuckV2 {
    public RubberDuckV2() {
        flyBehavior = new FlyNoWay();
        quackBehavior = new Squeak();
    }
    public void display() { System.out.println("Looks like a Rubber Duck"); }
}
```

---

#### **4. Bài tập nhỏ**

Thiết kế một lớp `Character` cho một trò chơi đơn giản.
1.  Thay vì sử dụng kế thừa (`Knight extends Character`, `Wizard extends Character`), hãy sử dụng composition.
2.  Tạo một interface `WeaponBehavior` với một method `useWeapon()`.
3.  Tạo các triển khai cụ thể như `SwordBehavior`, `BowAndArrowBehavior`, và `StaffBehavior`.
4.  Lớp `Character` nên có một trường cho `WeaponBehavior`.
5.  Lớp `Character` nên có một method `attack()` ủy thác cho method `useWeapon()` của object `weaponBehavior` của nó.
6.  Lớp `Character` cũng nên có một method `setWeapon(WeaponBehavior newWeapon)` để cho phép thay đổi vũ khí tại runtime.
7.  Trong `main`, tạo một nhân vật, cho nó tấn công bằng kiếm, sau đó đổi vũ khí của nó thành cung và cho nó tấn công lại.

---

#### **5. Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào mô tả chính xác nhất một ưu điểm chính của composition so với inheritance?

A) Composition cho phép kiểm tra kiểu mạnh hơn tại thời điểm biên dịch.
B) Composition cho phép một lớp kế thừa từ nhiều lớp khác, tránh được vấn đề kim cương.
C) Composition cho phép linh hoạt hơn bằng cách cho phép hành vi của một object có thể được thay đổi tại runtime.
D) Inheritance tốt hơn cho việc tái sử dụng mã vì nó cung cấp quyền truy cập trực tiếp hơn vào mã của lớp cha.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Composition cho phép linh hoạt hơn bằng cách cho phép hành vi của một object có thể được thay đổi tại runtime. Bản chất động này là một lý do chính tại sao nó thường được ưa thích để xây dựng các hệ thống linh hoạt và dễ bảo trì.

### **Bài 6: Association, Aggregation, và Composition**

#### **1. Giải thích khái niệm**

Trong bài học trước, chúng ta đã so sánh Inheritance ("is-a") với Composition ("has-a"). Bây giờ, chúng ta sẽ phân tích mối quan hệ "has-a" thành ba loại chính thức của nó: Association, Aggregation, và Composition. Các thuật ngữ này mô tả các cách khác nhau mà các object có thể được liên kết và rất quan trọng cho việc thiết kế và mô hình hóa hướng đối tượng chính xác (đặc biệt là trong UML).

##### **Association ("uses-a")**

Association là mối quan hệ chung nhất giữa hai object. Nó biểu thị rằng hai class có một liên kết cấu trúc, có nghĩa là một object "sử dụng" hoặc tương tác với một object khác. Chúng là ngang hàng, và không object nào sở hữu object kia.

*   **Vòng đời:** Vòng đời của các object liên quan là **độc lập**. Một object có thể được tạo, tồn tại, và bị hủy mà không ảnh hưởng đến object kia.
*   **Ví dụ tương tự:** Một `Doctor` và một `Patient`. Một bác sĩ có nhiều bệnh nhân, và một bệnh nhân có thể gặp nhiều bác sĩ. Nếu một bác sĩ cụ thể nghỉ hưu, các bệnh nhân vẫn tiếp tục tồn tại. Nếu một bệnh nhân chuyển đi, bác sĩ vẫn tiếp tục tồn tại.
*   **Số lượng:** Có thể là một-một, một-nhiều, nhiều-một, hoặc nhiều-nhiều.
*   **Triển khai:** Thường được triển khai bằng cách truyền một object làm tham số của method hoặc giữ một tham chiếu đến nó như một biến instance, nơi vòng đời của object được tham chiếu không được quản lý bởi lớp chứa.

##### **Aggregation (một kiểu "has-a" mạnh hơn)**

Aggregation là một dạng chuyên biệt của Association. Nó đại diện cho một mối quan hệ "toàn thể-bộ phận" nơi "bộ phận" có thể tồn tại độc lập với "toàn thể".

*   **Vòng đời:** Vòng đời của object "bộ phận" là **độc lập** với vòng đời của object "toàn thể".
*   **Ví dụ tương tự:** Một `Department` và các `Professor` của nó. Khoa "có" các giáo sư. Tuy nhiên, nếu khoa bị đóng cửa, các giáo sư ("bộ phận") không ngừng tồn tại; họ có thể tham gia một khoa hoặc trường đại học khác.
*   **Quyền sở hữu:** Đó là một sự sở hữu yếu. "Toàn thể" có các tham chiếu đến các "bộ phận" của nó, nhưng không quản lý việc tạo hoặc hủy chúng.
*   **Ký hiệu UML:** Một hình thoi rỗng (trắng) trên lớp "toàn thể".

##### **Composition (kiểu "part-of" mạnh nhất)**

Composition là một dạng nghiêm ngặt hơn của Aggregation. Nó đại diện cho một mối quan hệ "toàn thể-bộ phận" nơi "bộ phận" **không thể** tồn tại độc lập với "toàn thể".

*   **Vòng đời:** Vòng đời của object "bộ phận" là **phụ thuộc** vào vòng đời của object "toàn thể". Nếu "toàn thể" bị hủy, các "bộ phận" cũng bị hủy cùng với nó.
*   **Ví dụ tương tự:** Một `House` và các `Room` của nó. Các phòng là một phần không thể thiếu của ngôi nhà. Bạn không thể có một căn phòng mà không có ngôi nhà. Nếu bạn phá hủy ngôi nhà, các phòng cũng bị phá hủy.
*   **Quyền sở hữu:** Đó là một sự sở hữu mạnh. "Toàn thể" chịu trách nhiệm tạo và hủy các "bộ phận" của nó.
*   **Ký hiệu UML:** Một hình thoi đặc (đen) trên lớp "toàn thể".

##### **Bảng so sánh tóm tắt**

| Mối quan hệ | Loại | Vòng đời | Quyền sở hữu | Ví dụ |
| :--- | :--- | :--- | :--- | :--- |
| **Association** | uses-a | Độc lập | Không có | `Student` và `Course` |
| **Aggregation** | has-a | Độc lập | Yếu | `Team` và `Player` |
| **Composition** | part-of | Phụ thuộc | Mạnh | `Order` và `OrderItem` |

---

#### **2. Ví dụ mã nguồn**

```java
// --- Ví dụ Association ---
// Một Student có thể tồn tại mà không cần một Course, và ngược lại.
class Student {
    private String name;
    // ...
}
class Course {
    private String title;
    // Course sử dụng các object Student, nhưng không sở hữu chúng.
    private List<Student> students;
    // ...
}

// --- Ví dụ Aggregation ---
class Professor {
    private String name;
    public Professor(String name) { this.name = name; }
}

class Department {
    private String name;
    // Aggregation: Department có một danh sách các Professor.
    // Các object Professor được tạo từ bên ngoài và có thể tồn tại mà không cần department.
    private List<Professor> professors;

    public Department(String name, List<Professor> professors) {
        this.name = name;
        this.professors = professors;
    }
}

// --- Ví dụ Composition ---
class Engine {
    private String type;
    // Engine được tạo cho một chiếc xe cụ thể và 'chết' cùng với nó.
    public Engine(String type) { this.type = type; }
    public void start() { System.out.println("Engine started."); }
}

class Car {
    private String model;
    // Composition: Car sở hữu Engine của nó. Engine được tạo bên trong Car.
    private final Engine engine;

    public Car(String model) {
        this.model = model;
        // Vòng đời của Engine gắn liền với vòng đời của Car.
        this.engine = new Engine("V8");
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving.");
    }
}

public class RelationshipsDemo {
    public static void main(String[] args) {
        // Demo Aggregation
        Professor p1 = new Professor("Dr. Smith");
        Professor p2 = new Professor("Dr. Jones");
        List<Professor> csProfessors = new ArrayList<>();
        csProfessors.add(p1);
        csProfessors.add(p2);
        Department csDept = new Department("Computer Science", csProfessors);
        // Nếu csDept được đặt thành null, p1 và p2 vẫn tồn tại.

        // Demo Composition
        Car myCar = new Car("Mustang");
        myCar.drive();
        // Khi myCar ra khỏi phạm vi và được garbage collect, object Engine của nó
        // cũng trở thành đối tượng đủ điều kiện để garbage collect vì không có gì khác có thể tham chiếu đến nó.
    }
}
```

---

#### **3. Bài tập nhỏ**

Mô hình hóa một `Playlist` cho một ứng dụng nghe nhạc trực tuyến.
1.  Tạo một lớp `Song` với `title` và `artist`.
2.  Tạo một lớp `Playlist` với `name`.
3.  Quyết định mối quan hệ giữa `Playlist` và `Song`. Đó là Association, Aggregation, hay Composition? Giải thích lựa chọn của bạn. (Gợi ý: Một `Song` có thể tồn tại bên ngoài một `Playlist` không? Nó có thể thuộc về nhiều playlist không?)
4.  Triển khai các lớp. Lớp `Playlist` nên có một `List<Song>` và các method để `addSong()` và `playPlaylist()`. Method `addSong()` nên nhận một object `Song` làm tham số.
5.  Trong `main`, tạo một vài object `Song`, tạo một `Playlist`, và thêm các bài hát vào đó.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một ứng dụng thương mại điện tử, một object `Order` chứa nhiều object `OrderItem` (mỗi object đại diện cho một sản phẩm, số lượng và giá). Một `OrderItem` không thể được tạo ra nếu không có một `Order` liên quan. Mối quan hệ giữa `Order` và `OrderItem` là gì?

A) Association
B) Aggregation
C) Composition
D) Inheritance

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Composition. `OrderItem` là một "bộ phận" không thể thiếu của `Order`. Vòng đời của nó hoàn toàn phụ thuộc vào vòng đời của `Order`. Nếu `Order` bị xóa, tất cả các `OrderItem` của nó cũng bị xóa theo.

### **Bài 7: Nguyên tắc SOLID - Nguyên tắc Trách nhiệm duy nhất (SRP)**

#### **1. Giải thích khái niệm**

Bài học này bắt đầu hành trình của chúng ta vào các nguyên tắc **SOLID**, một bộ năm nguyên tắc thiết kế cơ bản là nền tảng để viết phần mềm hướng đối tượng dễ bảo trì, có thể mở rộng và mạnh mẽ.

Nguyên tắc đầu tiên là **Single Responsibility Principle (SRP)**.

**Nguyên tắc:** *Một class chỉ nên có một lý do duy nhất để thay đổi.*

Đây là một trong những nguyên tắc đơn giản nhất để hiểu nhưng có thể khó áp dụng đúng. Nó **không** có nghĩa là một class chỉ nên có một method. Nó có nghĩa là một class chỉ nên có một công việc hoặc trách nhiệm chính. Tất cả các method và thuộc tính trong class đó phải có tính gắn kết cao (highly cohesive), nghĩa là tất cả chúng đều liên quan chặt chẽ đến mục đích duy nhất đó.

**Ví dụ tương tự:** Hãy nghĩ về một đầu bếp trong nhà bếp. Trách nhiệm duy nhất của một đầu bếp là nấu ăn. Họ không nên chịu trách nhiệm nhận đơn đặt hàng từ khách hàng (công việc của người phục vụ) hoặc rửa bát đĩa (công việc của người rửa bát). Nếu nhà hàng quyết định thay đổi cách nhận đơn đặt hàng (ví dụ: chuyển sang dùng máy tính bảng), công việc của đầu bếp không nên bị ảnh hưởng. Bằng cách tách biệt các trách nhiệm, hệ thống trở nên dễ quản lý và thay đổi hơn.

**Lợi ích cốt lõi của SRP:**
*   **Giảm độ phức tạp:** Các class nhỏ hơn, tập trung hơn và dễ hiểu hơn.
*   **Cải thiện khả năng bảo trì:** Một thay đổi liên quan đến một trách nhiệm sẽ không ảnh hưởng đến một trách nhiệm khác. Nếu bạn cần thay đổi cách dữ liệu được lưu vào cơ sở dữ liệu, bạn sẽ không có nguy cơ làm hỏng logic nghiệp vụ tính toán các giá trị.
*   **Tính gắn kết cao hơn:** Các yếu tố của class đều hoạt động cùng nhau hướng tới một mục tiêu chung.
*   **Tăng cường khả năng kiểm thử:** Dễ dàng hơn nhiều để viết các unit test tập trung cho một class chỉ làm một việc.

**Vi phạm phổ biến (Anti-Pattern): The God Object**
Một "God Object" là một class biết quá nhiều và làm quá nhiều. Nó thường xử lý logic nghiệp vụ, lưu trữ dữ liệu, xác thực đầu vào của người dùng và định dạng tất cả ở một nơi. Các class này là một cơn ác mộng về bảo trì vì một thay đổi trong bất kỳ lĩnh vực nào trong số này đều đòi hỏi phải sửa đổi class khổng lồ, phức tạp này.

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm SRP**
Lớp `Employee` dưới đây có ba trách nhiệm riêng biệt: logic nghiệp vụ (tính lương), lưu trữ dữ liệu (lưu vào DB), và trình bày (tạo báo cáo). Nó có ba lý do khác nhau để thay đổi.

```java
// VI PHẠM SRP
public class Employee {
    private String name;
    private double salary;
    private int hoursWorked;

    public Employee(String name, double salary, int hoursWorked) {
        this.name = name;
        this.salary = salary;
        this.hoursWorked = hoursWorked;
    }

    // Trách nhiệm 1: Logic nghiệp vụ
    public double calculatePay() {
        return (salary / 2080) * hoursWorked; // 2080 là số giờ làm việc trung bình trong một năm
    }

    // Trách nhiệm 2: Lưu trữ dữ liệu
    public void saveToDatabase() {
        // ... mã để kết nối với cơ sở dữ liệu SQL và lưu dữ liệu nhân viên ...
        System.out.println("Saving " + this.name + " to the database.");
    }

    // Trách nhiệm 3: Trình bày
    public String generateReport() {
        // ... mã để định dạng dữ liệu nhân viên thành một báo cáo HTML ...
        return "<html><body><h1>Employee Report for " + this.name + "</h1></body></html>";
    }
}
```

##### **Ví dụ tốt: Tuân thủ SRP**
Chúng ta tái cấu trúc một class duy nhất thành ba class riêng biệt, mỗi class có một trách nhiệm duy nhất, rõ ràng.

```java
// Class 1: Một object dữ liệu đơn giản (POJO) không có trách nhiệm nào khác.
// Lý do duy nhất để nó thay đổi là nếu cấu trúc dữ liệu của Employee thay đổi.
public class EmployeeData {
    private String name;
    private double salary;
    // Getters và Setters...
}

// Class 2: Chỉ xử lý logic nghiệp vụ tính lương.
// Lý do duy nhất để nó thay đổi là nếu các quy tắc tính lương thay đổi.
public class PayCalculator {
    public double calculatePay(EmployeeData employee) {
        // ... logic tính toán ...
        return employee.getSalary() / 2080;
    }
}

// Class 3: Chỉ xử lý việc lưu trữ dữ liệu nhân viên.
// Lý do duy nhất để nó thay đổi là nếu lược đồ hoặc công nghệ cơ sở dữ liệu thay đổi.
public class EmployeeRepository {
    public void save(EmployeeData employee) {
        // ... mã để kết nối với cơ sở dữ liệu và lưu nhân viên ...
        System.out.println("Saving " + employee.getName() + " to the database.");
    }
}
```
Bây giờ, nếu cơ sở dữ liệu thay đổi từ SQL sang NoSQL, chỉ có lớp `EmployeeRepository` cần được sửa đổi. `PayCalculator` hoàn toàn không bị ảnh hưởng.

---

#### **3. Bài tập nhỏ**

Bạn được giao một lớp `Book` duy nhất chịu trách nhiệm lưu trữ chi tiết sách, in chúng ra console và lưu chúng vào một tệp. Điều này vi phạm SRP.

```java
public class Book {
    private String title;
    private String author;
    private String text;

    // constructor và getters...

    // Trách nhiệm 1: Quản lý dữ liệu sách (điều này ổn)

    // Trách nhiệm 2: Trình bày
    public void printToConsole() {
        System.out.println("Title: " + title);
        System.out.println("Author: " + author);
        System.out.println("Content: " + text);
    }

    // Trách nhiệm 3: Lưu trữ
    public void saveToFile(String filename) {
        // ... logic để ghi văn bản của sách vào một tệp ...
    }
}
```

Nhiệm vụ của bạn là tái cấu trúc mã này. Tạo hai lớp mới, `BookPrinter` và `BookPersistence`, và chuyển các method `printToConsole` và `saveToFile` vào chúng, tương ứng. Các lớp mới sẽ nhận một object `Book` làm tham số để thực hiện các hành động của chúng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Kịch bản nào sau đây mô tả lợi ích đáng kể nhất của việc áp dụng Nguyên tắc Trách nhiệm duy nhất?

A) Ứng dụng sẽ chạy nhanh hơn vì các lớp nhỏ hơn.
B) Tổng số dòng mã trong dự án sẽ được giảm bớt.
C) Thay đổi định dạng của một báo cáo sẽ không yêu cầu biên dịch lại lớp xử lý các giao dịch cơ sở dữ liệu.
D) Ứng dụng sẽ sử dụng ít bộ nhớ hơn tại thời điểm chạy.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Thay đổi định dạng của một báo cáo sẽ không yêu cầu biên dịch lại lớp xử lý các giao dịch cơ sở dữ liệu. Điều này trực tiếp giải quyết ý tưởng cốt lõi của SRP: cô lập sự thay đổi. Bằng cách tách biệt các trách nhiệm báo cáo và lưu trữ, hai trách nhiệm này được tách rời và có thể phát triển độc lập.

### **Bài 8: Nguyên tắc SOLID - Nguyên tắc Đóng/Mở (OCP)**

#### **1. Giải thích khái niệm**

Nguyên tắc SOLID thứ hai là **Open/Closed Principle (OCP)**.

**Nguyên tắc:** *Các thực thể phần mềm (lớp, mô-đun, hàm, v.v.) nên được mở để mở rộng, nhưng đóng để sửa đổi.*

Điều này có nghĩa là bạn nên có thể thêm chức năng mới vào một hệ thống **mà không cần thay đổi mã hiện có, đang hoạt động**. Thay đổi mã là rủi ro; nó có thể gây ra lỗi vào các tính năng trước đây đã ổn định. Thêm mã mới sẽ an toàn hơn.

OCP là một ứng dụng trực tiếp của tính trừu tượng. Chúng ta đạt được nó bằng cách lập trình theo interface hoặc abstract class thay vì các triển khai cụ thể. Bằng cách phụ thuộc vào các abstraction, chúng ta có thể giới thiệu các triển khai mới của các abstraction đó (phần "mở rộng") mà không bao giờ chạm vào mã sử dụng chúng (phần "đóng").

**Ví dụ tương tự:** Hãy nghĩ về một chiếc điện thoại thông minh và cửa hàng ứng dụng của nó. Hệ điều hành cốt lõi của điện thoại là "đóng để sửa đổi". Bạn không cần phải viết lại Android hoặc iOS để thêm một tính năng mới. Tuy nhiên, nó "mở để mở rộng" thông qua cửa hàng ứng dụng. Các nhà phát triển có thể tạo ra các ứng dụng hoàn toàn mới để thêm chức năng cho điện thoại mà không bao giờ chạm vào mã HĐH gốc.

**Lợi ích cốt lõi của OCP:**
*   **Dễ bảo trì:** Giảm nguy cơ gây ra lỗi vào mã hiện có, ổn định.
*   **Linh hoạt & Khả năng mở rộng:** Các tính năng mới có thể được thêm vào chỉ bằng cách tạo các lớp mới và cắm chúng vào hệ thống.
*   **Liên kết lỏng lẻo:** Thúc đẩy các thiết kế trong đó các thành phần không phụ thuộc chặt chẽ vào các triển khai cụ thể của nhau.

**Vi phạm phổ biến:** Sử dụng một chuỗi các câu lệnh `if/else if` hoặc `switch` dựa trên loại hoặc thuộc tính của một object. Mỗi khi bạn cần hỗ trợ một loại mới, bạn phải quay lại và sửa đổi khối mã này, điều này vi phạm quy tắc "đóng để sửa đổi".

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm OCP**
Hãy tưởng tượng chúng ta có một hệ thống tính diện tích của các hình dạng khác nhau. Triển khai này không đóng để sửa đổi. Nếu chúng ta muốn thêm một hình dạng mới, như một `Triangle`, chúng ta **phải** sửa đổi lớp `AreaCalculator`.

```java
// VI PHẠM OCP
class Rectangle {
    public double width;
    public double height;
}

class Circle {
    public double radius;
}

// Lớp này phải được sửa đổi mỗi khi một hình dạng mới được thêm vào.
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        }
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return circle.radius * circle.radius * Math.PI;
        }
        // Điều gì sẽ xảy ra nếu chúng ta thêm một Triangle? Chúng ta phải thêm một khối 'if' khác ở đây.
        return 0;
    }
}
```

##### **Ví dụ tốt: Tuân thủ OCP**
Chúng ta tái cấu trúc thiết kế để phụ thuộc vào một abstraction (interface `Shape`). `AreaCalculator` bây giờ là "đóng" vì nó không cần thay đổi. Hệ thống là "mở" vì chúng ta có thể thêm các hình dạng mới chỉ bằng cách tạo các lớp mới triển khai interface `Shape`.

```java
// 1. Định nghĩa một abstraction (hợp đồng)
interface Shape {
    double calculateArea();
}

// 2. Tạo các triển khai cụ thể
class RectangleV2 implements Shape {
    public double width;
    public double height;
    @Override
    public double calculateArea() {
        return width * height;
    }
}

class CircleV2 implements Shape {
    public double radius;
    @Override
    public double calculateArea() {
        return radius * radius * Math.PI;
    }
}

// HÌNH DẠNG MỚI: Chúng ta có thể thêm cái này mà không cần chạm vào bất kỳ mã hiện có nào.
class Triangle implements Shape {
    public double base;
    public double height;
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// 3. Mô-đun cấp cao chỉ phụ thuộc vào abstraction.
// Lớp này bây giờ ĐÓNG để sửa đổi nhưng MỞ để mở rộng.
class AreaCalculatorV2 {
    public double calculateArea(Shape shape) {
        // Không còn if/else! Nó chỉ gọi method trên abstraction.
        return shape.calculateArea();
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một `NotificationService` gửi các loại thông báo khác nhau. Triển khai hiện tại vi phạm OCP.

```java
public class NotificationService {
    public void sendNotification(String type, String message) {
        if (type.equals("email")) {
            System.out.println("Sending Email: " + message);
        } else if (type.equals("sms")) {
            System.out.println("Sending SMS: " + message);
        }
    }
}
```

Nhiệm vụ của bạn là tái cấu trúc mã này để tuân theo Nguyên tắc Đóng/Mở.
1.  Tạo một interface `NotificationProvider` với một method `send(String message)`.
2.  Tạo hai lớp cụ thể, `EmailProvider` và `SmsProvider`, triển khai interface này.
3.  Sửa đổi `NotificationService` để method `sendNotification` của nó nhận một object `NotificationProvider` làm tham số và gọi method `send` của nó.
4.  Chỉ ra cách bạn có thể dễ dàng thêm một `PushNotificationProvider` mà không cần thay đổi lớp `NotificationService`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Một hệ thống xử lý thanh toán. Lớp `PaymentProcessor` chính có một method `processPayment(PaymentDetails details)` chứa một câu lệnh `switch` lớn dựa trên `details.getPaymentType()` (ví dụ: "CREDIT_CARD", "PAYPAL", "BITCOIN"). Thiết kế này vi phạm rõ ràng nhất nguyên tắc SOLID nào?

A) Single Responsibility Principle
B) Open/Closed Principle
C) Liskov Substitution Principle
D) Interface Segregation Principle

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Open/Closed Principle. Mỗi khi một phương thức thanh toán mới (như "APPLE_PAY") được giới thiệu, nhà phát triển phải sửa đổi lớp `PaymentProcessor` hiện có bằng cách thêm một `case` mới vào câu lệnh `switch`. Điều này vi phạm quy tắc "đóng để sửa đổi".

### **Bài 9: Nguyên tắc SOLID - Nguyên tắc thay thế Liskov (LSP)**

#### **1. Giải thích khái niệm**

Nguyên tắc SOLID thứ ba là **Liskov Substitution Principle (LSP)**, được đặt theo tên của nhà khoa học máy tính Barbara Liskov.

**Nguyên tắc:** *Các kiểu con phải có thể thay thế được cho các kiểu cơ sở của chúng.*

Điều này có nghĩa là nếu bạn có một đoạn mã hoạt động với một lớp cơ sở (hoặc interface), nó cũng phải có thể hoạt động với bất kỳ lớp con nào của nó mà không cần biết đến điều đó. Lớp con không nên làm bất cứ điều gì mà mã client không mong đợi từ lớp cơ sở. Về bản chất, một lớp con nên mở rộng chức năng của lớp cha, chứ không thu hẹp hoặc thay đổi hành vi cơ bản của nó.

**Ví dụ tương tự:** Một ví dụ kinh điển là vấn đề "Hình vuông là một Hình chữ nhật". Về mặt toán học, một hình vuông *là một* hình chữ nhật. Vì vậy, thật hấp dẫn khi mô hình hóa điều này bằng kế thừa: `class Square extends Rectangle`.

Một `Rectangle` có các method `setWidth(int width)` và `setHeight(int height)`. Một người dùng object `Rectangle` mong đợi có thể đặt chiều rộng và chiều cao một cách độc lập.

`Rectangle r = new Rectangle();`
`r.setWidth(5);`
`r.setHeight(10);`
`assert r.getArea() == 50; // Đây là một kỳ vọng hợp lý.`

Bây giờ, nếu chúng ta thay thế một object `Square` cho `Rectangle`, kỳ vọng này bị phá vỡ. Để duy trì "tính hình vuông", lớp `Square` phải buộc chiều rộng và chiều cao phải giống nhau.

`Rectangle r = new Square(); // Sự thay thế`
`r.setWidth(5);`
`r.setHeight(10); // Điều này cũng phải thay đổi chiều rộng thành 10 để giữ nó là một hình vuông!`
`assert r.getArea() == 50; // THẤT BẠI! Diện tích bây giờ là 100.`

Object `Square` không phải là một sự thay thế hợp lệ cho một `Rectangle` vì nó thay đổi hành vi (hợp đồng) của lớp cơ sở. Đây là một vi phạm của LSP.

**Các quy tắc tuân thủ (Behavioral Subtyping):**
Một kiểu con phải tuân thủ hợp đồng của kiểu cha của nó. Điều này bao gồm:
*   **Tiền điều kiện không được tăng cường:** Một method của lớp con không nên yêu cầu nhiều hơn từ đầu vào của nó so với method của lớp cha.
*   **Hậu điều kiện không được làm yếu đi:** Một method của lớp con phải đảm bảo ít nhất bằng đầu ra của method của lớp cha.
*   **Các bất biến phải được bảo toàn:** Bất kỳ điều kiện nào luôn đúng cho lớp cha cũng phải luôn đúng cho lớp con.
*   **Ngoại lệ:** Một method của lớp con không nên ném ra các loại ngoại lệ mới không phải là một phần của chữ ký của method của lớp cha (trừ khi chúng là các kiểu con của các ngoại lệ đã được khai báo).

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm LSP**
Hãy mô hình hóa một hệ thống phân cấp các loài chim. Lớp cơ sở `Bird` có một method `fly()`. Điều này hoạt động với hầu hết các loài chim, nhưng không phải với các loài chim không bay được như chim cánh cụt.

```java
// VI PHẠM LSP
class Bird {
    public void fly() {
        System.out.println("This bird is flying.");
    }
}

class Sparrow extends Bird {
    // Chim sẻ có thể bay, vì vậy nó là một sự thay thế tốt.
}

class Penguin extends Bird {
    @Override
    public void fly() {
        // Một con chim cánh cụt không thể bay. Chúng ta làm gì?
        // Lựa chọn 1: Không làm gì cả (vi phạm kỳ vọng).
        // Lựa chọn 2: Ném ra một ngoại lệ (vi phạm kỳ vọng).
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

class BirdSanctuary {
    // Method này mong đợi bất kỳ con Bird nào cũng có thể bay.
    public void makeBirdsFly(List<Bird> birds) {
        for (Bird bird : birds) {
            try {
                bird.fly(); // Điều này sẽ bị lỗi khi đến Penguin.
            } catch (UnsupportedOperationException e) {
                System.out.println("Oops, found a bird that can't fly.");
            }
        }
    }
}
```
Mã client `BirdSanctuary` bị buộc phải xử lý một trường hợp đặc biệt cho `Penguin`, điều đó có nghĩa là `Penguin` không phải là một kiểu con có thể thay thế được của `Bird`.

##### **Ví dụ tốt: Tuân thủ LSP**
Chúng ta giải quyết vấn đề này bằng cách tạo ra một sự trừu tượng chính xác hơn. Thay vì giả định tất cả các loài chim đều có thể bay, chúng ta tách hành vi bay thành một interface riêng hoặc một lớp con riêng.

```java
// Lớp cơ sở cho tất cả các loài chim, không có method fly().
class BirdV2 {
    public void eat() {
        System.out.println("This bird is eating.");
    }
}

// Một interface chỉ dành cho những con chim có thể bay.
interface FlyingBird {
    void fly();
}

// Sparrow bây giờ triển khai hành vi bay.
class SparrowV2 extends BirdV2 implements FlyingBird {
    @Override
    public void fly() {
        System.out.println("Sparrow is flying high.");
    }
}

// Penguin không triển khai hành vi bay.
class PenguinV2 extends BirdV2 {
    public void swim() {
        System.out.println("Penguin is swimming.");
    }
}

class BirdSanctuaryV2 {
    // Method này bây giờ chỉ chấp nhận những con chim được ĐẢM BẢO có thể bay.
    // Nó không còn cần xử lý lỗi. Hợp đồng đã rõ ràng.
    public void makeBirdsFly(List<FlyingBird> flyingBirds) {
        for (FlyingBird bird : flyingBirds) {
            bird.fly();
        }
    }
}
```
Thiết kế mới này mạnh mẽ và tuân thủ LSP. Mã client cần hành vi bay sẽ yêu cầu một `FlyingBird`, và mã hoạt động với bất kỳ con chim nào sẽ yêu cầu một `BirdV2`. Không còn kỳ vọng bị phá vỡ.

---

#### **3. Bài tập nhỏ**

Bạn đang thiết kế một hệ thống để quản lý tài khoản người dùng. Bạn có một lớp `PremiumUser` kế thừa từ một lớp `User`.

Lớp `User` có một method `accessFreeContent()`.
Lớp `PremiumUser` cũng có một method `accessPremiumContent()`.

Bây giờ, hãy xem xét một method trong lớp `User` được gọi là `submitReview()`. Quy tắc là bất kỳ người dùng nào cũng có thể gửi đánh giá.

Một yêu cầu mới xuất hiện: "Người dùng miễn phí có thể gửi đánh giá, nhưng chúng sẽ được giữ lại để kiểm duyệt. Đánh giá của người dùng Premium được đăng ngay lập tức." Một nhà phát triển triển khai điều này bằng cách ghi đè `submitReview()` trong lớp `PremiumUser`.

Tuy nhiên, một nhà phát triển khác triển khai `submitReview()` trong lớp `User` để ném ra một `AccountNotActiveException` nếu tài khoản của người dùng bị tạm ngưng.

Liệu việc triển khai `submitReview()` của `PremiumUser` có khả năng vi phạm LSP về mặt xử lý ngoại lệ không? Giải thích tại sao có hoặc tại sao không. Có cách nào tốt hơn để thiết kế điều này không?

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều nào sau đây là vi phạm trực tiếp nhất của Nguyên tắc thay thế Liskov?

A) Một lớp con thêm một method public mới không có trong lớp cha.
B) Một method của lớp con ghi đè một method của lớp cha nhưng chấp nhận một loại tham số chung hơn.
C) Một method của lớp con ghi đè một method của lớp cha và ném ra một `Exception` được kiểm tra mới mà method của lớp cha không khai báo.
D) Một method của lớp con ghi đè một method của lớp cha và có một access modifier hạn chế hơn (ví dụ: ghi đè một method `public` bằng một method `protected`).

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Một method của lớp con ghi đè một method của lớp cha và ném ra một `Exception` được kiểm tra mới mà method của lớp cha không khai báo. Mã client được viết để xử lý lớp cha sẽ không được chuẩn bị để bắt ngoại lệ mới này, phá vỡ "khả năng thay thế" của lớp con. Lựa chọn D là vi phạm các quy tắc ghi đè của Java và sẽ không biên dịch được ngay từ đầu. Lựa chọn A là hoàn toàn ổn (mở rộng). Lựa chọn B liên quan đến chữ ký của method và sẽ được coi là một nạp chồng, không phải ghi đè.

### **Bài 10: Nguyên tắc SOLID - Nguyên tắc Phân tách Interface (ISP)**

#### **1. Giải thích khái niệm**

Nguyên tắc SOLID thứ tư là **Interface Segregation Principle (ISP)**.

**Nguyên tắc:** *Các client không nên bị buộc phải phụ thuộc vào các interface mà chúng không sử dụng.*

Nguyên tắc này giải quyết vấn đề của các interface "béo" hoặc "bị ô nhiễm". Một interface béo là một interface lớn, duy nhất chứa nhiều method phục vụ các mục đích khác nhau. Nếu một lớp chỉ cần thực hiện một trong những mục đích đó, nó bị buộc phải triển khai toàn bộ interface, thường để lại nhiều method trống hoặc ném ra ngoại lệ.

ISP khuyên rằng tốt hơn là nên chia nhỏ các interface lớn thành các interface nhỏ hơn, cụ thể hơn, mỗi cái được thiết kế cho một client hoặc vai trò cụ thể. Chúng thường được gọi là "role interfaces".

**Ví dụ tương tự:** Hãy tưởng tượng một thực đơn nhà hàng là một cuốn sách 50 trang duy nhất chứa bữa sáng, bữa trưa, bữa tối, đồ uống và món tráng miệng. Nếu bạn chỉ muốn gọi một ly cà phê, bạn vẫn được đưa cuốn sách khổng lồ, cồng kềnh này. Sẽ tốt hơn nhiều nếu có các thực đơn nhỏ hơn, riêng biệt: một thực đơn đồ uống, một thực đơn món tráng miệng, v.v. Bạn chỉ được đưa những gì bạn cần.

**Lợi ích cốt lõi của ISP:**
*   **Gắn kết cao & Liên kết lỏng lẻo:** Các interface tập trung và gắn kết hơn. Các lớp chỉ liên kết với các method mà chúng thực sự quan tâm.
*   **Cải thiện khả năng đọc và bảo trì:** Các interface nhỏ hơn dễ hiểu hơn. Các thay đổi đối với một role interface không ảnh hưởng đến các client không sử dụng nó.
*   **Tránh các triển khai "rỗng":** Các lớp không còn bị buộc phải triển khai các method không liên quan đến chúng, dẫn đến mã sạch hơn.

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm ISP**
Ở đây chúng ta có một interface béo, duy nhất cho một `Machine`. Một máy in đa chức năng hiện đại có thể làm mọi thứ, nhưng một máy in cũ đơn giản không thể quét hoặc fax.

```java
// VI PHẠM ISP: Một interface "béo"
interface Machine {
    void print(Document d);
    void scan(Document d);
    void fax(Document d);
}

// Lớp này ổn, vì nó có thể thực hiện tất cả các chức năng.
class MultiFunctionPrinter implements Machine {
    public void print(Document d) { /* ... */ }
    public void scan(Document d) { /* ... */ }
    public void fax(Document d) { /* ... */ }
}

// Lớp này bị buộc phải triển khai các method mà nó không thể hỗ trợ.
class OldFashionedPrinter implements Machine {
    public void print(Document d) {
        // Đây là method duy nhất có ý nghĩa.
        System.out.println("Printing document...");
    }

    public void scan(Document d) {
        // Vấn đề: Máy in này không thể quét.
        throw new UnsupportedOperationException("Scan not supported.");
    }

    public void fax(Document d) {
        // Vấn đề: Máy in này không thể fax.
        throw new UnsupportedOperationException("Fax not supported.");
    }
}
```

##### **Ví dụ tốt: Tuân thủ ISP**
Chúng ta phân tách interface `Machine` béo thành các interface nhỏ hơn, theo vai trò cụ thể.

```java
// 1. Phân tách interface thành các vai trò nhỏ hơn, gắn kết hơn.
interface Printer {
    void print(Document d);
}

interface Scanner {
    void scan(Document d);
}

interface Fax {
    void fax(Document d);
}

// 2. Các lớp bây giờ chỉ triển khai các interface mà chúng cần.

// Một MultiFunctionDevice có thể bao gồm nhiều vai trò.
class ModernPrinter implements Printer, Scanner {
    public void print(Document d) { /* ... */ }
    public void scan(Document d) { /* ... */ }
}

// Một OldFashionedPrinter chỉ cần là một Printer.
// Nó không còn bị buộc phải biết về việc quét hoặc fax.
class SimplePrinter implements Printer {
    public void print(Document d) {
        System.out.println("Printing document...");
    }
}

// 3. Mã client bây giờ có thể phụ thuộc vào abstraction cụ thể mà nó cần.
class PrintManager {
    private final Printer printer;

    public PrintManager(Printer printer) {
        this.printer = printer;
    }

    public void executePrintJob(Document d) {
        printer.print(d); // Trình quản lý này chỉ quan tâm đến việc in.
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn đang thiết kế một interface cho một đối tượng truy cập dữ liệu (DAO) sẽ tương tác với cơ sở dữ liệu. Một nhà phát triển đã tạo ra interface béo sau:

```java
interface DataAccess {
    void create(Object entity);
    Object read(int id);
    void update(Object entity);
    void delete(int id);
    List<Object> searchByQuery(String query);
}
```
Điều này vi phạm ISP vì một số client có thể chỉ cần đọc dữ liệu (ví dụ: một dịch vụ báo cáo), trong khi những client khác có thể chỉ ghi (ví dụ: một dịch vụ ghi log).

Nhiệm vụ của bạn là tái cấu trúc thiết kế này.
1.  Chia interface `DataAccess` thành các role interface nhỏ hơn, logic hơn. Một mẫu phổ biến cho việc này là CRUD (Create, Read, Update, Delete).
2.  Tạo một lớp `ReadOnlyRepository` chỉ cần triển khai chức năng đọc/tìm kiếm.
3.  Tạo một lớp `FullAccessRepository` triển khai tất cả các chức năng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Nhóm của bạn có một interface được gọi là `UserActions` với các method `viewProfile()`, `editProfile()`, `changePassword()`, và `deleteAccount()`. Bạn cần triển khai một lớp `GuestUser` chỉ có thể xem hồ sơ. Cách tiếp cận nào là tốt nhất theo ISP?

A) Triển khai interface `UserActions` trong `GuestUser` và để các method `editProfile`, `changePassword`, và `deleteAccount` ném ra một `AccessDeniedException`.
B) Tạo một interface mới `ProfileViewer` chỉ có method `viewProfile()`, và để `GuestUser` triển khai nó.
C) Biến interface `UserActions` thành một abstract class để `GuestUser` có thể kế thừa chỉ các method mà nó cần.
D) Không sử dụng một interface và chỉ triển khai method `viewProfile()` trực tiếp trong lớp `GuestUser`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Tạo một interface mới `ProfileViewer` chỉ có method `viewProfile()`, và để `GuestUser` triển khai nó. Đây là ứng dụng kinh điển của ISP. Nó phân tách interface béo `UserActions` thành một interface nhỏ hơn, theo vai trò cụ thể mà client (`GuestUser`) thực sự cần, mà không buộc nó phải phụ thuộc vào các method mà nó không sử dụng.

### **Bài 11: Nguyên tắc SOLID - Nguyên tắc Đảo ngược Phụ thuộc (DIP)**

#### **1. Giải thích khái niệm**

Đây là nguyên tắc cuối cùng trong từ viết tắt SOLID: **Dependency Inversion Principle (DIP)**. Nó được cho là có tác động lớn nhất để tạo ra các hệ thống tách rời, linh hoạt và dễ kiểm thử.

**Nguyên tắc (gồm hai phần):**
1.  *Các mô-đun cấp cao không nên phụ thuộc vào các mô-đun cấp thấp. Cả hai nên phụ thuộc vào các abstraction (ví dụ: interface).*
2.  *Các abstraction không nên phụ thuộc vào các chi tiết. Các chi tiết (triển khai cụ thể) nên phụ thuộc vào các abstraction.*

Hãy phân tích điều này:
*   **Mô-đun cấp cao:** Đây là các phần của ứng dụng của bạn chứa logic nghiệp vụ và chính sách cốt lõi. Chúng đại diện cho **"cái gì"** ứng dụng của bạn làm (ví dụ: một dịch vụ `ReportGenerator`).
*   **Mô-đun cấp thấp:** Đây là các phần xử lý các chi tiết triển khai và cơ sở hạ tầng. Chúng đại diện cho **"làm thế nào"** mọi thứ được thực hiện (ví dụ: một `DatabaseReader` hoặc một `FileSystemWriter`).

Một thiết kế truyền thống, liên kết chặt chẽ có mô-đun cấp cao trực tiếp tạo và gọi mô-đun cấp thấp.
`ReportGenerator` → `DatabaseReader`

Điều này tạo ra một hệ thống cứng nhắc. Nếu bạn muốn thay đổi nguồn dữ liệu từ cơ sở dữ liệu sang API web, bạn phải sửa đổi `ReportGenerator`. Điều này vi phạm Nguyên tắc Đóng/Mở.

DIP "đảo ngược" sự phụ thuộc này. Thay vì mô-đun cấp cao phụ thuộc vào mô-đun cấp thấp, **cả hai** đều phụ thuộc vào một abstraction (một interface) thường được định nghĩa bởi mô-đun cấp cao.

`ReportGenerator` → `IDataSource` ← `DatabaseReader`

Mũi tên từ `DatabaseReader` đến `IDataSource` biểu thị rằng việc triển khai cụ thể bây giờ "phụ thuộc" vào (triển khai) abstraction được định nghĩa bởi mô-đun cấp cao. Sự phụ thuộc đã được đảo ngược.

**Ví dụ tương tự:** Một ổ cắm điện trên tường và một cái đèn. Cái đèn (mô-đun cấp cao) không phụ thuộc vào nhà máy điện cụ thể (mô-đun cấp thấp) tạo ra điện. Thay vào đó, cả cái đèn và nhà máy điện đều phụ thuộc vào một abstraction chung: đặc tả ổ cắm tường tiêu chuẩn (điện áp, hình dạng phích cắm). Cái đèn có thể được cắm vào bất kỳ ổ cắm nào tuân thủ tiêu chuẩn này, và bất kỳ nguồn điện nào cũng có thể cung cấp điện cho nó. Sự phụ thuộc là vào hợp đồng trừu tượng, không phải vào việc triển khai cụ thể.

**DIP và Dependency Injection (DI):**
DIP là **nguyên tắc**. Dependency Injection là một **design pattern** phổ biến được sử dụng để triển khai nó. DI là quá trình cung cấp cho một lớp các phụ thuộc của nó từ một nguồn bên ngoài, thay vì để lớp tự tạo chúng. Điều này thường được thực hiện thông qua constructor injection, setter injection, hoặc thông qua một DI framework như Spring.

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm DIP**
`PasswordManager` cấp cao được liên kết trực tiếp với `FileSystemRepository` cấp thấp. Nó không thể tái sử dụng với một cơ chế lưu trữ khác và khó kiểm thử nếu không có hệ thống tệp thực sự.

```java
// VI PHẠM DIP

// Mô-đun cấp thấp
class FileSystemRepository {
    public void save(String password) {
        // ... logic để ghi mật khẩu vào một tệp ...
        System.out.println("Saved to file: " + password);
    }
}

// Mô-đun cấp cao
class PasswordManager {
    // Phụ thuộc trực tiếp vào một mô-đun cấp thấp cụ thể
    private final FileSystemRepository repository;

    public PasswordManager() {
        this.repository = new FileSystemRepository(); // LIÊN KẾT CHẶT CHẼ
    }

    public void savePassword(String password) {
        repository.save(password);
    }
}
```

##### **Ví dụ tốt: Tuân thủ DIP**
Chúng ta giới thiệu một interface (`PasswordRepository`) mà `PasswordManager` phụ thuộc vào. Cơ chế lưu trữ cụ thể được "tiêm" từ bên ngoài.

```java
// 1. Định nghĩa abstraction (hợp đồng). Điều này thuộc sở hữu của tầng cấp cao.
interface PasswordRepository {
    void save(String password);
}

// 2. Mô-đun cấp thấp bây giờ phụ thuộc vào abstraction.
class FileSystemRepositoryImpl implements PasswordRepository {
    @Override
    public void save(String password) {
        System.out.println("Saved to file: " + password);
    }
}

// Chúng ta có thể dễ dàng thêm một triển khai khác.
class DatabaseRepositoryImpl implements PasswordRepository {
    @Override
    public void save(String password) {
        System.out.println("Saved to database: " + password);
    }
}

// 3. Mô-đun cấp cao chỉ phụ thuộc vào abstraction.
class PasswordManagerV2 {
    // Sự phụ thuộc là vào interface, không phải lớp cụ thể.
    private final PasswordRepository repository;

    // Sự phụ thuộc được "tiêm" qua constructor.
    public PasswordManagerV2(PasswordRepository repository) {
        this.repository = repository;
    }

    public void savePassword(String password) {
        repository.save(password);
    }
}

// Ứng dụng chính kết nối mọi thứ lại với nhau (Vai trò "Assembler" hoặc "DI Container")
class Application {
    public static void main(String[] args) {
        // Chúng ta có thể chọn việc triển khai tại runtime.
        PasswordRepository repo = new DatabaseRepositoryImpl();
        PasswordManagerV2 manager = new PasswordManagerV2(repo);
        manager.savePassword("mySecret123");
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một lớp `ContentCopier` đọc từ bàn phím và ghi ra máy in. Đây là một ví dụ kinh điển về liên kết chặt chẽ.

```java
// Chính sách cấp cao: Sao chép nội dung
public class ContentCopier {
    public void copy() {
        KeyboardReader reader = new KeyboardReader();
        PrinterWriter writer = new PrinterWriter();
        String input = reader.read();
        writer.write(input);
    }
}
```

Nhiệm vụ của bạn là tái cấu trúc `ContentCopier` này để tuân theo DIP.
1.  Định nghĩa hai abstraction (interface): `IReader` và `IWriter`.
2.  Sửa đổi `ContentCopier` để nó phụ thuộc vào các interface này, nhận chúng trong constructor của nó.
3.  Tạo các triển khai cụ thể `KeyboardReader` và `PrinterWriter` triển khai các interface mới này.
4.  Chỉ ra cách việc tái cấu trúc này làm cho việc tạo ra một `ContentCopier` sao chép từ một `FileReader` sang một `FileWriter` trở nên tầm thường mà không cần thay đổi chính lớp `ContentCopier`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào sau đây mô tả đúng nhất mối quan hệ giữa Dependency Inversion (DIP) và Dependency Injection (DI)?

A) Chúng là hai khái niệm hoàn toàn không liên quan.
B) Chúng là một; các tên có thể thay thế cho nhau.
C) DIP là một nguyên tắc thiết kế, trong khi DI là một design pattern được sử dụng để đạt được nguyên tắc đó.
D) DI là một nguyên tắc thiết kế, và DIP là pattern được sử dụng để triển khai nó.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) DIP là một nguyên tắc thiết kế, trong khi DI là một design pattern được sử dụng để đạt được nguyên tắc đó. Nguyên tắc (DIP) nói *bạn nên làm gì* (phụ thuộc vào abstraction), và pattern (DI) cung cấp một cơ chế để *bạn có thể làm điều đó như thế nào* (bằng cách có các phụ thuộc được cung cấp từ một nguồn bên ngoài).

### **Bài 12: Nguyên tắc thiết kế - DRY, KISS, và YAGNI**

#### **1. Giải thích khái niệm**

Bài học này bao gồm một bộ ba nguyên tắc thiết kế thực dụng hoạt động như những triết lý chỉ đạo cho việc viết mã hàng ngày. Trong khi các nguyên tắc SOLID tập trung vào cấu trúc của các hệ thống hướng đối tượng, các nguyên tắc này hướng dẫn tư duy và cách tiếp cận để viết các dòng và khối mã riêng lẻ.

##### **Don't Repeat Yourself (DRY)**

*   **Nguyên tắc:** *Mọi mẩu kiến thức phải có một đại diện duy nhất, không mơ hồ, có thẩm quyền trong một hệ thống.*
*   **Trong thực tế:** Điều này thường được hiểu là "đừng sao chép và dán mã." Nếu bạn thấy mình viết cùng một khối logic ở nhiều nơi, bạn đang vi phạm DRY. Vấn đề với mã bị trùng lặp là nếu một lỗi được tìm thấy hoặc một yêu cầu thay đổi, bạn phải nhớ sửa nó ở *mọi nơi*. Việc quên dù chỉ một chỗ cũng dẫn đến một hệ thống không nhất quán và có lỗi.
*   **Giải pháp:** Abstraction. Tập trung hóa logic bị trùng lặp vào một nơi duy nhất, chẳng hạn như một method mới, một lớp trợ giúp, hoặc một lớp cơ sở, và để tất cả các vị trí khác gọi nguồn chân lý duy nhất này.
*   **Cạm bẫy (Trùng lặp tình cờ):** Hãy cẩn thận khi trừu tượng hóa mã *trông* giống nhau bây giờ nhưng lại đại diện cho các khái niệm nghiệp vụ khác nhau. Việc ép chúng vào một abstraction duy nhất có thể tạo ra một vấn đề tồi tệ hơn nếu sau này chúng cần phát triển độc lập.

##### **Keep It Simple, Stupid (KISS)**

*   **Nguyên tắc:** *Hầu hết các hệ thống hoạt động tốt nhất nếu chúng được giữ đơn giản thay vì làm phức tạp; do đó, sự đơn giản nên là một mục tiêu chính trong thiết kế, và sự phức tạp không cần thiết nên được tránh.*
*   **Trong thực tế:** Luôn chọn giải pháp đơn giản nhất giải quyết vấn đề một cách hiệu quả. Tránh thiết kế quá mức (over-engineering). Đừng sử dụng một design pattern phức tạp nếu một câu lệnh điều kiện đơn giản là đủ. Đừng viết mã thông minh, khó hiểu mà người khác (hoặc chính bạn trong tương lai) khó hiểu.
*   **Ví dụ tương tự:** Nếu bạn cần đóng một cái đinh, hãy dùng một cái búa. Đừng xây dựng một cỗ máy đóng đinh tự động, dẫn đường bằng laser phức tạp. Công cụ đơn giản nhất thường là tốt nhất.
*   **Mục tiêu:** Mã dễ đọc, dễ hiểu và dễ bảo trì. Sự đơn giản làm giảm gánh nặng nhận thức cho các nhà phát triển và làm cho hệ thống ít bị lỗi hơn.

##### **You Ain't Gonna Need It (YAGNI)**

*   **Nguyên tắc:** *Luôn triển khai mọi thứ khi bạn thực sự cần chúng, không bao giờ khi bạn chỉ dự đoán rằng bạn sẽ cần chúng.*
*   **Trong thực tế:** Nguyên tắc này chống lại sự cám dỗ của nhà phát triển muốn thêm chức năng dựa trên suy đoán về tương lai. Việc xây dựng các tính năng không được yêu cầu bởi bộ user story hoặc nhiệm vụ hiện tại sẽ thêm sự phức tạp không cần thiết và tốn thời gian phát triển có thể được dành cho các yêu cầu thực sự.
*   **Ví dụ tương tự:** Đóng gói hành lý cho một chuyến đi. YAGNI giống như chỉ đóng gói những gì bạn biết mình sẽ cần cho điểm đến của mình. Ngược lại là đóng gói một chiếc áo khoác mùa đông, một bộ đồ bơi, và đồ đi bộ đường dài "chỉ để đề phòng", làm cho vali của bạn nặng và cồng kềnh cho một chuyến công tác đơn giản đến thành phố.
*   **Mục tiêu:** Tiết kiệm thời gian và công sức, và giữ cho cơ sở mã gọn gàng và tập trung vào việc cung cấp giá trị kinh doanh thực tế. Nó củng cố nguyên tắc KISS bằng cách ngăn chặn sự phức tạp do suy đoán.

---

#### **2. Ví dụ mã nguồn**

##### **Trước: Vi phạm DRY, KISS, và YAGNI**
Mã này xác thực và xử lý hai loại đơn hàng khác nhau. Logic xác thực bị trùng lặp (vi phạm DRY). Mã cũng phức tạp hơn một chút so với cần thiết và bao gồm một tính năng ghi log suy đoán (vi phạm KISS và YAGNI).

```java
// VI PHẠM CÁC NGUYÊN TẮC
public class OrderProcessor {

    // Method cho đơn hàng của khách hàng thông thường
    public void processCustomerOrder(List<Product> products) {
        // --- LOGIC TRÙNG LẶP BẮT ĐẦU ---
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return;
            }
        }
        // --- LOGIC TRÙNG LẶP KẾT THÚC ---

        // Tính năng suy đoán: có thể sau này chúng ta sẽ cần ghi log XML? (YAGNI)
        logToXmlFile(products);

        System.out.println("Processing customer order...");
        // ... logic xử lý ...
    }

    // Method cho đơn hàng kinh doanh nội bộ
    public void processBusinessOrder(List<Product> products) {
        // --- LOGIC TRÙNG LẶP BẮT ĐẦU ---
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return;
            }
        }
        // --- LOGIC TRÙNG LẶP KẾT THÚC ---

        System.out.println("Processing business order...");
        // ... logic xử lý ...
    }

    private void logToXmlFile(List<Product> products) {
        // Tính năng này chưa được yêu cầu.
        System.out.println("Speculative logging to XML...");
    }
}
```

##### **Sau: Tuân thủ các nguyên tắc**
Mã được tái cấu trúc để đơn giản và dễ bảo trì hơn.

```java
// TUÂN THỦ CÁC NGUYÊN TẮC
public class OrderProcessorV2 {

    // Method trợ giúp private để tập trung hóa việc xác thực (DRY)
    private boolean isOrderValid(List<Product> products) {
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return false;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return false;
            }
        }
        return true;
    }

    // Các method public được đơn giản hóa (KISS)
    public void processCustomerOrder(List<Product> products) {
        if (!isOrderValid(products)) {
            return;
        }
        System.out.println("Processing customer order...");
        // ... logic xử lý ...
    }

    public void processBusinessOrder(List<Product> products) {
        if (!isOrderValid(products)) {
            return;
        }
        System.out.println("Processing business order...");
        // ... logic xử lý ...
    }

    // Method logToXmlFile suy đoán đã được xóa hoàn toàn (YAGNI).
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một lớp với hai method: một để xuất dữ liệu người dùng ra tệp CSV và một để xuất dữ liệu bài viết ra tệp CSV.

```java
public class DataExporter {
    public void exportUsersToCsv(List<User> users) {
        // Bước 1: Mở một file stream
        System.out.println("Opening file 'users.csv'...");
        // Bước 2: Ghi dòng tiêu đề
        System.out.println("Writing header: ID,Name,Email");
        // Bước 3: Lặp qua người dùng và định dạng mỗi người thành một dòng CSV
        for (User user : users) {
            System.out.println(user.getId() + "," + user.getName() + "," + user.getEmail());
        }
        // Bước 4: Đóng file stream
        System.out.println("Closing file.");
    }

    public void exportArticlesToCsv(List<Article> articles) {
        // Bước 1: Mở một file stream
        System.out.println("Opening file 'articles.csv'...");
        // Bước 2: Ghi dòng tiêu đề
        System.out.println("Writing header: ID,Title,Author");
        // Bước 3: Lặp qua các bài viết và định dạng mỗi bài thành một dòng CSV
        for (Article article : articles) {
            System.out.println(article.getId() + "," + article.getTitle() + "," + article.getAuthor());
        }
        // Bước 4: Đóng file stream
        System.out.println("Closing file.");
    }
}
```

Mã này vi phạm DRY. Logic để mở/đóng tệp và lặp bị trùng lặp. Nhiệm vụ của bạn là tái cấu trúc điều này.
1.  Tạo một interface `CsvExportable` với hai method: `getCsvHeader()` và `toCsvRow()`.
2.  Làm cho các lớp `User` và `Article` triển khai interface mới này.
3.  Tạo một method chung, duy nhất `exportToCsv(List<? extends CsvExportable> items, String filename)` chứa logic được chia sẻ và sử dụng các method của interface để lấy dữ liệu cụ thể.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Một nhà phát triển đang xây dựng một trang hồ sơ người dùng. Họ quyết định thêm một tính năng tùy chỉnh avatar thời gian thực phức tạp bằng WebGL, mặc dù yêu cầu của dự án chỉ yêu cầu một chức năng tải lên hình ảnh đơn giản. Nhà phát triển lập luận, "Khách hàng có thể sẽ yêu cầu điều này trong tương lai." Nhà phát triển đang vi phạm rõ ràng nhất nguyên tắc nào?

A) DRY (Don't Repeat Yourself)
B) KISS (Keep It Simple, Stupid)
C) YAGNI (You Ain't Gonna Need It)
D) Cả B và C

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Cả B và C. Đây là một vi phạm chính của YAGNI vì tính năng này hoàn toàn là suy đoán và hiện tại không cần thiết. Nó cũng là một vi phạm của KISS vì họ đang chọn một giải pháp rất phức tạp (trình chỉnh sửa WebGL) thay vì giải pháp đơn giản được yêu cầu (tải lên hình ảnh), thêm sự phức tạp không cần thiết vào hệ thống.

### **Bài 13: Cohesion và Coupling**

#### **1. Giải thích khái niệm**

Cohesion và Coupling là hai trong số những khái niệm cơ bản nhất trong thiết kế phần mềm, có trước cả lập trình hướng đối tượng. Chúng là các số liệu được sử dụng để đánh giá một mô-đun (một class, một package, một microservice) được thiết kế tốt đến đâu. Mục tiêu chung là đạt được **High Cohesion** và **Low Coupling**.

##### **Cohesion (Thước đo "sự liên quan" *bên trong* một mô-đun)**

Cohesion đo lường mức độ liên quan và tập trung của các trách nhiệm của một mô-đun duy nhất.

*   **High Cohesion (Tốt):** Một mô-đun có cohesion cao có một mục đích rõ ràng, duy nhất. Tất cả các yếu tố của nó (method, thuộc tính) hoạt động cùng nhau để đạt được một mục tiêu đó. Đây là một hệ quả trực tiếp của việc tuân theo **Single Responsibility Principle**.
    *   **Ví dụ tương tự:** Một hộp dụng cụ được tổ chức tốt, trong đó ngăn trên cùng chỉ chứa tua vít, ngăn giữa chỉ chứa cờ lê, và ngăn dưới cùng chỉ chứa búa. Mỗi ngăn có cohesion rất cao.
    *   **Lợi ích:** Dễ hiểu, dễ bảo trì và dễ tái sử dụng hơn.

*   **Low Cohesion (Xấu):** Một mô-đun có cohesion thấp làm nhiều việc không liên quan. Các trách nhiệm của nó bị phân tán và không tập trung. Đây là một đặc điểm của một "God Object".
    *   **Ví dụ tương tự:** Một ngăn kéo lộn xộn nơi bạn tìm thấy tua vít, pin, chìa khóa cũ, dây thun, và gói sốt cà chua tất cả trộn lẫn với nhau. Ngăn kéo có cohesion rất thấp.
    *   **Vấn đề:** Khó hiểu, khó bảo trì (một thay đổi trong một trách nhiệm có thể làm hỏng một trách nhiệm khác), và không thể tái sử dụng.

##### **Coupling (Thước đo "sự phụ thuộc" *giữa* các mô-đun)**

Coupling đo lường mức độ mà một mô-đun phụ thuộc vào một mô-đun khác.

*   **Low Coupling (Tốt / Loose Coupling):** Các mô-đun phần lớn độc lập. Một thay đổi trong một mô-đun có ít hoặc không có tác động đến các mô-đun khác. Chúng giao tiếp thông qua các interface (abstraction) ổn định, được xác định rõ ràng. Đây là một hệ quả trực tiếp của việc tuân theo **Dependency Inversion Principle** và **Open/Closed Principle**.
    *   **Ví dụ tương tự:** Một cổng USB. Máy tính của bạn (mô-đun A) không liên kết chặt chẽ với bàn phím của bạn (mô-đun B). Bạn có thể đổi bất kỳ bàn phím nào cho một bàn phím khác miễn là nó sử dụng giao diện USB tiêu chuẩn. Máy tính không cần biết các chi tiết nội bộ về cách bàn phím được sản xuất.
    *   **Lợi ích:** Thúc đẩy tính linh hoạt, khả năng mở rộng, và kiểm thử dễ dàng hơn (các mô-đun có thể được kiểm thử độc lập).

*   **High Coupling (Xấu / Tight Coupling):** Các mô-đun phụ thuộc nhiều vào các chi tiết triển khai nội bộ của nhau. Một thay đổi trong một mô-đun thường yêu cầu một chuỗi các thay đổi trong các mô-đun khác.
    *   **Ví dụ tương tự:** Hàn dây của một bàn phím cụ thể trực tiếp vào bo mạch chủ của máy tính. Bây giờ chúng được liên kết chặt chẽ. Nếu bàn phím bị hỏng, bạn phải thực hiện một cuộc phẫu thuật lớn trên bo mạch chủ để sửa chữa hoặc thay thế nó.
    *   **Vấn đề:** Tạo ra một hệ thống "ngôi nhà bằng lá bài" nơi các thay đổi là rủi ro và khó khăn. Giảm khả năng tái sử dụng và làm cho việc phát triển song song trở nên khó khăn hơn.

##### **Sự cân bằng và mối quan hệ**

Mục tiêu luôn là **HIGH COHESION** và **LOW COUPLING**.
*   Tuân theo SRP dẫn đến **high cohesion**.
*   Tuân theo DIP và OCP dẫn đến **low coupling**.

Hai khái niệm này hoạt động cùng nhau. Bằng cách chia một hệ thống thành các mô-đun nhỏ, có cohesion cao (mỗi mô-đun có một trách nhiệm duy nhất), bạn làm cho việc quản lý các phụ thuộc giữa chúng trở nên dễ dàng hơn, điều này tự nhiên dẫn đến coupling thấp hơn.

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Low Cohesion và High Coupling**

```java
// LOW COHESION: Lớp này làm mọi thứ - logic nghiệp vụ, truy cập dữ liệu, định dạng.
// HIGH COUPLING: ReportGenerator liên kết chặt chẽ với MySqlConnection.
class ReportGenerator {
    private MySqlConnection dbConnection; // Phụ thuộc trực tiếp vào một lớp cụ thể

    public ReportGenerator() {
        // Mô-đun cấp cao tạo ra mô-đun cấp thấp.
        this.dbConnection = new MySqlConnection("connection_string");
    }

    // Một sự pha trộn của các trách nhiệm không liên quan...
    public List<User> fetchUsersFromDatabase() {
        // ... logic để truy vấn người dùng ...
        return dbConnection.query("SELECT * FROM users");
    }

    public String formatReportAsHtml(List<User> users) {
        // ... logic để tạo một bảng HTML ...
        return "<html>...</html>";
    }

    public void emailReport(String htmlReport) {
        // ... logic để kết nối với một máy chủ SMTP và gửi email ...
    }
}
```

##### **Ví dụ tốt: High Cohesion và Low Coupling**

```java
// --- HIGH COHESION: Mỗi lớp có một trách nhiệm duy nhất, được xác định rõ ràng. ---

// 1. Đối tượng dữ liệu người dùng (POJO)
class User { /* ... */ }

// 2. Abstraction cho việc truy cập dữ liệu
interface UserRepository {
    List<User> findAll();
}

// 3. Triển khai truy cập dữ liệu cấp thấp
class MySqlUserRepository implements UserRepository {
    @Override
    public List<User> findAll() { /* ... logic truy vấn ... */ return null; }
}

// 4. Định dạng báo cáo
class HtmlFormatter {
    public String format(List<User> users) { /* ... logic định dạng ... */ return ""; }
}

// 5. Gửi email
class EmailService {
    public void send(String content) { /* ... logic email ... */ }
}

// --- LOW COUPLING: Lớp chính phụ thuộc vào abstraction, không phải triển khai cụ thể. ---
class ReportService {
    private final UserRepository repository; // Phụ thuộc vào interface
    private final HtmlFormatter formatter;     // Phụ thuộc vào lớp cụ thể (cũng có thể được trừu tượng hóa!)
    private final EmailService emailer;       // Phụ thuộc vào lớp cụ thể

    // Các phụ thuộc được tiêm vào (DIP)
    public ReportService(UserRepository repository, HtmlFormatter formatter, EmailService emailer) {
        this.repository = repository;
        this.formatter = formatter;
        this.emailer = emailer;
    }

    public void generateAndSendReport() {
        List<User> users = repository.findAll();
        String htmlReport = formatter.format(users);
        emailer.send(htmlReport);
    }
}
```

---

#### **3. Bài tập nhỏ**

Phân tích lớp `OrderManager` sau.
1.  Xác định các trách nhiệm khác nhau của nó. Nó có cohesion cao không?
2.  Xác định các phụ thuộc trực tiếp của nó. Nó là liên kết lỏng lẻo hay chặt chẽ?
3.  Tái cấu trúc lớp thành các lớp nhỏ hơn, có cohesion cao hơn và liên kết lỏng lẻo. Định nghĩa các interface cho các phụ thuộc và sử dụng constructor injection.

```java
public class OrderManager {
    public void processOrder(Order order) {
        // Trách nhiệm 1: Xác thực đơn hàng
        if (order.getItems().isEmpty()) {
            System.out.println("Order is invalid.");
            return;
        }

        // Trách nhiệm 2: Xử lý thanh toán với một dịch vụ cụ thể
        StripePaymentGateway gateway = new StripePaymentGateway();
        gateway.charge(order.getTotal());

        // Trách nhiệm 3: Cập nhật kho hàng trong một cơ sở dữ liệu cụ thể
        MySqlDatabase db = new MySqlDatabase();
        for (Item item : order.getItems()) {
            db.execute("UPDATE inventory SET stock = stock - 1 WHERE id = " + item.getId());
        }

        // Trách nhiệm 4: Gửi email xác nhận
        System.out.println("Sending email to " + order.getCustomerEmail());
    }
}
```

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Nếu việc sửa đổi lớp `A` thường xuyên buộc bạn phải thay đổi lớp `B`, điều này ngụ ý gì về mối quan hệ giữa `A` và `B`?

A) Chúng có cohesion thấp.
B) Chúng có coupling cao.
C) Chúng có cohesion cao.
D) Chúng có coupling thấp.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Chúng có coupling cao. Liên kết chặt chẽ có nghĩa là những thay đổi trong một mô-đun lan truyền và yêu cầu những thay đổi trong các mô-đun phụ thuộc khác. Đây là triệu chứng kinh điển của một thiết kế có coupling cao.

### **Bài 14: Encapsulation vs. Data Hiding & Luật Demeter**

#### **1. Giải thích khái niệm**

Bài học này làm rõ hai khái niệm liên quan chặt chẽ điều chỉnh cách các object nên bảo vệ trạng thái của chúng và tương tác với nhau để duy trì coupling thấp.

##### **Encapsulation vs. Data Hiding**

Các thuật ngữ này thường được sử dụng thay thế cho nhau, nhưng chúng có ý nghĩa riêng biệt.

*   **Encapsulation** là **cơ chế** gộp dữ liệu (field) và các method hoạt động trên dữ liệu đó vào một đơn vị duy nhất (một class). Đó là một khái niệm cấu trúc. Bạn có thể có một lớp được đóng gói hoàn toàn với tất cả các field và method của nó là `public`.

*   **Data Hiding** là **nguyên tắc** che giấu trạng thái nội bộ và các chi tiết triển khai của một object khỏi thế giới bên ngoài. Mục tiêu là ngăn chặn truy cập trực tiếp, không kiểm soát vào dữ liệu của một object. Điều này đạt được bằng cách áp dụng các access modifier (như `private`) cho các field và chỉ phơi bày trạng thái thông qua các method public (getter/setter).

**Mối quan hệ:** Encapsulation *cho phép* Data Hiding. Đầu tiên bạn gộp mọi thứ lại với nhau (encapsulation), sau đó bạn áp dụng kiểm soát truy cập để ẩn đi các phần bạn không muốn phơi bày (data hiding). Một lớp được thiết kế tốt sử dụng encapsulation để đạt được data hiding.

```java
// Lớp này được ENCAPSULATED. Dữ liệu và các method được gộp lại.
// Tuy nhiên, nó KHÔNG thực hành DATA HIDING vì trường là public.
public class PoorlyDesignedClock {
    public int hour; // Cho phép truy cập trực tiếp
    public void tick() { /* ... */ }
}

// Lớp này vừa ENCAPSULATED vừa thực hành DATA HIDING.
public class WellDesignedClock {
    private int hour; // Truy cập bị hạn chế
    public int getHour() { return hour; } // Truy cập có kiểm soát
    public void tick() { /* ... */ }
}
```

##### **The Law of Demeter (LoD) hoặc Nguyên tắc Kiến thức Tối thiểu**

Nguyên tắc này cung cấp một hướng dẫn cụ thể để xây dựng các hệ thống có coupling lỏng lẻo. Nó thường được tóm tắt là: **"Chỉ nói chuyện với những người bạn trực tiếp của bạn."**

Một method của một object chỉ nên gọi các method thuộc về:
1.  Chính object đó (`this`).
2.  Các object được truyền vào làm tham số cho method.
3.  Bất kỳ object nào nó tạo ra hoặc khởi tạo trực tiếp.
4.  Các object thành phần trực tiếp của object đó (các biến instance của nó).

Nó **không nên** gọi các method trên một object được trả về từ một lời gọi method khác. Điều này là do làm như vậy tạo ra sự phụ thuộc không chỉ vào object bạn đang nói chuyện, mà còn vào cấu trúc nội bộ của object đó.

**Anti-Pattern "Tai nạn tàu hỏa" (Train Wreck):**
Mã vi phạm Luật Demeter thường trông giống như một "tai nạn tàu hỏa" vì có nhiều lời gọi method được nối chuỗi:
`String managerName = employee.getDepartment().getManager().getName();`

Dòng mã này kết nối lớp hiện tại với `Employee`, `Department`, và `Manager`. Nếu lớp `Department` sau này bị thay đổi để không còn có method `getManager()` nữa, mã này sẽ bị hỏng, mặc dù nó chỉ đang cố gắng nói chuyện với một `Employee`.

---

#### **2. Ví dụ mã nguồn**

##### **Ví dụ tồi: Vi phạm Luật Demeter**
Một `Paperboy` cần thu tiền thanh toán từ một `Customer`. `Paperboy` "vươn tay qua" `Customer` để lấy ví của họ và lấy tiền trực tiếp.

```java
// VI PHẠM LoD
class Money { /* ... số tiền ... */ }

class Wallet {
    private Money money;
    public Money getMoney() { return money; }
    public void debit(float amount) { /* ... trừ tiền ... */ }
}

class Customer {
    private Wallet wallet;
    // Phơi bày thành phần nội bộ (cái ví)
    public Wallet getWallet() { return wallet; }
}

class Paperboy {
    public void collectPayment(Customer customer, float paymentAmount) {
        // Đây là một "train wreck" và là một vi phạm của LoD.
        // Paperboy cần biết rằng một Customer có một Wallet.
        Wallet wallet = customer.getWallet();
        wallet.debit(paymentAmount);
        System.out.println("Payment collected successfully.");
    }
}
```

##### **Ví dụ tốt: Tuân thủ Luật Demeter**
`Paperboy` chỉ cần nói cho `Customer` biết nó muốn gì (tiền thanh toán). `Customer` chịu trách nhiệm xử lý logic nội bộ về cách thanh toán được thực hiện.

```java
// TUÂN THỦ LoD
class MoneyV2 { /* ... */ }

class WalletV2 {
    private MoneyV2 money;
    public void debit(float amount) { /* ... */ }
}

class CustomerV2 {
    private WalletV2 wallet;

    // Cấu trúc nội bộ được che giấu.
    // Khách hàng cung cấp một method dịch vụ cấp cao.
    public void makePayment(float amount) {
        // Khách hàng ủy thác lời gọi cho người bạn trực tiếp của mình (cái ví của nó).
        wallet.debit(amount);
    }
}

class PaperboyV2 {
    public void collectPayment(CustomerV2 customer, float paymentAmount) {
        // Chỉ nói chuyện với người bạn trực tiếp của bạn (khách hàng).
        customer.makePayment(paymentAmount);
        System.out.println("Payment collected successfully.");
    }
}
```
Bây giờ lớp `PaperboyV2` không còn liên kết với lớp `WalletV2` nữa. Cấu trúc nội bộ của `CustomerV2` có thể được thay đổi (ví dụ: họ có thể thanh toán từ tài khoản ngân hàng thay vì ví) mà không bao giờ ảnh hưởng đến lớp `PaperboyV2`.

---

#### **3. Bài tập nhỏ**

Bạn có một chiếc `Car` cần kiểm tra áp suất của lốp xe. Mã sau đây vi phạm Luật Demeter.

```java
class Tire {
    private double pressure;
    public double getPressure() { return pressure; }
}

class Wheel {
    private Tire tire;
    public Tire getTire() { return tire; }
}

class Car {
    private List<Wheel> wheels;

    public boolean checkTirePressure() {
        for (Wheel wheel : wheels) {
            // Vi phạm: Vươn qua Wheel để đến Tire
            if (wheel.getTire().getPressure() < 30) {
                System.out.println("Low pressure in a tire!");
                return false;
            }
        }
        return true;
    }
}
```

Nhiệm vụ của bạn là tái cấu trúc mã này để tuân thủ Luật Demeter.
1.  Thêm một method vào lớp `Wheel` để che giấu `Tire`. Ví dụ, một method `isPressureLow()`.
2.  Sửa đổi method `checkTirePressure()` của `Car` để gọi method mới này trên các object `Wheel` của nó, để nó không còn cần biết về lớp `Tire` nữa.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Câu nào sau đây mô tả đúng nhất mục tiêu chính của Luật Demeter?

A) Để đảm bảo mỗi lớp chỉ có một trách nhiệm.
B) Để giảm coupling bằng cách hạn chế thông tin cấu trúc mà một method có về các object khác.
C) Để đảm bảo rằng các lớp con luôn có thể được thay thế cho các lớp cha của chúng.
D) Để ngăn chặn việc tạo ra các interface lớn, phức tạp.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Để giảm coupling bằng cách hạn chế thông tin cấu trúc mà một method có về các object khác. Bằng cách ngăn bạn "vươn qua" các object, LoD buộc bạn phải phụ thuộc vào những gì một object có thể *làm* (các method public của nó) thay vì những gì nó *có* (cấu trúc nội bộ của nó), đây là một nguyên lý cốt lõi của coupling lỏng lẻo.

### **Bài 15: Lớp Immutable**

#### **1. Giải thích khái niệm**

Một **immutable object** là một object mà trạng thái nội bộ của nó không thể bị thay đổi sau khi nó đã được tạo. Bất kỳ hoạt động nào có vẻ như sửa đổi một immutable object thực ra đều trả về một object mới với trạng thái đã được sửa đổi, để lại object ban đầu không bị ảnh hưởng.

Lớp `String` là ví dụ nổi tiếng nhất về một lớp immutable trong Java. Khi bạn gọi `myString.toUpperCase()`, bạn không thay đổi `myString`; bạn đang tạo và trả về một chuỗi mới là phiên bản viết hoa.

Việc thiết kế các lớp của riêng bạn để trở thành immutable mang lại những lợi thế đáng kể, đặc biệt là trong các ứng dụng đồng thời và đa luồng.

**Lợi ích cốt lõi của Immutability:**
1.  **An toàn cho luồng (Thread Safety):** Các immutable object vốn đã an toàn cho luồng. Vì trạng thái của chúng không bao giờ thay đổi, chúng có thể được chia sẻ tự do giữa nhiều luồng mà không cần bất kỳ sự đồng bộ hóa nào (`synchronized` block hoặc lock). Điều này loại bỏ một loại lớn các lỗi đồng thời phức tạp.
2.  **Dự đoán được và Đơn giản:** Trạng thái của một immutable object là cố định và được biết tại thời điểm tạo. Bạn có thể truyền nó cho các method khác hoặc lưu trữ nó trong các collection với sự đảm bảo tuyệt đối rằng trạng thái của nó sẽ không bị thay đổi bất ngờ bởi một phần nào đó của mã. Điều này làm cho chương trình dễ dàng để suy luận hơn rất nhiều.
3.  **Có thể sử dụng làm khóa `Map` và trong `Set`:** Các collection dựa trên hash như `HashMap` và `HashSet` dựa vào việc `hashCode()` của các phần tử của chúng không đổi. Nếu bạn sử dụng một object có thể thay đổi (mutable) làm khóa trong `HashMap` và sau đó thay đổi trạng thái của nó, mã hash của nó có thể thay đổi, và bạn có thể "mất" object đó trong map. Các immutable object là hoàn hảo cho vai trò này.
4.  **Caching:** Bởi vì trạng thái của chúng là hằng số, kết quả của chúng có thể được lưu vào bộ đệm dễ dàng. Ví dụ, `hashCode()` của một `String` được tính một lần và sau đó được lưu vào cache vì chuỗi không bao giờ có thể thay đổi.

---

#### **2. Cách tạo một lớp Immutable**

Để làm cho một lớp trở thành immutable, bạn phải tuân theo một bộ quy tắc nghiêm ngặt:

1.  **Khai báo lớp là `final`:** Điều này ngăn các lớp khác kế thừa nó và ghi đè các method để thay đổi hành vi của nó và phá vỡ tính immutable của nó.
2.  **Làm cho tất cả các trường là `private` và `final`:** `private` thực thi data hiding. `final` đảm bảo rằng các trường chỉ có thể được gán một lần, bên trong constructor.
3.  **Không cung cấp bất kỳ method "setter" nào:** Không nên có method nào sửa đổi các biến instance.
4.  **Khởi tạo tất cả các trường trong constructor:** Tất cả trạng thái phải được đặt tại thời điểm tạo.
5.  **Thực hiện các bản sao phòng thủ (defensive copies) cho các trường object có thể thay đổi:** Đây là bước quan trọng nhất và thường bị bỏ qua nhất.
    *   **Trong constructor:** Nếu một tham số của constructor là một object có thể thay đổi (như `Date` hoặc `List`), bạn phải tạo một bản sao mới của nó cho trường nội bộ của bạn. Đừng chỉ gán tham chiếu, nếu không mã bên ngoài vẫn có thể sửa đổi object đó.
    *   **Trong bất kỳ method "getter" nào:** Nếu bạn có một getter trả về một trường object có thể thay đổi, bạn phải trả về một bản sao mới của nó. Đừng trả về một tham chiếu đến trạng thái nội bộ của bạn, nếu không mã bên ngoài có thể sửa đổi nó.

---

#### **3. Ví dụ mã nguồn**

Ví dụ này cho thấy một lớp `User` immutable được thiết kế đúng cách, chứa một object `Date` có thể thay đổi.

```java
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

// Quy tắc 1: Lớp được khai báo là final
public final class ImmutableUser {

    // Quy tắc 2: Các trường là private và final
    private final String username;
    private final Date registrationDate;
    private final List<String> roles;

    // Quy tắc 4: Tất cả các trường được khởi tạo trong constructor
    public ImmutableUser(String username, Date registrationDate, List<String> roles) {
        this.username = username;

        // Quy tắc 5 (Constructor): Thực hiện một bản sao phòng thủ của object Date có thể thay đổi.
        this.registrationDate = new Date(registrationDate.getTime());

        // Quy tắc 5 (Constructor): Thực hiện một bản sao phòng thủ của object List có thể thay đổi.
        this.roles = new ArrayList<>(roles);
    }

    // Quy tắc 3: Không có method setter. Chỉ có các getter được cung cấp.
    public String getUsername() {
        return username;
    }

    public List<String> getRoles() {
        // Quy tắc 5 (Getter): Trả về một bản sao, không phải tham chiếu ban đầu.
        return new ArrayList<>(roles);
    }

    public Date getRegistrationDate() {
        // Quy tắc 5 (Getter): Trả về một bản sao, không phải tham chiếu ban đầu.
        return new Date(registrationDate.getTime());
    }
}

class ImmutabilityDemo {
    public static void main(String[] args) {
        // Tạo một date có thể thay đổi để kiểm tra lớp immutable của chúng ta
        Date myDate = new Date();
        List<String> myRoles = new ArrayList<>();
        myRoles.add("ADMIN");

        ImmutableUser user = new ImmutableUser("alice", myDate, myRoles);
        System.out.println("User's initial registration date: " + user.getRegistrationDate());
        System.out.println("User's initial roles: " + user.getRoles());

        // --- Hãy thử sửa đổi trạng thái từ bên ngoài ---

        // Nỗ lực 1: Sửa đổi object myDate ban đầu
        myDate.setTime(0); // Đặt về thời điểm epoch
        System.out.println("User's date after modifying original: " + user.getRegistrationDate());

        // Nỗ lực 2: Sửa đổi danh sách được trả về bởi getter
        List<String> rolesFromGetter = user.getRoles();
        rolesFromGetter.add("SUPER_USER");
        System.out.println("User's roles after modifying getter list: " + user.getRoles());

        // Trạng thái của object 'user' vẫn không thay đổi, chứng tỏ tính immutable của nó.
    }
}
```
**Đầu ra của demo:**
Đầu ra sẽ cho thấy ngày đăng ký và danh sách vai trò của người dùng **không** thay đổi, mặc dù chúng ta đã cố gắng sửa đổi chúng. Điều này là do các bản sao phòng thủ.

---

#### **4. Bài tập nhỏ**

Tạo một lớp immutable có tên `CurrencyPair`.
1.  Nó nên có hai trường `private final String`: `baseCurrency` và `quoteCurrency`.
2.  Khai báo lớp là `final`.
3.  Cung cấp một constructor để khởi tạo các trường.
4.  Cung cấp các getter cho cả hai trường. (Vì `String` đã là immutable, bạn không cần phải tạo các bản sao phòng thủ của nó).
5.  Ghi đè các method `equals()`, `hashCode()`, và `toString()` để thực hành tốt.
6.  Trong `main`, tạo một instance của `CurrencyPair` và chứng minh rằng nó không thể thay đổi sau khi tạo.

---

#### **5. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang tạo một lớp immutable `Product` có một trường `private final List<String> tags;`. Triển khai getter nào sau đây bảo toàn chính xác tính immutable của lớp `Product`?

A)```java
public List<String> getTags() {
return this.tags;
}
```

B)
```java
public List<String> getTags() {
    return Collections.unmodifiableList(this.tags);
}
```

C)
```java
public void getTags(List<String> destinationList) {
    destinationList.addAll(this.tags);
}
```

D)
```java
public String[] getTags() {
    return this.tags.toArray(new String[0]);
}
```

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B), và cũng có thể là D), là những cách đúng để bảo toàn tính immutable.
*   **B) `Collections.unmodifiableList(this.tags)`** là cách phổ biến và thành ngữ nhất. Nó trả về một trình bao bọc xung quanh danh sách ban đầu sẽ ném ra một `UnsupportedOperationException` nếu có bất kỳ sửa đổi nào (như `add` hoặc `remove`) được cố gắng.
*   **D) `this.tags.toArray(new String[0])`** cũng đúng vì nó tạo ra một mảng mới chứa các phần tử của danh sách. Người gọi có thể sửa đổi mảng mới này, nhưng nó sẽ không có tác động đến danh sách nội bộ của `Product`. Đây là một dạng sao chép phòng thủ.
*   A) là không đúng vì nó trả về một tham chiếu trực tiếp đến danh sách nội bộ, cho phép nó bị sửa đổi.
*   C) là một thiết kế getter không thông thường và không trả về giá trị trực tiếp.

### **Bài 16: Áp dụng OOP - Các Anti-Pattern phổ biến và Tái cấu trúc**

#### **1. Giải thích khái niệm**

Bây giờ chúng ta đã đề cập đến các nguyên tắc cốt lõi của thiết kế OOP tốt, việc học cách nhận biết và sửa chữa thiết kế tồi cũng quan trọng không kém. **Anti-patterns** là những giải pháp phổ biến, lặp đi lặp lại cho các vấn đề mà cuối cùng lại không hiệu quả và tạo ra nhiều vấn đề hơn là giải quyết chúng. Bài học này bao gồm một vài anti-pattern kinh điển và các chiến lược tái cấu trúc để sửa chữa chúng.

##### **Anti-Pattern: The God Object (hoặc "Blob")**
*   **Mô tả:** Một lớp duy nhất, khổng lồ làm, hoặc biết, quá nhiều. Nó vi phạm **Single Responsibility Principle** và thường có **cohesion rất thấp**. Object này trở thành trung tâm cho một phần lớn logic của ứng dụng, và mọi người trong nhóm phải chỉnh sửa và hợp nhất các thay đổi trong một tệp này, dẫn đến xung đột thường xuyên.
*   **Triệu chứng:** Một lớp với một số lượng lớn các method và biến instance xử lý các tác vụ không liên quan (ví dụ: logic nghiệp vụ, lưu trữ dữ liệu, kết xuất giao diện người dùng, v.v.).
*   **Chiến lược tái cấu trúc:** **Phân rã (Decomposition)**. Áp dụng triệt để Single Responsibility Principle. Xác định các trách nhiệm khác nhau trong God Object và tách chúng ra thành các lớp mới, nhỏ hơn, có cohesion cao. Sử dụng dependency injection để cung cấp các lớp trợ giúp mới này cho lớp ban đầu, lớp này bây giờ hoạt động như một điều phối viên.

##### **Anti-Pattern: Feature Envy**
*   **Mô tả:** Một method dường như quan tâm đến dữ liệu của một lớp khác hơn là của chính nó. Nó thực hiện nhiều cuộc gọi getter đến một object khác để lấy dữ liệu của nó và sau đó thực hiện một số logic trên dữ liệu đó. Đây là một dấu hiệu của việc phân bổ trách nhiệm kém và dẫn đến **coupling cao**.
*   **Triệu chứng:** Một method trong lớp `A` gần như hoàn toàn bao gồm các cuộc gọi như `b.getX()`, `b.getY()`, `b.getZ()`. Logic thuộc về bên trong lớp `B`.
*   **Chiến lược tái cấu trúc:** **Di chuyển Method (Move Method)**. Di chuyển toàn bộ method (hoặc phần logic liên quan của nó) đến lớp sở hữu dữ liệu mà nó "ghen tị". Điều này làm tăng cohesion của lớp sở hữu dữ liệu và giảm coupling giữa hai lớp. Nó phù hợp với nguyên tắc "Tell, Don't Ask"—bạn nên bảo một object làm gì đó với dữ liệu của chính nó, không phải hỏi xin dữ liệu của nó rồi tự mình thao tác trên đó.

##### **Anti-Pattern: Anemic Domain Model**
*   **Mô tả:** Một thiết kế trong đó các object chỉ là các thùng chứa dữ liệu đơn giản với các getter và setter, và tất cả logic nghiệp vụ được đặt trong các lớp "manager" hoặc "service" riêng biệt. Các lớp chỉ có dữ liệu này được gọi là "anemic" (thiếu máu). Đây thường là một dấu hiệu của lập trình thủ tục được ngụy trang trong cú pháp hướng đối tượng. Nó vi phạm ý tưởng cốt lõi của OOP về việc gộp dữ liệu và hành vi hoạt động trên dữ liệu đó.
*   **Triệu chứng:** Một package đầy các POJO (Plain Old Java Objects) chỉ có các trường, constructor, getter và setter. Một bộ các lớp "Service" tương ứng nhận các POJO này làm tham số và thực hiện tất cả công việc.
*   **Chiến lược tái cấu trúc:** **Thêm hành vi (Add Behavior)**. Di chuyển logic nghiệp vụ từ các lớp service vào chính các domain object. Ví dụ, thay vì một method `OrderService.calculateTotal(Order order)`, hãy tạo một method `order.calculateTotal()`. Điều này làm cho các domain object trở nên phong phú với hành vi, tăng cohesion và đóng gói các quy tắc nghiệp vụ tốt hơn.

---

#### **2. Ví dụ mã nguồn**

##### **Trước: Một sự pha trộn của các Anti-Pattern**

```java
// Anti-Pattern: Anemic Domain Model. Lớp Order chỉ là một túi dữ liệu.
class Order {
    private List<OrderItem> items;
    private double taxRate;
    // Getters và setters cho items và taxRate...
}

// Anti-Pattern: Feature Envy. Method này "ghen tị" với dữ liệu của Order.
// Nó cũng gợi ý về một God Object nếu lớp này quản lý thanh toán, vận chuyển, v.v.
class OrderProcessor {
    public double calculateOrderTotal(Order order) {
        // 1. Hỏi Order dữ liệu của nó
        List<OrderItem> items = order.getItems();
        double subtotal = 0;
        for (OrderItem item : items) {
            // 2. Hỏi OrderItem dữ liệu của nó
            subtotal += item.getPrice() * item.getQuantity();
        }
        // 3. Hỏi Order thêm dữ liệu
        double tax = subtotal * order.getTaxRate();
        return subtotal + tax;
    }
}
```

##### **Sau: Tái cấu trúc thành một Rich Domain Model**

```java
// Không còn anemic. Lớp này bây giờ sở hữu logic nghiệp vụ của riêng mình.
class RichOrder {
    private List<OrderItem> items;
    private double taxRate;

    // constructor...

    // Tái cấu trúc: Logic từ service đã được chuyển đến đây.
    public double calculateTotal() {
        // Method bây giờ hoạt động trực tiếp trên dữ liệu của chính nó.
        double subtotal = items.stream()
                               .mapToDouble(item -> item.calculateSubtotal()) // Ủy thác cho OrderItem
                               .sum();
        double tax = subtotal * this.taxRate;
        return subtotal + tax;
    }
}

class OrderItem {
    private double price;
    private int quantity;

    // Hành vi bây giờ là một phần của lớp sở hữu dữ liệu.
    public double calculateSubtotal() {
        return this.price * this.quantity;
    }
}

// OrderProcessor bây giờ đơn giản hơn nhiều, hoặc thậm chí có thể không cần thiết.
// Nó hoạt động như một điều phối viên cấp cao.
class OrderService {
    public void process(RichOrder order) {
        // Tell, Don't Ask.
        double total = order.calculateTotal();
        // ... bây giờ tiến hành thanh toán, vận chuyển, v.v. ...
    }
}
```
Thiết kế được tái cấu trúc này có cohesion cao hơn (logic đi cùng với dữ liệu mà nó hoạt động trên) và coupling thấp hơn (`OrderService` không còn cần biết các chi tiết nội bộ về cách tính tổng của một `Order`).

---

#### **3. Bài tập nhỏ**

Bạn có một lớp `Report` và một lớp `ReportGenerator`. `ReportGenerator` thể hiện "Feature Envy".

```java
class Report {
    private String title;
    private String content;
    private String author;

    public Report(String title, String content, String author) {
        this.title = title;
        this.content = content;
        this.author = author;
    }
    // Getters cho tất cả các trường...
}

class ReportGenerator {
    // Method này ghen tị với dữ liệu của Report.
    public String toHtml(Report report) {
        String html = "<html><head><title>" + report.getTitle() + "</title></head><body>";
        html += "<h1>" + report.getTitle() + "</h1>";
        html += "<h2>By: " + report.getAuthor() + "</h2>";
        html += "<p>" + report.getContent() + "</p>";
        html += "</body></html>";
        return html;
    }
}
```

Nhiệm vụ của bạn là tái cấu trúc mã này.
1.  Áp dụng tái cấu trúc **Move Method**.
2.  Di chuyển logic `toHtml` vào chính lớp `Report`, để nó trở thành một rich domain object.
3.  Lớp `ReportGenerator` bây giờ có thể là dư thừa hoặc có thể được đơn giản hóa để chỉ gọi method mới trên object `Report`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang tái cấu trúc một lớp `UserService` lớn. Bạn nhận thấy một method private có tên `isValidEmail(String email)` sử dụng một biểu thức chính quy để xác thực định dạng email. Method này là một ứng cử viên hoàn hảo để được tách ra thành một lớp riêng. Lợi ích chính mà điều này đạt được là gì?

A) Nó làm cho lớp `UserService` trở thành immutable.
B) Nó làm tăng cohesion của lớp `EmailValidator` mới và lớp `UserService`.
C) Nó thể hiện Luật Demeter.
D) Nó chuyển đổi một anemic domain model thành một rich domain model.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Nó làm tăng cohesion của lớp `EmailValidator` mới và lớp `UserService`. Trách nhiệm xác thực email được tách ra thành một lớp `EmailValidator` mới, có cohesion cao, công việc duy nhất của nó là xác thực. Điều này cũng làm cho `UserService` có cohesion cao hơn bằng cách loại bỏ một trách nhiệm bên lề, cho phép nó tập trung vào các tác vụ quản lý người dùng cấp cao hơn.

### **Bài 17: Tóm tắt chủ đề, Câu hỏi phỏng vấn và Dự án cuối cùng**

Đây là bài học cuối cùng cho chủ đề của chúng ta về OOP & Nguyên tắc thiết kế. Chúng ta sẽ củng cố tất cả các khái niệm vào một bản tóm tắt, xem lại các câu hỏi phỏng vấn phổ biến kiểm tra kiến thức này, và áp dụng mọi thứ trong một dự án nhỏ cuối cùng.

---

#### **1. Bảng tóm tắt các điểm chính**

| Khái niệm | Điểm chính |
| :--- | :--- |
| **Abstraction** | Ẩn các chi tiết triển khai phức tạp. Đạt được thông qua **abstract classes** ("is-a", chia sẻ mã/trạng thái) và **interfaces** ("can-do", định nghĩa một hợp đồng). |
| **Encapsulation** | Gộp dữ liệu và các method vào một lớp. Thực thi **data hiding** thông qua các access modifier `private` và truy cập có kiểm soát qua các method public (getter/setter). |
| **Inheritance** | Mối quan hệ "is-a" (`extends`). Thúc đẩy tái sử dụng mã nhưng tạo ra **liên kết chặt chẽ**. Một lớp con kế thừa từ đúng một lớp cha. |
| **Polymorphism** | "Nhiều hình dạng." Một object có thể được đối xử như một instance của kiểu cha của nó. **Runtime polymorphism** (ghi đè method) đạt được thông qua dynamic binding. |
| **Composition** | Mối quan hệ "has-a" hoặc "part-of". Là sự thay thế được ưa thích cho inheritance để tái sử dụng và linh hoạt. Tạo ra **liên kết lỏng lẻo**. |
| **Lớp `Object`** | Là gốc của tất cả các lớp Java. Ghi đè `equals()` (cho đẳng thức giá trị) và `hashCode()` (cho các collection dựa trên hash) cùng nhau. Ghi đè `toString()` để ghi log có ý nghĩa. |
| **Nguyên tắc SOLID** | **S**ingle Responsibility, **O**pen/Closed, **L**iskov Substitution, **I**nterface Segregation, **D**ependency Inversion. Một bộ quy tắc để tạo ra phần mềm linh hoạt, dễ bảo trì và dễ hiểu. |
| **DRY, KISS, YAGNI** | **D**on't **R**epeat **Y**ourself (trừu tượng hóa mã trùng lặp). **K**eep **I**t **S**imple, **S**tupid (tránh thiết kế quá mức). **Y**ou **A**in't **G**onna **N**eed **I**t (đừng triển khai các tính năng suy đoán). |
| **Cohesion & Coupling** | Mục tiêu là **High Cohesion** (một lớp làm tốt một việc) và **Low Coupling** (các lớp độc lập với nhau). SRP thúc đẩy cohesion; DIP/OCP thúc đẩy coupling lỏng lẻo. |
| **Luật Demeter** | "Chỉ nói chuyện với những người bạn trực tiếp của bạn." Tránh các chuỗi method (`a.getB().getC().doSomething()`) để giảm coupling với cấu trúc nội bộ của các object khác. |
| **Immutability** | Trạng thái của một object không thể thay đổi sau khi tạo. Cung cấp an toàn luồng và khả năng dự đoán vốn có. Yêu cầu một lớp `final`, các trường `private final`, không có setter, và sao chép phòng thủ các thành phần có thể thay đổi. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Giải thích sự khác biệt giữa một abstract class và một interface. Khi nào bạn sẽ sử dụng cái này thay vì cái kia?"**
    *   *Trả lời:* Một interface định nghĩa một hợp đồng hành vi thuần túy (mối quan hệ "can-do") và một lớp có thể triển khai nhiều interface. Một abstract class cung cấp một bản thiết kế một phần (mối quan hệ "is-a"), có thể có trạng thái (biến instance) và các method cụ thể, nhưng một lớp chỉ có thể kế thừa một lớp. Chọn một abstract class khi bạn cần chia sẻ mã hoặc trạng thái giữa các lớp con có liên quan chặt chẽ. Chọn một interface khi bạn cần định nghĩa một khả năng có thể được áp dụng bởi các lớp không liên quan.

2.  **"Hợp đồng giữa `equals()` và `hashCode()` là gì? Điều gì xảy ra nếu bạn vi phạm nó?"**
    *   *Trả lời:* Hợp đồng là: nếu hai object bằng nhau theo `equals()`, chúng PHẢI có cùng một mã hash. Nếu bạn vi phạm điều này (ví dụ: bằng cách ghi đè `equals()` nhưng không ghi đè `hashCode()`), các collection dựa trên hash như `HashMap` và `HashSet` sẽ không hoạt động chính xác. Bạn có thể đặt một object vào một set, nhưng khi bạn kiểm tra xem nó `contains()` một object bằng nhau, nó sẽ trả về `false` vì các mã hash khác nhau làm cho set tìm kiếm trong bucket sai.

3.  **"Tại sao 'ưu tiên composition hơn inheritance' là một nguyên tắc thiết kế phổ biến?"**
    *   *Trả lời:* Inheritance tạo ra liên kết chặt chẽ; một thay đổi trong superclass có thể dễ dàng làm hỏng các subclass. Nó cũng là tĩnh, cố định tại thời điểm biên dịch. Composition linh hoạt hơn, cho phép bạn thay đổi hành vi tại runtime bằng cách hoán đổi các thành phần. Nó tạo ra liên kết lỏng lẻo vì lớp chứa chỉ tương tác với giao diện công khai của thành phần, tôn trọng encapsulation và làm cho hệ thống dễ kiểm thử và bảo trì hơn.

4.  **"Các nguyên tắc SOLID, đặc biệt là DIP, làm thế nào để dẫn đến mã dễ kiểm thử hơn?"**
    *   *Trả lời:* Nguyên tắc Đảo ngược Phụ thuộc (DIP) làm cho chúng ta phụ thuộc vào các abstraction (interface) thay vì các triển khai cụ thể. Bằng cách sử dụng Dependency Injection, chúng ta có thể cung cấp các triển khai "mock" hoặc "stub" của các interface này trong quá trình kiểm thử. Điều này cho phép chúng ta kiểm thử một thành phần (như một service) hoàn toàn độc lập, mà không cần một cơ sở dữ liệu hoặc kết nối mạng thực sự, làm cho các unit test của chúng ta nhanh, đáng tin cậy và tập trung.

5.  **"Bạn có một method trong lớp A gọi `b.getC().doSomething()`. Nguyên tắc thiết kế nào có khả năng bị vi phạm và bạn sẽ sửa nó như thế nào?"**
    *   *Trả lời:* Điều này vi phạm Luật Demeter. Nó kết nối lớp A không chỉ với lớp B, mà còn với cấu trúc nội bộ của B (thực tế là nó có một C). Để sửa nó, bạn sẽ giới thiệu một method mới trong lớp B, ví dụ `doTheThing()`, để che giấu sự ủy thác nội bộ. Lời gọi trong A sau đó sẽ trở thành `b.doTheThing()`, và lớp A không còn cần biết về lớp C nữa. Điều này làm giảm coupling và làm cho hệ thống linh hoạt hơn trước sự thay đổi.

---

#### **3. Dự án nhỏ cuối cùng: Một hệ thống ghi log linh hoạt**

Dự án này sẽ áp dụng nhiều nguyên tắc mà chúng ta đã học để xây dựng một hệ thống ghi log được tách rời và dễ dàng mở rộng.

**🎯 Mục tiêu:** Thiết kế một hệ thống ghi log trong đó logic cốt lõi của ứng dụng có thể ghi log các thông điệp mà không bị ràng buộc vào một đích đến cụ thể (ví dụ: console, tệp, hoặc mạng).

**Yêu cầu dự án:**

1.  **Interfaces (Abstraction, DIP, ISP):**
    *   Tạo một interface `LogOutput` với một method duy nhất: `void write(String formattedMessage)`. Đây là một interface chi tiết (ISP).
    *   Tạo một interface `MessageFormatter` với một method duy nhất: `String format(String message)`.

2.  **Triển khai cụ thể (SRP):**
    *   Tạo `ConsoleOutput`, triển khai `LogOutput` và ghi thông điệp ra `System.out.println()`.
    *   Tạo `FileOutput`, triển khai `LogOutput` và ghi thông điệp vào một tệp.
    *   Tạo `TimestampFormatter`, triển khai `MessageFormatter` và thêm một dấu thời gian vào đầu thông điệp.
    *   Tạo `SimpleFormatter`, triển khai `MessageFormatter` và trả về thông điệp như nguyên bản.

3.  **Dịch vụ Logger (Composition, Low Coupling):**
    *   Tạo một lớp `Logger`. Đây là lớp chính mà ứng dụng sẽ sử dụng.
    *   Nó nên được **bao gồm (composed)** từ một `LogOutput` và một `MessageFormatter`. Nó *không* nên kế thừa từ chúng.
    *   Các phụ thuộc (`LogOutput` và `MessageFormatter`) nên được tiêm vào thông qua constructor (DIP).
    *   Nó sẽ có một method public, `log(String message)`, sử dụng formatter của nó để định dạng thông điệp và sau đó sử dụng output của nó để ghi thông điệp đã định dạng.

4.  **Ứng dụng chính (Minh họa OCP):**
    *   Trong method `main` của bạn, hãy minh họa sự linh hoạt của thiết kế.
    *   Đầu tiên, tạo một `Logger` được cấu hình để ghi log ra console với một dấu thời gian. Ghi log một vài thông điệp.
    *   Sau đó, tạo một instance `Logger` thứ hai được cấu hình để ghi log vào một tệp với simple formatter, **mà không thay đổi bất kỳ lớp hiện có nào**. Ghi log thêm một vài thông điệp. Điều này chứng tỏ rằng hệ thống của bạn mở để mở rộng (các loại output/formatter mới) nhưng đóng để sửa đổi.

**Cấu trúc ví dụ của method `main`:**

```java
public static void main(String[] args) {
    // Cấu hình 1: Ghi log với dấu thời gian ra console
    LogOutput console = new ConsoleOutput();
    MessageFormatter timestampFormatter = new TimestampFormatter();
    Logger consoleLogger = new Logger(console, timestampFormatter);

    consoleLogger.log("Application has started.");
    consoleLogger.log("Processing user request.");

    System.out.println("------------------------------------");

    // Cấu hình 2: Ghi log thông điệp đơn giản vào một tệp
    LogOutput file = new FileOutput("app.log");
    MessageFormatter simpleFormatter = new SimpleFormatter();
    Logger fileLogger = new Logger(file, simpleFormatter);

    fileLogger.log("An error occurred in module X.");
    fileLogger.log("Shutting down services.");
}
```

Hoàn thành dự án này sẽ cho bạn một sự hiểu biết thực tế, thực hành về cách các nguyên tắc OOP và thiết kế quan trọng này kết hợp với nhau để tạo ra phần mềm sạch, dễ bảo trì và được xây dựng để tồn tại lâu dài.

