### **Bài 1: Hiểu về Hệ thống phân cấp I/O của Java**

#### **1. Giải thích khái niệm**

##### **I/O là gì?**
Input/Output (I/O) là cơ chế cho phép một chương trình Java giao tiếp với thế giới bên ngoài. "Thế giới bên ngoài" này có thể là một tệp trên đĩa, một kết nối mạng, console hệ thống, hoặc một chương trình khác. I/O là nền tảng cho bất kỳ ứng dụng nào cần lưu trữ dữ liệu, gửi/nhận dữ liệu, hoặc tương tác với người dùng.

##### **Hai thế giới của I/O cổ điển: Byte vs. Character Streams**
Package `java.io` được xây dựng trên một sự phân biệt quan trọng giữa hai loại dữ liệu:
1.  **Byte Streams:** Xử lý dữ liệu nhị phân thô, mỗi lần một byte 8-bit. Chúng phù hợp với mọi loại dữ liệu, bao gồm hình ảnh, tệp âm thanh, chương trình thực thi, và dữ liệu ký tự nơi bạn quản lý việc mã hóa thủ công.
    *   **Các lớp trừu tượng cơ sở:** `InputStream` và `OutputStream`.
2.  **Character Streams:** Xử lý dữ liệu ký tự, mỗi lần một ký tự Unicode 16-bit. Chúng là lựa chọn được ưu tiên để làm việc với các tệp văn bản vì chúng tự động xử lý việc chuyển đổi giữa byte và ký tự bằng một bộ ký tự được chỉ định (như UTF-8). Việc sử dụng các character stream cho văn bản ngăn chặn các lỗi phổ biến liên quan đến mã hóa ký tự.
    *   **Các lớp trừu tượng cơ sở:** `Reader` và `Writer`.

**Ví dụ tương tự:** Hãy nghĩ về một **byte stream** như một đường ống dẫn các vật liệu thô, chưa được kiểm tra (như dầu thô). Một **character stream** giống như một đường ống của nhà máy đóng chai chuyên dụng, nhận vật liệu thô, tinh chế nó thành một sản phẩm cụ thể (như Coca-Cola, đại diện cho các ký tự), và đảm bảo nó được xử lý đúng cách. Bạn sẽ không bao giờ gửi một cỗ máy phức tạp (như một tệp hình ảnh) qua nhà máy đóng chai.

##### **Mẫu Decorator trong I/O của Java**
Thư viện `java.io` là một ví dụ kinh điển của mẫu thiết kế **Decorator**. Ý tưởng cốt lõi là bạn bắt đầu với một stream cơ bản, "thô" kết nối với một nguồn (như một tệp) và sau đó bạn "bao bọc" hoặc "trang trí" nó với các stream khác để thêm chức năng.

*   **Core Stream (Thành phần):** `FileInputStream` kết nối trực tiếp với một tệp để đọc các byte.
*   **Decorator Stream:** `BufferedInputStream` có thể bao bọc một `FileInputStream`. Nó không kết nối với tệp; nó thêm chức năng **đệm (buffering)** (đọc các khối dữ liệu lớn vào bộ nhớ cùng một lúc) vào stream bên dưới, điều này cải thiện đáng kể hiệu suất.

**Sơ đồ của việc trang trí:**
```
+-----------------------------------+
| Mã của bạn                        |
+-----------------------------------+
       | đọc từ
+-----------------------------------+
| new BufferedInputStream( ... )    |  <- Decorator (thêm đệm)
+-----------------------------------+
       | bao bọc
+-----------------------------------+
| new FileInputStream("file.txt")   |  <- Thành phần (kết nối với nguồn)
+-----------------------------------+
       | đọc từ
+-----------------------------------+
|           Tệp trên đĩa           |
+-----------------------------------+
```

##### **Lớp `File`**
Lớp `java.io.File` là cách kế thừa để biểu diễn một đường dẫn tệp hoặc thư mục. Nó cung cấp các method để tương tác với hệ thống tệp, chẳng hạn như tạo tệp, xóa thư mục, kiểm tra quyền, và liệt kê nội dung. Mặc dù vẫn được sử dụng rộng rãi, nó có một số hạn chế (ví dụ: xử lý lỗi kém, dấu phân cách đường dẫn phụ thuộc vào nền tảng, hỗ trợ thuộc tính hạn chế). Cách tiếp cận hiện đại, được giới thiệu trong Java 7, là sử dụng các lớp `java.nio.file.Path` và `Files`, chúng ta sẽ đề cập sau.

##### **Checked Exceptions trong I/O**
Gần như tất cả các method trong package `java.io` thực hiện các hoạt động I/O thực tế đều được khai báo để ném ra `java.io.IOException` hoặc một trong các lớp con của nó (như `FileNotFoundException`). Đây là một **checked exception**, buộc bạn, nhà phát triển, phải xử lý các lỗi I/O tiềm ẩn trong mã của mình bằng cách sử dụng một khối `try-catch` hoặc bằng cách khai báo nó trong một mệnh đề `throws`.

---

#### **2. Ví dụ mã nguồn: Sử dụng lớp `File`**

Mã này minh họa việc kiểm tra hệ thống tệp cơ bản bằng cách sử dụng lớp `File`. Nó chưa đọc hoặc ghi dữ liệu.

```java
import java.io.File;
import java.io.IOException;

public class FileClassDemo {
    public static void main(String[] args) {
        // Tạo một đối tượng File đại diện cho một đường dẫn. Tệp có thể chưa tồn tại.
        File myFile = new File("my-sample-file.txt");

        System.out.println("File object created for path: " + myFile.getAbsolutePath());

        try {
            // --- Thông tin tệp cơ bản ---
            if (myFile.exists()) {
                System.out.println("File exists.");
                System.out.println("Is it a directory? " + myFile.isDirectory());
                System.out.println("File size: " + myFile.length() + " bytes");
            } else {
                System.out.println("File does not exist.");
                // Hãy tạo nó
                if (myFile.createNewFile()) {
                    System.out.println("File was created successfully.");
                }
            }

            // --- Làm việc với các thư mục ---
            File myDir = new File("sample-directory");
            if (!myDir.exists()) {
                if (myDir.mkdir()) { // mkdir() tạo một thư mục duy nhất
                    System.out.println("\nDirectory created: " + myDir.getAbsolutePath());
                }
            }
            if (myDir.isDirectory()) {
                System.out.println("\nListing contents of directory: " + myDir.getName());
                String[] contents = myDir.list();
                if (contents != null && contents.length > 0) {
                    for (String item : contents) {
                        System.out.println("- " + item);
                    }
                } else {
                    System.out.println("Directory is empty.");
                }
            }

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
        }
    }
}

```

---

#### **3. Bài tập nhỏ**

Viết một chương trình chấp nhận một đường dẫn thư mục làm đối số dòng lệnh.
1.  Sử dụng lớp `File` để đại diện cho đường dẫn này.
2.  Kiểm tra xem đường dẫn có tồn tại không và nó có phải là một thư mục không.
3.  Nếu nó là một thư mục, hãy lặp qua nội dung của nó (`file.listFiles()`).
4.  Đối với mỗi mục trong thư mục, hãy in tên của nó và liệu nó là một tệp (`[F]`) hay một thư mục (`[D]`).
    *Ví dụ đầu ra:*
    ```
    [D] .git
    [F] .gitignore
    [D] src
    [F] pom.xml
    ```

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn cần viết một chương trình sao chép một tệp âm thanh MP3 từ một vị trí này sang một vị trí khác. Cặp lớp cơ sở nào từ package `java.io` là lựa chọn đúng cho tác vụ này?

A) `Reader` và `Writer`
B) `File` và `RandomAccessFile`
C) `InputStream` và `OutputStream`
D) `BufferedReader` và `BufferedWriter`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `InputStream` và `OutputStream`. Một tệp MP3 chứa dữ liệu nhị phân thô, không phải văn bản. Các byte stream được thiết kế để xử lý bất kỳ loại dữ liệu nhị phân nào mà không cố gắng diễn giải nó. Việc sử dụng các character stream (`Reader`/`Writer`) sẽ làm hỏng tệp vì chúng sẽ cố gắng giải mã dữ liệu nhị phân như các ký tự văn bản, làm thay đổi các byte.

### **Bài 2: Byte Streams và Buffered Streams**

#### **1. Giải thích khái niệm**

Byte streams là các khối xây dựng cơ bản của I/O trong Java. Chúng đọc và ghi dữ liệu dưới dạng một luồng các byte 8-bit và là lựa chọn đúng đắn để xử lý bất kỳ loại dữ liệu nhị phân thô nào, chẳng hạn như hình ảnh, tệp thực thi, các object được serialize, hoặc các gói tin mạng.

##### **Các lớp trừu tượng cốt lõi**
*   **`InputStream`:** Một lớp trừu tượng là lớp cha của tất cả các lớp đại diện cho một luồng đầu vào của các byte.
    *   **Method chính:** `int read()`: Đọc byte tiếp theo của dữ liệu từ luồng đầu vào. Nó trả về byte dưới dạng một giá trị `int` từ 0 đến 255. Nó trả về **-1** nếu đã đến cuối luồng. `-1` này là tín hiệu tiêu chuẩn cho "cuối luồng".
*   **`OutputStream`:** Một lớp trừu tượng là lớp cha của tất cả các lớp đại diện cho một luồng đầu ra của các byte.
    *   **Method chính:** `void write(int b)`: Ghi byte được chỉ định (8 bit bậc thấp của `int`) vào luồng đầu ra.

##### **Các triển khai cụ thể phổ biến**

*   **File Streams (`FileInputStream` / `FileOutputStream`):**
    *   Đây là các stream cơ bản để đọc từ và ghi vào các tệp trên đĩa. Chúng cung cấp một kết nối trực tiếp, không có bộ đệm đến một tệp.
*   **Byte Array Streams (`ByteArrayInputStream` / `ByteArrayOutputStream`):**
    *   Các stream này sử dụng một mảng byte trong bộ nhớ làm nguồn hoặc đích của chúng. Chúng cực kỳ hữu ích cho các hoạt động mà bạn cần đọc từ hoặc ghi vào một bộ đệm tạm thời trong bộ nhớ mà không cần chạm vào hệ thống tệp. Ví dụ, tạo một tài liệu PDF trong bộ nhớ trước khi gửi nó qua mạng.

##### **Vấn đề về hiệu suất: I/O không có bộ đệm**
Khi bạn sử dụng một `FileInputStream` cơ bản và gọi `read()` từng byte một, mỗi lần gọi có thể kích hoạt một lời gọi hệ thống đến hệ điều hành cơ sở để đọc từ đĩa. Các lời gọi hệ thống rất tốn kém về mặt tính toán. Việc đọc một tệp 1MB từng byte một có thể dẫn đến một triệu lời gọi hệ thống riêng biệt, điều này cực kỳ chậm.

**Ví dụ tương tự:** Điều này giống như việc đi đến cửa hàng tạp hóa để mua nguyên liệu cho một bữa tối lớn, nhưng bạn chỉ mang một món hàng về nhà mỗi lần. Bạn sẽ phải thực hiện hàng trăm chuyến đi, và phần lớn thời gian của bạn sẽ dành cho việc di chuyển, không phải mua sắm.

##### **Giải pháp: Buffered Streams (Các Decorator)**

*   **`BufferedInputStream` và `BufferedOutputStream`:** Đây là các lớp decorator thêm chức năng đệm vào một stream bên dưới.
*   **Cơ chế nội bộ:**
    *   Một `BufferedInputStream` bao bọc một `InputStream` và duy trì một bộ đệm `byte[]` nội bộ (ví dụ: 8192 byte).
    *   Khi bạn gọi `read()`, `BufferedInputStream` kiểm tra xem bộ đệm của nó có dữ liệu không. Nếu có, nó trả về một byte trực tiếp từ bộ nhớ, điều này rất nhanh.
    *   Nếu bộ đệm trống, nó thực hiện một lời gọi đọc lớn, duy nhất trên stream bên dưới để lấp đầy hoàn toàn bộ đệm của nó. Lời gọi hệ thống tốn kém này bây giờ phục vụ hàng nghìn yêu cầu `read()` tiếp theo từ bộ nhớ.
    *   Tương tự, `BufferedOutputStream` tích lũy các byte trong bộ đệm nội bộ của nó và ghi chúng vào stream bên dưới thành một khối lớn duy nhất khi bộ đệm đầy (hoặc khi `flush()` được gọi).
*   **Lợi ích về hiệu suất:** Đệm làm giảm đáng kể số lượng lời gọi hệ thống, dẫn đến một sự cải thiện hiệu suất lớn cho hầu hết các hoạt động I/O.

**Thực hành tốt nhất:** **Luôn luôn** bao bọc các file stream và các stream chậm khác bằng các buffered stream.

---

#### **2. Ví dụ mã nguồn: Sao chép một tệp nhị phân**

Mã này sao chép một tệp hình ảnh. Nó cho thấy cả cách chậm, không có bộ đệm và cách nhanh, có bộ đệm để minh họa sự khác biệt về hiệu suất.

```java
import java.io.*;

public class FileCopyDemo {

    public static void main(String[] args) throws IOException {
        File sourceFile = new File("source-image.jpg");
        File destUnbuffered = new File("dest-unbuffered.jpg");
        File destBuffered = new File("dest-buffered.jpg");

        // Tạo một tệp nguồn giả cho demo
        try (OutputStream os = new FileOutputStream(sourceFile)) {
            os.write(new byte[5 * 1024 * 1024]); // Tệp 5 MB
        }

        // --- 1. Sao chép không có bộ đệm (Chậm) ---
        long startTime = System.nanoTime();
        copyFileUnbuffered(sourceFile, destUnbuffered);
        long endTime = System.nanoTime();
        System.out.println("Unbuffered copy time: " + (endTime - startTime) / 1_000_000 + " ms");

        // --- 2. Sao chép có bộ đệm (Nhanh) ---
        startTime = System.nanoTime();
        copyFileBuffered(sourceFile, destBuffered);
        endTime = System.nanoTime();
        System.out.println("Buffered copy time:   " + (endTime - startTime) / 1_000_000 + " ms");
    }

    // Chậm: Đọc từng byte một, nhiều lời gọi hệ thống
    public static void copyFileUnbuffered(File source, File dest) throws IOException {
        try (InputStream in = new FileInputStream(source);
             OutputStream out = new FileOutputStream(dest)) {
            int b;
            while ((b = in.read()) != -1) { // -1 chỉ ra cuối luồng
                out.write(b);
            }
        }
    }

    // Nhanh: Đọc các khối lớn vào một bộ đệm, ít lời gọi hệ thống
    public static void copyFileBuffered(File source, File dest) throws IOException {
        // Trang trí các file stream bằng các buffered stream
        try (InputStream in = new BufferedInputStream(new FileInputStream(source));
             OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
            byte[] buffer = new byte[8192]; // Bộ đệm 8 KB
            int bytesRead;
            while ((bytesRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead);
            }
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Viết một chương trình nhận hai đường dẫn tệp làm đối số dòng lệnh: một tệp nguồn và một tệp đích.
1.  Triển khai logic để sao chép tệp nguồn đến tệp đích.
2.  Bạn **phải** sử dụng `FileInputStream` và `FileOutputStream`.
3.  Bạn **phải** bao bọc chúng trong `BufferedInputStream` và `BufferedOutputStream` để đảm bảo hiệu suất tốt.
4.  Sử dụng câu lệnh `try-with-resources` để đảm bảo rằng tất cả các stream được đóng một cách chính xác.
5.  Thêm các câu lệnh in để xác nhận khi nào việc sao chép bắt đầu và khi nào nó kết thúc.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Mục đích chính của decorator `BufferedInputStream` là gì?

A) Để mã hóa dữ liệu đang được đọc từ stream bên dưới.
B) Để giảm số lượng lời gọi hệ thống đến nguồn dữ liệu bên dưới bằng cách đọc dữ liệu thành các khối lớn vào một bộ đệm trong bộ nhớ.
C) Để chuyển đổi dữ liệu byte thô từ stream bên dưới thành các ký tự.
D) Để đảm bảo rằng method `read()` là an toàn cho luồng.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Để giảm số lượng lời gọi hệ thống đến nguồn dữ liệu bên dưới bằng cách đọc dữ liệu thành các khối lớn vào một bộ đệm trong bộ nhớ. Đây là định nghĩa của việc đệm và lợi ích hiệu suất chính của nó. Nó đánh đổi một lượng nhỏ bộ nhớ để giảm đáng kể các hoạt động I/O tốn kém.

### **Bài 3: Character Streams và Encodings**

#### **1. Giải thích khái niệm**

Trong khi byte streams là cần thiết cho dữ liệu nhị phân thô, chúng không tiện lợi cho việc xử lý văn bản. Một ký tự không phải lúc nào cũng là một byte đơn lẻ. Với các mã hóa ký tự như UTF-8, một ký tự có thể được biểu diễn bằng một đến bốn byte. Nếu bạn đọc một tệp văn bản từng byte một, bạn có thể chỉ đọc được một phần của một ký tự đa byte, dẫn đến dữ liệu bị hỏng.

**Character streams** giải quyết vấn đề này. Chúng được thiết kế đặc biệt cho văn bản và tự động xử lý quá trình phức tạp của việc chuyển đổi giữa các byte và các ký tự bằng cách sử dụng một mã hóa ký tự được chỉ định.

##### **Các lớp trừu tượng cốt lõi**
*   **`Reader`:** Một lớp trừu tượng để đọc các luồng ký tự. Method `read()` của nó đọc một ký tự Unicode 16-bit đơn lẻ.
*   **`Writer`:** Một lớp trừu tượng để viết các luồng ký tự. Method `write()` của nó viết một ký tự đơn lẻ.

##### **Các Bridge Stream: `InputStreamReader` và `OutputStreamWriter`**
Hai lớp "cầu nối" này là liên kết quan trọng giữa thế giới hướng byte và thế giới hướng ký tự.

*   **`InputStreamReader`:** Bao bọc một `InputStream` (cung cấp các byte) và giải mã các byte đó thành các ký tự theo một `Charset` được chỉ định.
*   **`OutputStreamWriter`:** Bao bọc một `OutputStream` (chấp nhận các byte) và mã hóa các ký tự thành các byte trước khi viết chúng vào stream bên dưới.

**Ví dụ tương tự:** Hãy nghĩ về một `InputStreamReader` như một phiên dịch viên của Liên Hợp Quốc. `InputStream` là một người nói một ngôn ngữ thô (các byte). `InputStreamReader` (phiên dịch viên) lắng nghe ngôn ngữ thô đó và chuyển nó thành một ngôn ngữ được hiểu phổ biến, các ký tự Unicode, để phần còn lại của chương trình của bạn tiêu thụ.

**Sơ đồ của Cầu nối:**
```
+--------------+     +-----------------------+     +-------------------+
| Mã của bạn   | <-- | new InputStreamReader | <-- | new FileInputStream|
| (đọc chars)  |     | (charset: UTF-8)      |     | (đọc bytes)       |
+--------------+     +-----------------------+     +-------------------+
                          ^ (giải mã)                     ^ (từ)
                          |                               |
                     +-------------------------------------------+
                     |        Các byte từ tệp (ví dụ: UTF-8)      |
                     +-------------------------------------------+
```

##### **`Charset` và Mã hóa ký tự**
Một `Charset` (bộ ký tự hoặc mã hóa) là một bộ quy tắc để ánh xạ các byte thành các ký tự.
*   **ASCII:** Một mã hóa đơn giản, ban đầu. 1 ký tự = 1 byte. Chỉ có thể biểu diễn 128 ký tự (bảng chữ cái tiếng Anh, số, ký hiệu).
*   **UTF-8:** Mã hóa thống trị trên web. Đó là một mã hóa có độ rộng thay đổi. Các ký tự ASCII được lưu trữ dưới dạng một byte đơn lẻ, trong khi các ký tự khác (như `é`, `ü`, `Ω`, `€`, `你好`) được lưu trữ bằng 2, 3, hoặc 4 byte. Nó tương thích ngược với ASCII.
*   **UTF-16:** Biểu diễn nội bộ của Java cho các ký tự. Sử dụng 2 byte cho hầu hết các ký tự phổ biến và 4 byte cho các ký tự khác.

**Thực hành tốt nhất:** **Luôn luôn** chỉ định mã hóa ký tự khi làm việc với văn bản. Nếu không, JVM sẽ sử dụng mã hóa mặc định của nền tảng, có thể thay đổi giữa các hệ điều hành (ví dụ: UTF-8 trên macOS/Linux, cp1252 trên các phiên bản Windows cũ hơn ở Mỹ/Tây Âu). Điều này có thể dẫn đến ứng dụng của bạn hoạt động trên máy của bạn nhưng tạo ra văn bản bị hỏng trên một máy chủ có mã hóa mặc định khác.

##### **Các lớp tiện lợi: `FileReader` và `FileWriter`**
*   Đây là các lớp con đơn giản của `InputStreamReader` và `OutputStreamWriter`.
*   **`FileReader`** tương đương với `new InputStreamReader(new FileInputStream(fileName))`.
*   **`FileWriter`** tương đương với `new OutputStreamWriter(new FileOutputStream(fileName))`.
*   **Cảnh báo:** Các lớp này tiện lợi nhưng nguy hiểm vì chúng **luôn sử dụng mã hóa mặc định của nền tảng**. Đối với các ứng dụng mạnh mẽ, đa nền tảng, tốt hơn là nên tường minh và sử dụng `InputStreamReader` và `OutputStreamWriter` với một `Charset` được chỉ định.

##### **Buffered Character Streams**
Cũng giống như với các byte stream, việc đệm cung cấp một sự tăng tốc hiệu suất lớn cho các character stream.
*   **`BufferedReader`:** Bao bọc một `Reader` để cung cấp đệm. Nó cũng thêm method `String readLine()` rất hữu ích, đọc toàn bộ một dòng văn bản mỗi lần.
*   **`BufferedWriter`:** Bao bọc một `Writer` để cung cấp đệm. Nó thêm một method `void newLine()` để viết dấu phân cách dòng dành riêng cho nền tảng.

---

#### **2. Ví dụ mã nguồn: Đọc một tệp văn bản một cách chính xác**

Ví dụ này minh họa cách hiện đại, mạnh mẽ để đọc và viết một tệp văn bản bằng cách sử dụng `try-with-resources`, mã hóa UTF-8 tường minh, và đệm.

```java
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;

public class CharacterStreamDemo {

    public static void main(String[] args) {
        String fileName = "sample-text.txt";

        // --- Ghi vào một tệp với mã hóa tường minh và đệm ---
        try (Writer writer = new BufferedWriter(
                              new OutputStreamWriter(
                                  new FileOutputStream(fileName), StandardCharsets.UTF_8))) {
            writer.write("Hello, World! This is line 1.\n");
            writer.write("こんにちは, a Japanese character (Konnichiwa).\n");
            writer.write("€ is the Euro symbol.\n");
        } catch (IOException e) {
            System.err.println("Error writing to file: " + e.getMessage());
        }

        // --- Đọc từ một tệp với mã hóa tường minh và đệm ---
        System.out.println("Reading from file '" + fileName + "':");
        try (BufferedReader reader = new BufferedReader(
                                        new InputStreamReader(
                                            new FileInputStream(fileName), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading from file: " + e.getMessage());
        }

        // --- Cách hiện đại của NIO.2 (đơn giản hơn nhiều) ---
        // Lớp tiện ích Files xử lý các stream và đệm cho bạn.
        System.out.println("\nReading with Files.newBufferedReader (NIO.2):");
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(fileName), StandardCharsets.UTF_8)) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading with NIO.2: " + e.getMessage());
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Viết một chương trình đọc một tệp văn bản từng dòng và viết một tệp mới trong đó mỗi dòng được bắt đầu bằng một số dòng.
1.  Chương trình nên nhận hai đối số dòng lệnh: đường dẫn tệp đầu vào và đường dẫn tệp đầu ra.
2.  Sử dụng một `BufferedReader` để đọc và một `BufferedWriter` để viết.
3.  Bạn **phải** chỉ định `StandardCharsets.UTF_8` cho cả việc đọc và viết để đảm bảo tính chính xác.
4.  Sử dụng một bộ đếm để theo dõi số dòng.
    *Ví dụ đầu vào (`in.txt`):*
    ```
    Hello
    World
    ```
    *Ví dụ đầu ra (`out.txt`):*
    ```
    1: Hello
    2: World
    ```

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Rủi ro chính của việc sử dụng `FileReader` và `FileWriter` trong một ứng dụng máy chủ sẽ được triển khai trên các hệ điều hành khác nhau là gì?

A) Chúng chậm hơn nhiều so với việc sử dụng `FileInputStream` và `FileOutputStream`.
B) Chúng không hỗ trợ interface `AutoCloseable` và phải được đóng thủ công.
C) Chúng đã lỗi thời và sẽ bị xóa trong các phiên bản Java tương lai.
D) Chúng sử dụng mã hóa ký tự mặc định của nền tảng, có thể dẫn đến hỏng dữ liệu nếu môi trường phát triển và sản xuất có các mặc định khác nhau.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Chúng sử dụng mã hóa ký tự mặc định của nền tảng, có thể dẫn đến hỏng dữ liệu nếu môi trường phát triển và sản xuất có các mặc định khác nhau. Đây là một nguồn lỗi phổ biến và tinh vi. Một tệp được viết chính xác trên máy Mac của nhà phát triển (mặc định UTF-8) có thể xuất hiện dưới dạng chữ nguệch ngoạc khi được đọc bởi cùng một ứng dụng trên một máy chủ Windows (mặc định cp1252). Việc luôn chỉ định charset một cách tường minh là giải pháp đúng đắn, mạnh mẽ.

### **Bài 4: Các tiện ích I/O nâng cao và Serialization**

#### **1. Giải thích khái niệm**

Ngoài các stream cơ bản, package `java.io` còn cung cấp một số lớp tiện ích mạnh mẽ cho các tác vụ I/O chuyên biệt, bao gồm tương tác với hệ thống tệp một cách có cấu trúc hơn và chuyển đổi toàn bộ biểu đồ object thành một byte stream.

##### **`RandomAccessFile` - Tệp không tuần tự**
*   **Hành vi:** Không giống như các stream, đọc hoặc ghi dữ liệu một cách tuần tự từ đầu đến cuối, `RandomAccessFile` cho phép bạn di chuyển một con trỏ tệp đến bất kỳ vị trí nào trong một tệp và đọc hoặc ghi dữ liệu từ vị trí cụ thể đó.
*   **Ví dụ tương tự:** `InputStream` giống như đọc một cuốn sách từ trang 1 đến cuối. `RandomAccessFile` giống như có một cuốn sách với một mục lục và số trang, cho phép bạn nhảy trực tiếp đến bất kỳ chương hoặc trang nào.
*   **Chế độ:** Khi bạn tạo một `RandomAccessFile`, bạn phải chỉ định một chế độ:
    *   `"r"`: Chỉ đọc.
    *   `"rw"`: Đọc-ghi.
*   **Con trỏ tệp:** Nó duy trì một con trỏ tệp nội bộ chỉ ra vị trí cho hoạt động đọc hoặc ghi tiếp theo. Bạn có thể di chuyển con trỏ này bằng method `seek(long pos)`.
*   **Trường hợp sử dụng:** Hữu ích để làm việc với các tệp có cấu trúc đã biết, như các tệp cơ sở dữ liệu, các tệp log nhị phân nơi bạn cần đọc N byte cuối cùng, hoặc để chỉnh sửa các phần của một tệp lớn mà không cần viết lại toàn bộ.

##### **`PrintStream` và `PrintWriter` - Cho đầu ra được định dạng**
*   **`PrintWriter` (Dựa trên ký tự):** Một decorator `Writer` thêm các method tiện lợi để in các biểu diễn được định dạng của các loại dữ liệu khác nhau (`println()`, `printf()`, `format()`). Đây là lớp lý tưởng để viết đầu ra văn bản có thể đọc được bởi con người. Nó cũng có một tùy chọn cho "auto-flushing", buộc một ghi vào stream bên dưới mỗi khi một dòng mới được in.
*   **`PrintStream` (Dựa trên byte):** Một phiên bản tương đương dựa trên byte của `PrintWriter`. Instance nổi tiếng nhất của lớp này là **`System.out`**. Một tính năng chính (và là một cạm bẫy tiềm ẩn) là nó **không bao giờ ném ra `IOException`**. Thay vào đó, nó đặt một cờ lỗi nội bộ mà bạn phải kiểm tra thủ công bằng method `checkError()`. Điều này tiện lợi cho đầu ra console nhưng có thể che giấu các vấn đề khi ghi vào tệp.
*   **Thực hành tốt nhất:** Sử dụng `PrintWriter` cho tất cả các đầu ra được định dạng dựa trên ký tự. Sử dụng `PrintStream` chủ yếu cho đầu ra console (`System.out`).

##### **Object Serialization**
Serialization là quá trình chuyển đổi trạng thái của một object Java thành một byte stream. Deserialization là quá trình ngược lại: tái tạo object từ byte stream đó.

*   **Mục đích:**
    1.  **Lưu trữ (Persistence):** Lưu trạng thái của một object vào một tệp trên đĩa để được truy xuất sau này.
    2.  **Giao tiếp:** Gửi một object qua mạng đến một ứng dụng Java khác (ví dụ: trong Remote Method Invocation - RMI).
*   **Interface `Serializable`:** Để làm cho một lớp có thể serialize được, nó phải triển khai interface `java.io.Serializable`. Đây là một "marker interface" – nó không có method nào để triển khai. Nó chỉ đơn giản là báo hiệu cho JVM rằng object được phép serialize.
*   **`ObjectOutputStream` và `ObjectInputStream`:** Đây là các decorator stream xử lý quá trình serialization.
    *   `new ObjectOutputStream(new FileOutputStream("data.ser"))` bao bọc một byte stream. Method `writeObject(Object obj)` của nó thực hiện việc serialization.
    *   `new ObjectInputStream(new FileInputStream("data.ser"))` bao bọc một byte stream. Method `readObject()` của nó thực hiện việc deserialization.

##### **Từ khóa `transient` và `serialVersionUID`**
*   **`transient`:** Nếu bạn có một trường trong một lớp `Serializable` mà bạn **không muốn** được lưu (ví dụ: một mật khẩu, một bộ đệm tạm thời, hoặc một trường có thể được tính toán lại), bạn đánh dấu nó là `transient`. Quá trình serialization sẽ bỏ qua trường này.
*   **`serialVersionUID`:** Đây là một trường `private static final long` hoạt động như một số phiên bản cho lớp của bạn. Trong quá trình deserialization, JVM kiểm tra xem `serialVersionUID` của lớp trên classpath có khớp với cái trong byte stream đã được serialize không. Nếu chúng không khớp, nó sẽ ném ra một `InvalidClassException`. Đây là một **thực hành tốt nhất mạnh mẽ** để khai báo tường minh trường này. Nếu không, trình biên dịch sẽ tạo ra một cái dựa trên cấu trúc của lớp, và những thay đổi có vẻ nhỏ đối với lớp có thể làm cho ID được tạo ra thay đổi, phá vỡ khả năng tương thích của deserialization.

---

#### **2. Ví dụ mã nguồn: Object Serialization**

Ví dụ này định nghĩa một lớp `User`, đánh dấu một trường là `transient`, và minh họa việc ghi và đọc object vào một tệp.

```java
import java.io.*;

// Lớp phải triển khai Serializable
class User implements Serializable {
    // Là một thực hành tốt nhất để khai báo tường minh ID phiên bản này.
    private static final long serialVersionUID = 1L;

    private int id;
    private String username;
    // Trường 'password' sẽ KHÔNG được lưu trong quá trình serialization.
    private transient String password;

    public User(int id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" + "id=" + id + ", username='" + username + '\'' + ", password='" + password + '\'' + '}';
    }
}

public class SerializationDemo {
    public static void main(String[] args) {
        String filename = "user.ser";
        User userToWrite = new User(101, "alice", "pa$$w0rd");

        // --- 1. Serialize object vào một tệp ---
        System.out.println("Serializing: " + userToWrite);
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(userToWrite);
            System.out.println("Serialization successful.");
        } catch (IOException e) {
            System.err.println("Error during serialization: " + e.getMessage());
        }

        // --- 2. Deserialize object từ tệp ---
        System.out.println("\nDeserializing from " + filename + "...");
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            User userToRead = (User) ois.readObject();
            System.out.println("Deserialized: " + userToRead);
            // Lưu ý rằng trường password là null vì nó là transient.
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Error during deserialization: " + e.getMessage());
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn đang xây dựng một trình quản lý cấu hình đơn giản lưu trạng thái của nó vào một tệp.
1.  Tạo một lớp `Configuration` triển khai `Serializable`.
2.  Nó nên chứa một `Map<String, String>` để giữ các cặp key-value cấu hình.
3.  Nó cũng nên chứa một trường `transient` `Date` có tên `lastModified` không nên được lưu trữ.
4.  Tạo hai method:
    *   `void save(String filename)`: Serialize object `Configuration` vào tệp được chỉ định.
    *   `static Configuration load(String filename)`: Một static factory method deserialize và trả về một object `Configuration` từ một tệp.
5.  Trong `main`, tạo một object `Configuration`, thêm một số cài đặt, lưu nó, và sau đó tải nó lại vào một object mới để xác minh rằng map đã được lưu nhưng ngày `lastModified` thì không.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Mục đích của từ khóa `transient` trong Java là gì?

A) Nó đánh dấu một method là tạm thời và có thể bị xóa trong các phiên bản tương lai.
B) Nó chỉ ra rằng một trường nên được loại trừ khỏi quá trình serialization của object.
C) Nó khai báo rằng một biến không an toàn cho luồng và phải được truy cập trong một khối synchronized.
D) Nó được sử dụng để tạo một tệp được xóa tự động khi JVM thoát.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Nó chỉ ra rằng một trường nên được loại trừ khỏi quá trình serialization của object. Đây là mục đích duy nhất của modifier `transient`. Nó báo hiệu cho cơ chế serialization của JVM để bỏ qua trường khi chuyển đổi một object thành một byte stream.

### **Bài 5: Giới thiệu về NIO (New I/O)**

#### **1. Giải thích khái niệm**

##### **Tại sao NIO được tạo ra?**
Mô hình I/O ban đầu của Java (`java.io`), mặc dù đơn giản, có một hạn chế cơ bản: nó là **blocking và hướng stream**.
*   **Blocking:** Khi một luồng thực hiện một lời gọi `read()` hoặc `write()`, nó bị **chặn** cho đến khi hoạt động đó hoàn tất. Luồng không thể làm bất kỳ công việc nào khác. Trong một máy chủ có lưu lượng truy cập cao xử lý hàng nghìn client, việc dành một luồng cho mỗi client là cực kỳ không hiệu quả, vì hầu hết các luồng sẽ chỉ ngồi không, chờ đợi I/O.
*   **Stream-Oriented:** Dữ liệu được xử lý dưới dạng một luồng byte liên tục, mỗi lần một byte. Không có cách nào dễ dàng để di chuyển qua lại hoặc làm việc với dữ liệu theo từng khối.

**NIO (New I/O)**, được giới thiệu trong Java 1.4 (`java.nio`), được thiết kế để khắc phục những hạn chế này. Nó cung cấp một cách tiếp cận **non-blocking, hướng buffer** đối với I/O.

##### **NIO vs. I/O cổ điển: Các khác biệt cốt lõi**

| Tính năng | I/O cổ điển (`java.io`) | I/O mới (NIO) (`java.nio`) |
| :--- | :--- | :--- |
| **Hướng** | **Stream-oriented** (dữ liệu là một luồng liên tục) | **Buffer-oriented** (dữ liệu được đọc vào/từ các buffer) |
| **Mô hình Blocking** | **Blocking** (luồng chờ I/O hoàn tất) | **Non-blocking** (luồng có thể làm việc khác trong khi I/O đang diễn ra) |
| **Hướng** | Một chiều (riêng `InputStream` và `OutputStream`) | Hai chiều (một `Channel` duy nhất có thể được sử dụng cho cả đọc và ghi) |
| **Các Abstraction chính**| `InputStream`, `OutputStream`, `Reader`, `Writer` | **`Buffer`**, **`Channel`**, **`Selector`** |
| **Tốt nhất cho** | I/O đơn giản, tuần tự (ví dụ: đọc một tệp cấu hình). | Các ứng dụng mạng hiệu suất cao, đồng thời cao (ví dụ: máy chủ, proxy). |

##### **Ba trụ cột của NIO**

NIO được xây dựng xung quanh ba khái niệm cốt lõi mà bạn phải hiểu.

**1. Channels:**
*   Một `Channel` đại diện cho một kết nối đến một thực thể có khả năng thực hiện các hoạt động I/O, chẳng hạn như một tệp hoặc một socket mạng. Nó giống như một đường ống hoặc ống dẫn dữ liệu.
*   **Các triển khai chính:**
    *   `FileChannel`: Để đọc từ và ghi vào các tệp.
    *   `SocketChannel`: Cho các kết nối mạng TCP.
    *   `ServerSocketChannel`: Để lắng nghe các kết nối TCP đến.
    *   `DatagramChannel`: Cho các kết nối mạng UDP.
*   **Tính năng chính:** Channels là nguồn và đích cho dữ liệu, nhưng bạn không tương tác trực tiếp với chúng. Thay vào đó, bạn sử dụng một `Buffer`.

**2. Buffers:**
*   Một `Buffer` là một khối bộ nhớ có kích thước cố định hoạt động như một thùng chứa dữ liệu. Trong NIO, tất cả I/O được thực hiện thông qua các buffer. Dữ liệu trước tiên được đọc từ một channel **vào** một buffer, hoặc được ghi từ một buffer **đến** một channel.
*   **Cách hoạt động:** Một buffer về cơ bản là một trình bao bọc xung quanh một mảng nguyên thủy (`byte[]`, `char[]`, v.v.) cung cấp một cách có cấu trúc để quản lý dữ liệu. Nó duy trì một tập hợp bốn con trỏ nội bộ để theo dõi trạng thái của dữ liệu:
    *   **`capacity`:** Kích thước tổng thể của buffer. Nó không bao giờ thay đổi.
    *   **`limit`:** Chỉ số của phần tử đầu tiên *không nên* được đọc hoặc ghi. Nó là "kết thúc" của dữ liệu hoạt động.
    *   **`position`:** Chỉ số của phần tử tiếp theo sẽ được đọc hoặc ghi.
    *   **`mark`:** Một vị trí được ghi nhớ, được lưu bởi `mark()` và được khôi phục bởi `reset()`.
*   **Thao tác `flip()`:** Đây là thao tác buffer quan trọng nhất. Sau khi bạn đã viết xong dữ liệu vào một buffer, bạn phải gọi `flip()` trước khi bạn có thể đọc từ nó. `flip()` đặt `limit` thành `position` hiện tại và đặt lại `position` về `0`. Điều này thực chất chuẩn bị buffer cho một hoạt động "xả" (đọc).

**3. Selectors:**
*   Một `Selector` là chìa khóa cho **I/O non-blocking, ghép kênh (multiplexed)**. Nó cho phép một luồng duy nhất giám sát nhiều `Channel` cho các sự kiện I/O (ví dụ: "kết nối sẵn sàng," "dữ liệu có sẵn để đọc").
*   **Cách hoạt động:** Bạn "đăng ký" các channel của mình với một selector, chỉ định các sự kiện mà bạn quan tâm (ví dụ: `SelectionKey.OP_READ`). Sau đó, trong một vòng lặp, bạn gọi method `select()` của selector. Method này chặn cho đến khi ít nhất một trong các channel đã đăng ký sẵn sàng cho một hoạt động I/O.
*   **Lợi ích:** Điều này cho phép một luồng duy nhất quản lý hiệu quả hàng nghìn kết nối mạng đồng thời, đây là nền tảng của các máy chủ hiệu suất cao.

**Sơ đồ luồng dữ liệu NIO:**
```
+-----------+       read()       +----------+       write()       +-----------+
| Channel   | <----------------- |  Buffer  | ------------------> | Channel   |
| (ví dụ: Tệp)|  (Channel ghi     |          | (Mã của bạn ghi    | (ví dụ: Socket)|
|           |   vào Buffer)     |          |  từ Buffer)        |           |
+-----------+       (xả)         +----------+       (lấp đầy)     +-----------+
```

---

#### **2. Ví dụ mã nguồn: Đọc một tệp với `FileChannel` và `ByteBuffer`**

Ví dụ này cho thấy mẫu cơ bản của việc sử dụng một `Channel` để đọc dữ liệu vào một `Buffer`.

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class NioReadDemo {
    public static void main(String[] args) {
        // Sử dụng try-with-resources trên stream và channel
        try (FileInputStream fis = new FileInputStream("sample-text.txt");
             FileChannel channel = fis.getChannel()) {

            // 1. Cấp phát một buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024); // buffer 1 KB

            System.out.println("Reading from file...");

            // 2. Đọc dữ liệu từ channel vào buffer
            while (channel.read(buffer) > 0) {
                // Lời gọi read() lấp đầy buffer từ channel.
                // Nó trả về số byte đã đọc, hoặc -1 khi đến cuối luồng.

                // 3. Lật buffer để chuẩn bị cho việc đọc
                buffer.flip();

                // 4. Đọc dữ liệu từ buffer
                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get());
                }

                // 5. Xóa buffer để chuẩn bị cho lần đọc tiếp theo
                buffer.clear();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Viết một chương trình sử dụng `FileChannel` và `ByteBuffer` để ghi chuỗi "Hello, NIO!" vào một tệp có tên `nio-output.txt`.
1.  Tạo một `FileOutputStream` và lấy `FileChannel` của nó.
2.  Tạo một `ByteBuffer` và `put` các byte của chuỗi của bạn vào đó (`myString.getBytes()`).
3.  Hãy nhớ `flip()` buffer sau khi ghi vào nó, để chuẩn bị cho việc được channel đọc.
4.  Sử dụng method `channel.write(buffer)` để ghi nội dung của buffer vào tệp.
5.  Sử dụng `try-with-resources` để đảm bảo channel và stream được đóng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong Java NIO, mục đích chính của method `Buffer.flip()` là gì?

A) Để mã hóa nội dung của buffer trước khi ghi nó vào một channel.
B) Để chuyển một buffer từ chế độ ghi sang chế độ đọc bằng cách đặt `limit` thành `position` hiện tại và đặt lại `position` về 0.
C) Để xóa tất cả dữ liệu trong buffer, đặt lại nó về trạng thái trống ban đầu.
D) Để tạo một chế độ xem thứ tự đảo ngược của dữ liệu trong buffer.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Để chuyển một buffer từ chế độ ghi sang chế độ đọc bằng cách đặt `limit` thành `position` hiện tại và đặt lại `position` về 0. Đó là bước cần thiết để "niêm phong" dữ liệu bạn đã ghi vào buffer và chuẩn bị cho việc xả (đọc).

### **Bài 6: Làm việc với Channels và Buffers**

#### **1. Giải thích khái niệm**

Việc thành thạo NIO đòi hỏi một sự hiểu biết vững chắc về vòng đời và quản lý trạng thái của các object `Buffer`, cũng như các cách khác nhau mà các `Channel` có thể tương tác với chúng. Bài học này đi sâu hơn vào các cơ chế cốt lõi này.

##### **Quản lý trạng thái Buffer**
Như chúng ta đã học, một `Buffer` được điều khiển bởi bốn con trỏ: `mark`, `position`, `limit`, và `capacity`. Mối quan hệ luôn là: **`0 <= mark <= position <= limit <= capacity`**.

Hãy theo dõi trạng thái của một buffer qua một chu kỳ đọc/ghi điển hình.

**1. Trạng thái ban đầu (Cấp phát):**
Khi bạn cấp phát một buffer, các con trỏ của nó được đặt để ghi.
`ByteBuffer buffer = ByteBuffer.allocate(8);`
*   `position = 0` (Sẵn sàng để ghi ở đầu)
*   `limit = 8` (Bạn có thể ghi đến dung lượng tối đa)
*   `capacity = 8`

**2. Ghi vào Buffer:**
Bạn `put` dữ liệu vào buffer. `position` tiến lên.
`buffer.put((byte)'H').put((byte)'E').put((byte)'L').put((byte)'L').put((byte)'O');`
*   `position = 5`
*   `limit = 8`
*   `capacity = 8`

**3. Lật Buffer (Chuẩn bị để đọc):**
Bạn gọi `buffer.flip()`. Đây là bước quan trọng để chuyển từ ghi sang đọc.
*   `limit` được đặt thành `position` hiện tại.
*   `position` được đặt lại về `0`.
    `buffer.flip();`
*   `position = 0` (Sẵn sàng để đọc từ đầu)
*   `limit = 5` (Bạn chỉ có thể đọc 5 byte bạn đã ghi)
*   `capacity = 8`

**4. Đọc từ Buffer:**
Bạn `get` dữ liệu từ buffer. `position` lại tiến lên.
`buffer.get(); buffer.get();`
*   `position = 2`
*   `limit = 5`
*   `capacity = 8`

**5. Xóa hoặc Nén Buffer (Chuẩn bị để ghi lại):**
Bạn có hai lựa chọn chính để chuẩn bị buffer cho chu kỳ ghi tiếp theo.
*   **`clear()`:** Đặt lại buffer về trạng thái ban đầu của nó. Nó **không** xóa dữ liệu trong buffer; nó chỉ đơn giản là đặt lại các con trỏ.
    `buffer.clear();`
    *   `position = 0`
    *   `limit = 8` (Quay trở lại dung lượng tối đa)
    *   Đây là lựa chọn phổ biến nhất khi bạn đã xong với nội dung hiện tại của buffer.
*   **`compact()`:** Được sử dụng khi bạn chỉ đọc một phần buffer và muốn loại bỏ dữ liệu đã đọc nhưng giữ lại dữ liệu chưa đọc. Nó sao chép tất cả các byte chưa đọc (từ `position` đến `limit`) đến đầu buffer và sau đó đặt các con trỏ để ghi.
    *   Điều này hữu ích để xử lý dữ liệu theo từng khối.

##### **Direct vs. Non-Direct Buffers**

Khi bạn cấp phát một `ByteBuffer`, bạn có hai lựa chọn:
*   **Non-Direct Buffer (`ByteBuffer.allocate()`):**
    *   Đây là loại buffer tiêu chuẩn. Nó cấp phát một mảng `byte[]` trên **Java heap**.
    *   **Ưu điểm:** Được quản lý bởi bộ thu gom rác của JVM, dễ sử dụng.
    *   **Nhược điểm:** Khi buffer này được sử dụng trong một hoạt động I/O, JVM trước tiên phải sao chép nội dung của nó vào một buffer bộ nhớ gốc trung gian trước khi HĐH có thể thực hiện I/O. Việc sao chép thêm này có thể gây ra một chi phí hiệu suất.
*   **Direct Buffer (`ByteBuffer.allocateDirect()`):**
    *   Điều này cấp phát một khối bộ nhớ **bên ngoài Java heap**, trong bộ nhớ gốc.
    *   **Ưu điểm:** HĐH có thể thực hiện I/O trực tiếp trên buffer này mà không cần sao chép trung gian, điều này có thể nhanh hơn đáng kể cho các hoạt động I/O lớn, có khối lượng lớn. Điều này được biết đến như là **zero-copy** trong một số ngữ cảnh.
    *   **Nhược điểm:** Việc cấp phát và giải phóng bộ nhớ gốc tốn kém hơn so với bộ nhớ heap. Các buffer này không được thu gom rác theo cách tiêu chuẩn và có thể dẫn đến các vấn đề quản lý bộ nhớ nếu không được sử dụng cẩn thận.
*   **Trường hợp sử dụng tốt nhất:** Sử dụng **direct buffers** cho các buffer lớn, tồn tại lâu dài sẽ tham gia vào các hoạt động I/O thường xuyên (ví dụ: trong một máy chủ mạng). Sử dụng **non-direct buffers** cho các tác vụ I/O nhỏ hơn, tồn tại ngắn hạn, hoặc ít được sử dụng hơn.

##### **Scatter/Gather I/O**
NIO cung cấp một tính năng mạnh mẽ trong đó một `Channel` có thể đọc dữ liệu vào, hoặc ghi dữ liệu từ, nhiều buffer trong một hoạt động duy nhất.
*   **Scattering Read (`channel.read(ByteBuffer[] bufs)`):** Đọc các byte từ một channel vào một chuỗi các buffer. Nó lấp đầy buffer đầu tiên, sau đó là buffer thứ hai, và cứ thế. Điều này hữu ích để phân tích cú pháp dữ liệu có cấu trúc, nơi một tiêu đề đi vào một buffer và phần thân đi vào một buffer khác.
*   **Gathering Write (`channel.write(ByteBuffer[] bufs)`):** Ghi các byte vào một channel từ một chuỗi các buffer. Nó xả buffer đầu tiên, sau đó là buffer thứ hai, và cứ thế. Điều này hữu ích để lắp ráp một thông điệp từ các buffer tiêu đề, thân, và chân trang riêng biệt và gửi nó trong một lời gọi hệ thống duy nhất.

---

#### **2. Ví dụ mã nguồn: Ghi một tệp với `FileChannel`**

Mã này minh họa chu kỳ ghi: đặt dữ liệu, lật, ghi vào channel.

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;

public class NioWriteDemo {
    public static void main(String[] args) {
        try (FileOutputStream fos = new FileOutputStream("nio-output.txt");
             FileChannel channel = fos.getChannel()) {

            String text1 = "This is the first line.\n";
            String text2 = "This is the second line.";

            // Cấp phát một buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);

            // --- Ghi phần đầu tiên ---
            buffer.put(text1.getBytes(StandardCharsets.UTF_8));
            buffer.flip(); // Chuẩn bị để xả (ghi vào channel)
            while(buffer.hasRemaining()) {
                channel.write(buffer);
            }

            // --- Ghi phần thứ hai ---
            buffer.clear(); // Chuẩn bị để ghi lại vào buffer
            buffer.put(text2.getBytes(StandardCharsets.UTF_8));
            buffer.flip(); // Chuẩn bị để xả
            while(buffer.hasRemaining()) {
                channel.write(buffer);
            }

            System.out.println("File written successfully.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn được giao một tệp chứa một thông điệp có định dạng cố định:
*   4 byte đầu tiên là một số nguyên đại diện cho độ dài thông điệp.
*   Các byte còn lại là nội dung thông điệp (được mã hóa bằng UTF-8).

Nhiệm vụ của bạn là đọc thông điệp này bằng cách sử dụng một "scattering read."
1.  Tạo một tệp với cấu trúc này.
2.  Tạo hai `ByteBuffer`: một có dung lượng 4 (`headerBuffer`) và một cái khác có dung lượng lớn hơn (ví dụ: 1024, `bodyBuffer`).
3.  Đặt chúng vào một mảng `ByteBuffer`: `ByteBuffer[] buffers = { headerBuffer, bodyBuffer };`.
4.  Sử dụng `channel.read(buffers)` để đọc từ tệp vào cả hai buffer trong một hoạt động duy nhất.
5.  `flip()` cả hai buffer.
6.  Đọc số nguyên từ `headerBuffer` để lấy độ dài thông điệp.
7.  Đọc các byte từ `bodyBuffer`, giải mã chúng, và in thông điệp.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn có một `ByteBuffer` và bạn vừa viết xong dữ liệu vào đó bằng method `put()`. Bạn phải làm gì trước khi có thể truyền buffer này cho một method `channel.write()`?

A) Gọi `buffer.clear()` để đặt lại các con trỏ của buffer.
B) Gọi `buffer.rewind()` để di chuyển vị trí trở lại 0.
C) Gọi `buffer.compact()` để dịch chuyển dữ liệu về đầu.
D) Gọi `buffer.flip()` để đặt limit thành vị trí hiện tại và đặt lại vị trí về 0.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) Gọi `buffer.flip()`. Method `channel.write()` sẽ đọc (xả) dữ liệu từ buffer giữa `position` và `limit` của nó. Sau một hoạt động `put()`, `position` ở cuối dữ liệu đã ghi. `flip()` đặt `limit` thành vị trí này một cách chính xác và di chuyển `position` trở lại 0, xác định khối dữ liệu chính xác cần được ghi.

### **Bài 7: Selectors và I/O Non-blocking**

#### **1. Giải thích khái niệm**

Bài học này bao gồm phần mạnh mẽ và phức tạp nhất của NIO: `Selector`. Nó là động cơ cho phép một luồng duy nhất quản lý hàng nghìn kết nối mạng đồng thời, không chặn, tạo thành nền tảng của các máy chủ Java hiệu suất cao.

##### **Vấn đề với các mô hình máy chủ truyền thống**
Một thiết kế máy chủ mạng đơn giản, thường được gọi là "một luồng cho mỗi kết nối," dành một luồng cho mỗi client được kết nối.

```
Client 1 <--> Thread 1 (chặn trên read())
Client 2 <--> Thread 2 (chặn trên read())
...
Client 5000 <--> Thread 5000 (chặn trên read())
```
**Nhược điểm:**
1.  **Sử dụng tài nguyên cao:** Luồng rất tốn kém. Mỗi luồng tiêu thụ bộ nhớ đáng kể cho ngăn xếp của nó. Việc tạo ra hàng nghìn luồng có thể nhanh chóng làm cạn kiệt tài nguyên hệ thống.
2.  **Khả năng mở rộng kém:** Hầu hết thời gian, các luồng này đều không hoạt động, bị chặn chờ client gửi dữ liệu. Chúng đang tiêu thụ tài nguyên nhưng không làm việc gì.
3.  **Chi phí chuyển đổi ngữ cảnh:** Hệ điều hành dành rất nhiều thời gian để chuyển đổi giữa hàng nghìn luồng này, đây là một nút thắt cổ chai hiệu suất lớn.

##### **Giải pháp NIO: I/O Non-blocking với một Selector**
`Selector` của NIO cung cấp một cơ chế cho **I/O ghép kênh (multiplexing)**. Nó cho phép một luồng duy nhất giám sát nhiều `Channel` và được thông báo chỉ khi một trong số chúng sẵn sàng cho một hoạt động I/O (ví dụ: có dữ liệu để đọc hoặc sẵn sàng chấp nhận một ghi).

**Quy trình làm việc:**
1.  **Đặt các Channel ở chế độ Non-blocking:** Tất cả các socket channel (`SocketChannel`, `ServerSocketChannel`) mà bạn muốn giám sát phải được cấu hình ở chế độ non-blocking: `channel.configureBlocking(false);`.
2.  **Tạo một Selector:** Tạo một object `Selector` duy nhất: `Selector selector = Selector.open();`.
3.  **Đăng ký các Channel:** Đăng ký mỗi non-blocking channel với selector. Khi bạn đăng ký, bạn chỉ định "các hoạt động quan tâm" nào bạn muốn được thông báo.
    *   `SelectionKey.OP_READ`: Quan tâm đến các sự kiện đọc.
    *   `SelectionKey.OP_WRITE`: Quan tâm đến các sự kiện ghi.
    *   `SelectionKey.OP_CONNECT`: Quan tâm đến các sự kiện hoàn thành kết nối.
    *   `SelectionKey.OP_ACCEPT`: Quan tâm đến các sự kiện kết nối đến (cho `ServerSocketChannel`).
        Việc đăng ký trả về một object `SelectionKey`, đại diện cho việc đăng ký của một channel với một selector.
4.  **Vòng lặp sự kiện:** Luồng quản lý duy nhất đi vào một vòng lặp vô hạn. Bên trong vòng lặp:
    *   **Gọi `selector.select()`:** Đây là method quan trọng. Nó **chặn** cho đến khi ít nhất một trong các channel đã đăng ký sẵn sàng cho một trong các hoạt động mà nó quan tâm. Nó trả về số lượng các channel sẵn sàng.
    *   **Lấy các Key sẵn sàng:** Gọi `selector.selectedKeys()` để lấy một `Set` các object `SelectionKey` cho các channel đã sẵn sàng.
    *   **Xử lý các sự kiện:** Lặp qua tập hợp các key đã chọn. Đối với mỗi key, bạn xác định sự kiện nào nó sẵn sàng (`key.isReadable()`, `key.isAcceptable()`, v.v.) và thực hiện hoạt động I/O tương ứng (ví dụ: đọc dữ liệu từ channel vào một buffer). Các lời gọi I/O sẽ không bị chặn vì selector đã đảm bảo rằng chúng đã sẵn sàng.
    *   **Xóa Key:** Sau khi xử lý một key, bạn **phải** xóa nó khỏi tập hợp các key đã chọn: `iterator.remove()`. Selector chỉ thêm các key vào tập hợp; nó không bao giờ xóa chúng. Nếu bạn không xóa nó, cùng một key sẽ được xử lý lại trong lần lặp tiếp theo của vòng lặp.

**Sơ đồ của Mô hình Selector:**
```
+---------------------------------+
|          Luồng duy nhất         |
|    (Vòng lặp sự kiện / Dispatcher)    |
|                                 |
|      while (true) {             |
|        selector.select();  <--+ | Chặn cho đến khi một channel sẵn sàng
|        Set<SelectionKey> keys = | |
|           selector.selectedKeys();|
|        // Lặp và xử lý           |
|      }                          |
+---------------------------------+
        | giám sát
+---------------------------------+
|             Selector            |
+---------------------------------+
   | đăng ký | đăng ký | đăng ký
+-----------+ +-----------+ +-----------+
| Channel 1 | | Channel 2 | | Channel...|
| (Client A)| | (Client B)| | (Client N)|
+-----------+ +-----------+ +-----------+
```

---

#### **2. Ví dụ mã nguồn: Một máy chủ Echo Non-blocking đơn giản**

Đây là một ví dụ đơn giản nhưng hoàn chỉnh về một máy chủ có thể xử lý nhiều client với một luồng duy nhất.

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NioEchoServer {
    public static void main(String[] args) throws IOException {
        // 1. Tạo một Selector
        Selector selector = Selector.open();

        // 2. Tạo một ServerSocketChannel và cấu hình nó
        ServerSocketChannel serverSocket = ServerSocketChannel.open();
        serverSocket.bind(new InetSocketAddress("localhost", 5454));
        serverSocket.configureBlocking(false); // PHẢI là non-blocking

        // 3. Đăng ký ServerSocketChannel với Selector cho các sự kiện ACCEPT
        serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("Echo Server started on port 5454...");

        ByteBuffer buffer = ByteBuffer.allocate(256);

        // 4. Vòng lặp sự kiện
        while (true) {
            selector.select(); // Chặn cho đến khi một sự kiện xảy ra

            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                // Kiểm tra một sự kiện ACCEPT
                if (key.isAcceptable()) {
                    register(selector, serverSocket);
                }

                // Kiểm tra một sự kiện READ
                if (key.isReadable()) {
                    answerWithEcho(buffer, key);
                }

                // PHẢI xóa key sau khi xử lý
                iter.remove();
            }
        }
    }

    private static void register(Selector selector, ServerSocketChannel serverSocket) throws IOException {
        SocketChannel client = serverSocket.accept(); // Sẽ không bị chặn
        client.configureBlocking(false);
        client.register(selector, SelectionKey.OP_READ);
        System.out.println("Accepted new connection from: " + client.getRemoteAddress());
    }

    private static void answerWithEcho(ByteBuffer buffer, SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        int bytesRead = client.read(buffer);

        if (bytesRead == -1) { // Client đã đóng kết nối
            System.out.println("Connection closed by: " + client.getRemoteAddress());
            client.close();
            return;
        }

        System.out.println("Received " + bytesRead + " bytes from " + client.getRemoteAddress());
        buffer.flip();
        client.write(buffer); // Lặp lại dữ liệu
        buffer.clear();
    }
}
```

---

#### **3. Bài tập nhỏ**

Sửa đổi method `answerWithEcho` trong ví dụ máy chủ.
1.  Thay vì ngay lập tức lặp lại dữ liệu, máy chủ nên trước tiên chuyển đổi văn bản đến thành chữ hoa.
2.  Để làm điều này, bạn sẽ cần:
    *   Đọc các byte từ channel vào buffer.
    *   `flip()` buffer.
    *   Giải mã các byte thành một `String` (ví dụ: sử dụng `StandardCharsets.UTF_8.decode(buffer).toString()`).
    *   Chuyển đổi chuỗi thành chữ hoa.
    *   `clear()` buffer.
    *   `put` các byte của chuỗi chữ hoa mới trở lại vào buffer.
    *   `flip()` buffer một lần nữa.
    *   Ghi nội dung của buffer trở lại channel của client.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một vòng lặp sự kiện dựa trên `Selector` của NIO, tại sao việc gọi `iterator.remove()` sau khi xử lý một `SelectionKey` từ tập hợp các key đã chọn là bắt buộc?

A) Để đóng channel bên dưới được liên kết với key.
B) Để ngăn JVM hết bộ nhớ bằng cách xóa các key cũ.
C) Bởi vì selector chỉ thêm các key vào tập hợp nhưng không xóa chúng, việc không làm như vậy sẽ khiến cùng một sự kiện được xử lý lặp đi lặp lại trong một vòng lặp bận rộn.
D) Để hủy đăng ký channel khỏi selector.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Bởi vì selector chỉ thêm các key vào tập hợp nhưng không xóa chúng, việc không làm như vậy sẽ khiến cùng một sự kiện được xử lý lặp đi lặp lại trong một vòng lặp bận rộn. Tập hợp các key đã chọn là cơ chế mà qua đó lời gọi `select()` giao tiếp các sự kiện sẵn sàng với mã của bạn. Mã của bạn chịu trách nhiệm xác nhận rằng nó đã xử lý sự kiện bằng cách xóa key khỏi tập hợp.

### **Bài 8: API Files và Path (NIO.2)**

#### **1. Giải thích khái niệm**

Được giới thiệu trong Java 7, NIO.2 (package `java.nio.file`) là một API hiện đại, toàn diện, và mạnh mẽ hơn để tương tác với hệ thống tệp. Nó được thiết kế để khắc phục những hạn chế của lớp `java.io.File` kế thừa.

##### **`File` vs. `Path`: Tại sao lại có API mới?**

| Tính năng | `java.io.File` (Kế thừa) | `java.nio.file.Path` (Hiện đại) |
| :--- | :--- | :--- |
| **Xử lý lỗi** | Các method thường trả về `false` hoặc `null` khi thất bại, không cung cấp lý do. | Các method ném ra các `IOException` được kiểm tra, cụ thể (ví dụ: `NoSuchFileException`). |
| **Phụ thuộc nền tảng** | Dựa vào các dấu phân cách đường dẫn phụ thuộc vào hệ thống (`File.separator`). | Một sự trừu tượng hóa trên hệ thống tệp bên dưới, xử lý các khác biệt của HĐH một cách duyên dáng. |
| **Tính bất biến** | Có thể thay đổi (ví dụ: `renameTo()` sửa đổi đối tượng). | **Bất biến**. Các hoạt động trên một `Path` trả về một object `Path` mới. |
| **Chức năng** | Hạn chế. Thiếu hỗ trợ cho các liên kết tượng trưng, thuộc tính tệp, v.v. | Phong phú và mở rộng. Cung cấp các method mạnh mẽ để sao chép, di chuyển, duyệt cây, v.v. |

**Thực hành tốt nhất:** Trong tất cả các mã Java mới (phiên bản 7+), bạn nên **ưu tiên `Path` và `Files` hơn lớp `File`**.

##### **Các lớp `Path` và `Paths`**

*   **Interface `Path`:** Một `Path` là một object đại diện cho đường dẫn đến một tệp hoặc thư mục. Nó hoàn toàn là một biểu diễn trừu tượng và không yêu cầu tệp hoặc thư mục phải thực sự tồn tại.
*   **Lớp `Paths`:** Đây là một lớp factory với một method chính duy nhất, `get()`, được sử dụng để tạo các object `Path` từ một `String` hoặc `URI`.
    ```java
    Path p1 = Paths.get("/home/user/file.txt"); // Cho Linux/macOS
    Path p2 = Paths.get("C:\\Users\\User\\document.docx"); // Cho Windows
    ```

##### **Lớp tiện ích `Files`**

Đây là con ngựa thồ của API NIO.2. Nó là một lớp final chỉ bao gồm các method `static` hoạt động trên các object `Path`. Nó cung cấp một loạt các method mạnh mẽ, một dòng cho các hoạt động tệp phổ biến.

**Các Method chính của `Files`:**
*   **Tồn tại và các thuộc tính cơ bản:**
    *   `Files.exists(path)`
    *   `Files.notExists(path)`
    *   `Files.isDirectory(path)`
    *   `Files.isRegularFile(path)`
    *   `Files.size(path)`
*   **Tạo và Xóa:**
    *   `Files.createFile(path)`
    *   `Files.createDirectory(path)`
    *   `Files.createDirectories(path)` (Tạo các thư mục cha nếu chúng không tồn tại)
    *   `Files.delete(path)` (Ném ra một ngoại lệ nếu tệp không tồn tại)
    *   `Files.deleteIfExists(path)`
*   **Sao chép và Di chuyển:**
    *   `Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING)`
    *   `Files.move(source, target, StandardCopyOption.ATOMIC_MOVE)`
*   **Đọc và Ghi (Các trường hợp đơn giản):**
    *   `byte[] bytes = Files.readAllBytes(path)` (Cẩn thận với các tệp lớn!)
    *   `List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8)`
    *   `Files.write(path, bytes, StandardOpenOption.CREATE, StandardOpenOption.APPEND)`
    *   **Streams API:** `Stream<String> lineStream = Files.lines(path)` (Trả về một `Stream` lười biếng, tuyệt vời để xử lý các tệp lớn một cách hiệu quả).

##### **Duyệt thư mục: `DirectoryStream` và `FileVisitor`**

*   **`DirectoryStream`:** Một cách hiện đại và hiệu quả để lặp qua nội dung của một thư mục *duy nhất*. Nó được sử dụng bên trong một khối `try-with-resources` và hiệu quả hơn so với `file.list()` cũ vì nó có thể lấy nội dung một cách lười biếng.
*   **`Files.walk()` và `FileVisitor`:** `Files.walk(startPath)` trả về một `Stream<Path>` cho phép bạn duyệt qua một cây thư mục **đệ quy** theo một phong cách lười biếng, chức năng. Đối với logic duyệt phức tạp hơn, có trạng thái (như xóa toàn bộ một cây thư mục), bạn sử dụng `Files.walkFileTree(startPath, new MyFileVisitor())`. `FileVisitor` là một interface với các method như `preVisitDirectory`, `visitFile`, `postVisitDirectory` hoạt động như các callback trong quá trình duyệt.

---

#### **2. Ví dụ mã nguồn: Các hoạt động NIO.2 phổ biến**

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;
import java.util.stream.Stream;

public class Nio2FilesDemo {
    public static void main(String[] args) {
        // 1. Tạo một đối tượng Path
        Path dirPath = Paths.get("temp-data");
        Path filePath = dirPath.resolve("log.txt"); // Nối các đường dẫn

        try {
            // 2. Tạo các thư mục và tệp
            if (Files.notExists(dirPath)) {
                Files.createDirectories(dirPath); // Tạo 'temp-data'
                System.out.println("Directory created.");
            }
            if (Files.notExists(filePath)) {
                Files.createFile(filePath);
                System.out.println("File created.");
            }

            // 3. Ghi nội dung vào tệp (cách đơn giản)
            List<String> linesToWrite = List.of("line 1", "line 2", "line 3");
            Files.write(filePath, linesToWrite, StandardCharsets.UTF_8, StandardOpenOption.APPEND);
            System.out.println("\nWrote lines to file.");

            // 4. Đọc nội dung từ tệp (cách đơn giản)
            System.out.println("\nReading all lines from file:");
            List<String> linesRead = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            linesRead.forEach(System.out::println);

            // 5. Xử lý một tệp lớn một cách hiệu quả với Streams API
            System.out.println("\nProcessing file with Stream API:");
            try (Stream<String> lineStream = Files.lines(filePath)) {
                lineStream.filter(line -> line.contains("2"))
                          .forEach(line -> System.out.println("Found line with '2': " + line));
            }

            // 6. Sao chép tệp
            Path copiedFilePath = dirPath.resolve("log_copy.txt");
            Files.copy(filePath, copiedFilePath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("\nFile copied to: " + copiedFilePath.getFileName());

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Viết một chương trình tìm kiếm đệ quy tất cả các tệp có phần mở rộng `.java` trong một thư mục đã cho (ví dụ: thư mục `src` của dự án của bạn).
1.  Chương trình nên nhận đường dẫn thư mục bắt đầu làm đối số dòng lệnh.
2.  Sử dụng `Files.walk(startPath)` để lấy một stream của tất cả các đường dẫn trong cây thư mục.
3.  Sử dụng method `filter()` của Stream API để tìm chỉ những đường dẫn đại diện cho các tệp thông thường và có tên tệp kết thúc bằng `.java`.
4.  Sử dụng method `forEach()` để in đường dẫn tuyệt đối của mỗi tệp khớp.
5.  Bao bọc lời gọi `Files.walk()` trong một khối `try-with-resources`, vì `Stream` được trả về là `AutoCloseable`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn cần đọc một tệp log 5 GB và đếm xem có bao nhiêu dòng chứa từ "ERROR". Method `java.nio.file.Files` nào là hiệu quả nhất về bộ nhớ cho tác vụ này?

A) `Files.readAllBytes(path)`
B) `Files.readAllLines(path)`
C) `Files.newInputStream(path)`
D) `Files.lines(path)`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `Files.lines(path)`. Method này hiệu quả nhất về bộ nhớ vì nó trả về một `Stream<String>` đọc tệp một cách **lười biếng**. Nó xử lý tệp từng dòng một mà không tải toàn bộ tệp 5 GB vào bộ nhớ. Ngược lại, `readAllBytes` và `readAllLines` đều sẽ cố gắng tải toàn bộ tệp, gần như chắc chắn gây ra một `OutOfMemoryError`. `newInputStream` là một cách hợp lệ để bắt đầu, nhưng `Files.lines` là một sự trừu tượng hóa cấp cao hơn hoàn toàn phù hợp cho vấn đề cụ thể này.

### **Bài 9: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Bài học kết luận này tóm tắt những khác biệt chính giữa các mô hình I/O của Java, cung cấp một bộ các câu hỏi phỏng vấn phổ biến để kiểm tra kiến thức của bạn, và đưa ra một dự án cuối cùng để áp dụng những gì bạn đã học.

---

#### **1. Bảng tóm tắt: I/O cổ điển vs. NIO**

| Tính năng | I/O cổ điển (`java.io`) | I/O mới (NIO) (`java.nio`) |
| :--- | :--- | :--- |
| **Mô hình** | **Hướng stream:** Dữ liệu là một luồng một chiều, liên tục. | **Hướng buffer:** Dữ liệu được đọc vào/từ các buffer, cho phép kiểm soát nhiều hơn. |
| **Mô hình chặn** | **Blocking:** Một luồng bị chặn trên một lời gọi đọc/ghi cho đến khi nó hoàn tất. | **Hỗ trợ non-blocking:** Một luồng có thể yêu cầu một đọc/ghi và làm việc khác, kiểm tra sau xem hoạt động đã hoàn tất chưa. |
| **Hướng** | **Một chiều:** Các lớp riêng biệt cho đầu vào (`InputStream`) và đầu ra (`OutputStream`). | **Hai chiều:** Một `Channel` duy nhất có thể xử lý cả việc đọc và ghi. |
| **Các Abstraction cốt lõi** | `InputStream`, `OutputStream`, `Reader`, `Writer`, `File` | `Channel`, `Buffer`, `Selector`, `Path`, `Files` |
| **Mô hình đồng thời** | 1 luồng cho mỗi kết nối (thường là vậy). Khả năng mở rộng kém cho nhiều kết nối. | 1 luồng cho nhiều kết nối (thông qua `Selector`). Khả năng mở rộng tuyệt vời. |
| **API hệ thống tệp**| `java.io.File`: Hạn chế, xử lý lỗi kém, phụ thuộc vào nền tảng. | `java.nio.file.Path`/`Files`: Phong phú, bất biến, xử lý lỗi tốt hơn, độc lập với nền tảng. |
| **Hiệu suất** | Tốt cho I/O đơn giản, tuần tự. Việc đệm là cần thiết (`Buffered...`). | Vượt trội cho I/O mạng đồng thời, khối lượng lớn và thao tác tệp lớn (ví dụ: tệp ánh xạ bộ nhớ). |
| **Trường hợp sử dụng tốt nhất** | Đọc/ghi tệp đơn giản, xử lý các luồng dữ liệu tuần tự. | Xây dựng các máy chủ mạng hiệu suất cao (máy chủ HTTP, máy chủ trò chuyện), xử lý nhiều kết nối với ít luồng. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Sự khác biệt chính giữa byte streams và character streams là gì?"**
    *   *Trả lời:* Byte streams xử lý dữ liệu nhị phân thô (byte 8-bit) và phù hợp với mọi loại tệp. Character streams xử lý dữ liệu văn bản (ký tự Unicode 16-bit) và tự động quản lý việc dịch giữa các byte và các ký tự bằng một bộ ký tự được chỉ định. Bạn nên luôn sử dụng character streams cho văn bản để tránh các vấn đề về mã hóa.

2.  **"Mẫu Decorator trong ngữ cảnh của `java.io` là gì, và tại sao nó hữu ích?"**
    *   *Trả lời:* Mẫu Decorator được sử dụng để thêm chức năng vào một stream bằng cách bao bọc nó trong một stream khác. Ví dụ, một `FileInputStream` cung cấp việc đọc tệp cơ bản, nhưng bạn có thể bao bọc nó trong một `BufferedInputStream` để thêm đệm cho hiệu suất, sau đó có thể được bao bọc trong một `ObjectInputStream` để thêm khả năng deserialization object. Điều này cung cấp một cách linh hoạt để kết hợp các chức năng.

3.  **"Ba thành phần cốt lõi của Java NIO là gì, và vai trò của mỗi thành phần là gì?"**
    *   *Trả lời:* Ba thành phần cốt lõi là **Channels**, **Buffers**, và **Selectors**. Một `Channel` là một ống dẫn dữ liệu, đại diện cho một kết nối đến một tệp hoặc socket. Một `Buffer` là một khối bộ nhớ mà dữ liệu được đọc vào hoặc ghi từ đó; tất cả I/O trong NIO đều diễn ra thông qua các buffer. Một `Selector` là chìa khóa cho I/O non-blocking, cho phép một luồng duy nhất giám sát nhiều channel cho các sự kiện I/O.

4.  **"Giải thích mục đích của `flip()` trong một `ByteBuffer`."**
    *   *Trả lời:* Method `flip()` chuyển một buffer từ chế độ ghi sang chế độ đọc. Sau khi bạn đã ghi dữ liệu vào một buffer, `position` ở cuối dữ liệu bạn đã ghi. `flip()` đặt `limit` thành vị trí đó và đặt lại `position` về 0. Điều này chuẩn bị cho buffer được xả (đọc) từ đầu dữ liệu bạn vừa ghi.

5.  **"Một máy chủ non-blocking là gì, và một `Selector` làm thế nào để cho phép điều này?"**
    *   *Trả lời:* Một máy chủ non-blocking sử dụng một luồng duy nhất (hoặc một vài luồng) để xử lý nhiều kết nối client đồng thời mà không bị chặn trên các hoạt động I/O. Một `Selector` cho phép điều này bằng cách cho phép một luồng đó giám sát nhiều channel. Luồng gọi `selector.select()`, nó sẽ chặn cho đến khi *ít nhất một* trong các channel được giám sát sẵn sàng cho một hoạt động I/O. Luồng sau đó chỉ phục vụ các channel đã sẵn sàng và quay lại chờ đợi, không bao giờ bị kẹt trên một client chưa sẵn sàng.

6.  **"API `Path` của NIO.2 có những ưu điểm gì so với lớp `java.io.File` cũ?"**
    *   *Trả lời:* API `Path` vượt trội ở một số mặt: nó cung cấp xử lý lỗi tốt hơn bằng cách ném ra các `IOException` cụ thể thay vì trả về `null` hoặc `false`; nó là bất biến và an toàn cho luồng; nó có một bộ method phong phú hơn cho các hoạt động tệp (sao chép, di chuyển, duyệt cây) thông qua lớp `Files`; và nó xử lý tốt hơn các chi tiết dành riêng cho nền tảng.

---

#### **3. Dự án nhỏ cuối cùng: Tiện ích sao chép tệp hiệu suất cao**

Dự án này sẽ thách thức bạn triển khai một tiện ích sao chép tệp bằng ba kỹ thuật khác nhau, cho phép bạn so sánh việc triển khai và hiệu suất của chúng.

**🎯 Mục tiêu:** Tạo một tiện ích dòng lệnh sao chép một tệp từ một nguồn đến một đích bằng các chiến lược I/O khác nhau.

**Yêu cầu dự án:**

1.  **Lớp chính:**
    *   Method `main` nên chấp nhận ba đối số dòng lệnh: `[strategy] [source_file] [destination_file]`.
    *   `strategy` có thể là một trong ba giá trị: `io`, `nio`, hoặc `niomap`.
    *   Chương trình nên đo và in thời gian thực hiện cho hoạt động sao chép.

2.  **Chiến lược 1: I/O cổ điển với đệm (`io`)**
    *   Triển khai một method sao chép bằng `FileInputStream` và `FileOutputStream`.
    *   Bạn **phải** bao bọc chúng trong `BufferedInputStream` và `BufferedOutputStream` để có hiệu suất tốt.
    *   Sử dụng một bộ đệm mảng byte (ví dụ: 8192 byte) để đọc từ đầu vào và ghi ra đầu ra trong một vòng lặp.
    *   Sử dụng `try-with-resources` để đảm bảo các stream được đóng.

3.  **Chiến lược 2: NIO với `FileChannel` và `ByteBuffer` (`nio`)**
    *   Triển khai một method sao chép bằng `FileChannel`.
    *   Lấy một read channel từ một `FileInputStream` và một write channel từ một `FileOutputStream`.
    *   Sử dụng một `ByteBuffer` để truyền dữ liệu. Trong một vòng lặp, đọc từ source channel vào buffer, `flip()` buffer, và ghi từ buffer vào destination channel.
    *   Hãy nhớ `clear()` hoặc `compact()` buffer sau mỗi lần ghi.
    *   Sử dụng `try-with-resources`.

4.  **Chiến lược 3: NIO với `FileChannel.transferTo()` (`niomap` - một tên gọi không chính xác, nhưng cho dự án)**
    *   Đây là cách tiếp cận được tối ưu hóa nhất.
    *   Triển khai một method sao chép bằng `FileChannel`.
    *   Sử dụng method `sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel)`.
    *   Lời gọi method duy nhất này được tối ưu hóa cao. Trên nhiều hệ điều hành, nó có thể thực hiện một truyền **zero-copy**, di chuyển dữ liệu trực tiếp từ đĩa đến card mạng hoặc một vị trí đĩa khác trong không gian kernel, tránh được chi phí sao chép dữ liệu vào không gian người dùng của ứng dụng.
    *   Method này nên là nhanh nhất đối với các tệp lớn.

**Cách chạy và kiểm tra:**
*   Tạo một tệp giả lớn để kiểm tra (ví dụ: 500 MB hoặc 1 GB).
*   Chạy chương trình của bạn với mỗi trong ba chiến lược và so sánh thời gian thực hiện.

**Ví dụ dòng lệnh:**
```bash
java FileCopier io large_video.mp4 large_video_copy.mp4
# Time taken (io): 1234 ms

java FileCopier nio large_video.mp4 large_video_copy.mp4
# Time taken (nio): 876 ms

java FileCopier niomap large_video.mp4 large_video_copy.mp4
# Time taken (niomap): 150 ms
```

Dự án này cung cấp một sự so sánh trực tiếp, thực tế về các kỹ thuật I/O chính trong Java và củng cố các khái niệm về stream, buffer, channel, và tối ưu hóa hiệu suất.
