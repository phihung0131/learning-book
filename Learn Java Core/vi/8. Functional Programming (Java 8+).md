### **Bài 1: Giới thiệu về Lập trình hàm & Lambda**

#### **1. Giải thích khái niệm**

##### **Lập trình hàm (FP) là gì?**
Lập trình hàm là một mô hình lập trình coi việc tính toán như là sự đánh giá của các hàm toán học và tránh thay đổi trạng thái và dữ liệu có thể thay đổi. Đó là một phong cách lập trình **khai báo** ("làm gì") thay vì phong cách **mệnh lệnh** ("làm thế nào").

| Mệnh lệnh (OOP) | Khai báo (FP) |
| :--- | :--- |
| **Làm thế nào:** "Tạo một vòng lặp, khởi tạo một bộ đếm, lặp từ 0 đến 9, lấy phần tử tại chỉ số hiện tại, kiểm tra xem nó có chẵn không, nếu có, thêm nó vào một danh sách mới." | **Làm gì:** "Cho tôi một danh sách tất cả các số chẵn từ danh sách ban đầu." |

**Các nguyên lý cốt lõi của FP:**
*   **Hàm thuần túy (Pure Functions):** Đầu ra của một hàm chỉ phụ thuộc vào các đối số đầu vào của nó, và nó không có tác dụng phụ có thể quan sát được (như sửa đổi một biến toàn cục, ghi vào một tệp, v.v.).
*   **Tính bất biến (Immutability):** Các cấu trúc dữ liệu không bị sửa đổi sau khi chúng được tạo ra. "Các thay đổi" dẫn đến việc tạo ra các cấu trúc dữ liệu mới.
*   **Hàm hạng nhất (First-Class Functions):** Các hàm được đối xử như bất kỳ biến nào khác. Chúng có thể được truyền làm đối số cho các hàm khác, được trả về như các giá trị từ các hàm, và được lưu trữ trong các cấu trúc dữ liệu. Đây là nền tảng của cách FP được triển khai trong Java.

##### **Biểu thức Lambda: Hàm như là biến**
Một **biểu thức lambda** là một hàm ẩn danh (không tên). Nó cho phép bạn đối xử với chức năng như một đối số của method, hoặc mã như là dữ liệu. Lambda là cách của Java để kích hoạt "các hàm hạng nhất".

**Cấu trúc của một biểu thức Lambda:**
```
(parameter1, parameter2) -> { // khối mã }
```
1.  **Tham số:** `(parameter1, parameter2)` - Một danh sách các tham số cho hàm. Suy luận kiểu thường cho phép bạn bỏ qua các kiểu.
2.  **Mũi tên:** `->` - Phân tách các tham số khỏi phần thân.
3.  **Thân:** `{ // khối mã }` - Việc triển khai của hàm. Nếu phần thân là một biểu thức duy nhất, bạn có thể bỏ qua các dấu ngoặc nhọn và từ khóa `return`.

**Sự tiến hóa từ Lớp nội ẩn danh đến Lambda:**
Trước Java 8, nếu bạn muốn truyền hành vi, bạn phải sử dụng một lớp nội ẩn danh dài dòng.

```java
// Trước Java 8: Lớp nội ẩn danh
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello from anonymous class!");
    }
};

// Java 8: Biểu thức Lambda
// Trình biên dịch biết 'r2' là một Runnable, có một method trừu tượng, run(), không nhận đối số nào.
Runnable r2 = () -> System.out.println("Hello from lambda!");
```

##### **Biến được Capture: Quy tắc "Effectively Final"**
Một biểu thức lambda có thể truy cập các biến từ phạm vi bao quanh nó (method xung quanh). Điều này được gọi là "capturing". Tuy nhiên, có một quy tắc nghiêm ngặt: một lambda chỉ có thể truy cập các biến cục bộ là **final** hoặc **effectively final**.

*   **Effectively Final:** Một biến là effectively final nếu giá trị của nó không bao giờ thay đổi sau khi nó được khởi tạo.

**Tại sao lại có quy tắc này?** Quy tắc này tồn tại để ngăn chặn các vấn đề đồng thời và duy trì một hợp đồng rõ ràng. Nếu một lambda có thể sửa đổi một biến cục bộ, nó sẽ tạo ra các vấn đề phức tạp nếu lambda được thực thi trên một luồng khác rất lâu sau khi method ban đầu đã kết thúc. Bằng cách thực thi quy tắc "effectively final", Java đảm bảo rằng lambda chỉ đang capture một *giá trị* cố định, không phải là một biến có thể thay đổi.

##### **Tham chiếu Method (Method References)**
Một tham chiếu method là một cú pháp viết tắt, dễ đọc hơn cho một biểu thức lambda chỉ gọi một method duy nhất, đã tồn tại. Có bốn loại chính:

1.  **Tham chiếu Method Static:** `ClassName::staticMethodName`
    *   `str -> Integer.parseInt(str)` trở thành `Integer::parseInt`
2.  **Tham chiếu Method Instance (trên một instance cụ thể):** `instance::instanceMethodName`
    *   `() -> myPrinter.println()` trở thành `myPrinter::println`
3.  **Tham chiếu Method Instance (trên một object tùy ý của một loại):** `ClassName::instanceMethodName`
    *   `(s1, s2) -> s1.compareToIgnoreCase(s2)` trở thành `String::compareToIgnoreCase`
4.  **Tham chiếu Constructor:** `ClassName::new`
    *   `() -> new ArrayList<>()` trở thành `ArrayList::new`

---

#### **2. Ví dụ mã nguồn**

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class LambdasAndMethodRefsDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("alice", "bob", "charlie");

        // --- 1. Phong cách mệnh lệnh (Trước Java 8) ---
        List<String> upperCaseNamesImperative = new ArrayList<>();
        for (String name : names) {
            upperCaseNamesImperative.add(name.toUpperCase());
        }
        System.out.println("Imperative: " + upperCaseNamesImperative);


        // --- 2. Phong cách hàm với Lambda ---
        // Sử dụng Stream API, chúng ta sẽ đề cập chi tiết sau.
        // Lambda 'name -> name.toUpperCase()' được truyền như một hành vi.
        List<String> upperCaseNamesLambda = names.stream()
                                                 .map(name -> name.toUpperCase())
                                                 .toList(); // .toList() là từ Java 16+
        System.out.println("Lambda:     " + upperCaseNamesLambda);


        // --- 3. Phong cách hàm với Tham chiếu Method ---
        // 'String::toUpperCase' là một phiên bản dễ đọc hơn của lambda ở trên.
        List<String> upperCaseNamesMethodRef = names.stream()
                                                    .map(String::toUpperCase)
                                                    .toList();
        System.out.println("Method Ref: " + upperCaseNamesMethodRef);


        // --- Biến được Capture ---
        String prefix = "User: ";
        // Lambda 'name -> System.out.println(prefix + name)' capture 'prefix'.
        // Điều này được cho phép vì 'prefix' là effectively final.
        names.forEach(name -> System.out.println(prefix + name));
        
        // Nếu bạn cố gắng thay đổi prefix, mã sẽ không biên dịch:
        // prefix = "Guest: "; // LỖI BIÊN DỊCH
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một `List<String>`.
1.  Sắp xếp danh sách theo thứ tự bảng chữ cái bằng cách sử dụng `list.sort()`. Cung cấp một biểu thức lambda cho logic so sánh.
2.  Bây giờ, hãy sắp xếp cùng một danh sách theo độ dài của các chuỗi, từ ngắn nhất đến dài nhất.
3.  Cuối cùng, hãy sắp xếp lại danh sách theo độ dài, nhưng lần này theo thứ tự giảm dần (dài nhất đến ngắn nhất).
4.  Đối với bước đầu tiên (sắp xếp theo thứ tự bảng chữ cái), hãy thử viết lại lambda `(s1, s2) -> s1.compareTo(s2)` bằng cách sử dụng một tham chiếu method.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều nào sau đây **không phải** là một biểu thức lambda hợp lệ?

A) `() -> {}`
B) `s -> s.length()`
C) `(int x, int y) -> return x + y;`
D) `(x, y) -> x + y`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `(int x, int y) -> return x + y;`. Khi phần thân của một lambda là một biểu thức duy nhất, bạn không thể sử dụng dấu ngoặc nhọn `{}` hoặc từ khóa `return`. Nó nên được viết như trong D: `(x, y) -> x + y`. Nếu bạn muốn sử dụng từ khóa `return`, bạn phải đặt phần thân trong dấu ngoặc nhọn: `(int x, int y) -> { return x + y; }`.

### **Bài 3: Các nguyên tắc cơ bản của Stream API**

#### **1. Giải thích khái niệm**

##### **Stream vs. Collection: Một sự thay đổi về mặt khái niệm**
Đây là khái niệm quan trọng nhất cần nắm bắt. Một `Stream` **không phải** là một cấu trúc dữ liệu. Một `Collection` là một cấu trúc dữ liệu; nó là một thùng chứa dữ liệu trong bộ nhớ.

*   Một **`Collection`** là về **dữ liệu**. Bạn có thể thêm vào, xóa khỏi nó, và hỏi kích thước của nó.
*   Một **`Stream`** là về **tính toán**. Nó là một chuỗi các phần tử từ một nguồn hỗ trợ các hoạt động tổng hợp. Nó đại diện cho một "chế độ xem" của dữ liệu, không phải là chính dữ liệu.

**Ví dụ tương tự:**
*   Một **`Collection`** giống như một **chai nước**. Tất cả nước (dữ liệu) đều có mặt vật lý trong chai.
*   Một **`Stream`** giống như một **dòng sông**. Nước (dữ liệu) chảy qua nó. Bạn có thể đặt các bộ lọc, tua-bin, và vòi nước (các hoạt động) dọc theo dòng sông để xử lý nước khi nó đi qua, nhưng chính dòng sông không lưu trữ nước.

**Các khác biệt chính:**
1.  **Không lưu trữ:** Stream không lưu trữ các phần tử.
2.  **Bất biến:** Một pipeline của stream không sửa đổi nguồn dữ liệu cơ bản của nó (collection). Việc lọc một stream tạo ra một stream mới với các kết quả đã lọc; nó không xóa các phần tử khỏi collection ban đầu.
3.  **Đánh giá lười biếng (Lazy Evaluation):** Đây là chìa khóa cho hiệu suất của một stream. Các hoạt động trung gian không được thực thi ngay lập tức. Chúng chỉ được thực thi khi một hoạt động cuối (terminal operation) được gọi.
4.  **Có thể vô hạn:** Bởi vì chúng lười biếng, stream có thể đại diện cho các chuỗi dữ liệu vô hạn (ví dụ: một stream của tất cả các số nguyên tố). Một collection thì không thể.
5.  **Có thể tiêu thụ (Sử dụng một lần):** Một stream chỉ có thể được duyệt qua một lần. Sau khi một hoạt động cuối được gọi, stream bị "tiêu thụ" và không thể được sử dụng lại.

##### **Cấu trúc Pipeline của Stream**
Mọi hoạt động của stream đều tuân theo một pipeline ba giai đoạn:
**Nguồn → (Các) Hoạt động trung gian → Hoạt động cuối**

```
  +------------------+
  |      Nguồn      |  (ví dụ: một List, một Array, một tệp)
  +------------------+
          |
          v
+--------------------+
|  filter(...)       |  <-- Hoạt động trung gian (lười biếng)
+--------------------+
          |
          v
+--------------------+
|  map(...)          |  <-- Hoạt động trung gian (lười biếng)
+--------------------+
          |
          v
+--------------------+
|  collect(...)      |  <-- Hoạt động cuối (kích hoạt thực thi)
+--------------------+
          |
          v
  +------------------+
  |      Kết quả     |  (ví dụ: một List mới, một số đếm, một giá trị duy nhất)
  +------------------+```
1.  **Nguồn:** Nơi stream lấy các phần tử của nó. Đây có thể là một `Collection`, một mảng, một hàm tạo, hoặc một kênh I/O.
2.  **Hoạt động trung gian:** Đây là các hoạt động biến đổi một stream thành một stream khác. Chúng luôn **lười biếng**. Chúng không thực hiện bất kỳ xử lý nào cho đến khi một hoạt động cuối được gọi. Các ví dụ bao gồm `filter`, `map`, `sorted`, `distinct`.
3.  **Hoạt động cuối:** Đây là hoạt động kích hoạt việc thực thi của toàn bộ pipeline và tạo ra một kết quả hoặc một tác dụng phụ. Sau khi hoạt động cuối hoàn tất, stream không thể được sử dụng lại. Các ví dụ bao gồm `collect`, `forEach`, `reduce`, `count`.

##### **Đánh giá lười biếng và Lặp nội bộ đang hoạt động**
Hãy xem xét đoạn mã này:
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Anna");

names.stream()
     .filter(s -> {
         System.out.println("Filtering: " + s);
         return s.startsWith("A");
     })
     .map(s -> {
         System.out.println("Mapping: " + s);
         return s.toUpperCase();
     })
     .forEach(s -> System.out.println("ForEach: " + s));
```
Một quan niệm sai lầm phổ biến là mã này trước tiên sẽ lọc tất cả các tên, sau đó ánh xạ tất cả các tên đã lọc, và sau đó in chúng ra. Điều này là **không chính xác**.

Do đánh giá lười biếng, stream xử lý các phần tử **theo chiều dọc**, không phải theo chiều ngang. Hoạt động cuối `forEach` kéo các phần tử từng cái một qua toàn bộ pipeline.

**Luồng thực thi thực tế:**
1.  `forEach` yêu cầu một phần tử.
2.  `map` yêu cầu `filter` một phần tử.
3.  `filter` lấy "Alice" từ nguồn. Nó vượt qua bộ lọc (`Filtering: Alice`).
4.  `filter` gửi "Alice" đến `map`.
5.  `map` biến đổi "Alice" thành "ALICE" (`Mapping: Alice`).
6.  `map` gửi "ALICE" đến `forEach`.
7.  `forEach` in "ALICE" (`ForEach: ALICE`).
---
8.  `forEach` yêu cầu phần tử tiếp theo.
9.  `map` yêu cầu `filter` một phần tử.
10. `filter` lấy "Bob". Nó không vượt qua bài kiểm tra bộ lọc (`Filtering: Bob`).
11. `filter` yêu cầu nguồn phần tử tiếp theo.
---
12. `filter` lấy "Charlie". Nó không vượt qua bài kiểm tra bộ lọc (`Filtering: Charlie`).
13. `filter` yêu cầu nguồn phần tử tiếp theo.
---
14. `filter` lấy "Anna". Nó vượt qua bộ lọc (`Filtering: Anna`).
15. `filter` gửi "Anna" đến `map`.
16. `map` biến đổi "Anna" thành "ANNA" (`Mapping: Anna`).
17. `map` gửi "ANNA" đến `forEach`.
18. `forEach` in "ANNA" (`ForEach: ANNA`).

---

#### **2. Ví dụ mã nguồn: Tạo Stream**

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;
import java.util.stream.Stream;

public class StreamCreationDemo {
    public static void main(String[] args) {
        // 1. Từ một Collection
        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> streamFromList = list.stream();
        System.out.print("From List: ");
        streamFromList.forEach(s -> System.out.print(s + " "));

        // 2. Từ một Array
        String[] array = {"x", "y", "z"};
        Stream<String> streamFromArray = Arrays.stream(array);
        System.out.print("\nFrom Array: ");
        streamFromArray.forEach(s -> System.out.print(s + " "));

        // 3. Từ các giá trị riêng lẻ
        Stream<Integer> streamOfValues = Stream.of(1, 2, 3, 4, 5);
        System.out.print("\nFrom Values: ");
        streamOfValues.forEach(i -> System.out.print(i + " "));

        // 4. Một stream vô hạn sử dụng iterate()
        // Tạo một stream của các số chẵn: 0, 2, 4, 6, ...
        Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);
        System.out.print("\nFirst 5 even numbers from infinite stream: ");
        // Chúng ta PHẢI sử dụng một hoạt động ngắn mạch như limit() trên một stream vô hạn.
        infiniteStream.limit(5).forEach(i -> System.out.print(i + " "));

        // 5. Stream nguyên thủy (tránh boxing)
        IntStream intStream = IntStream.range(1, 4); // Range là độc quyền cho điểm cuối
        System.out.print("\nFrom IntStream.range(1, 4): ");
        intStream.forEach(i -> System.out.print(i + " "));
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một `List<String>`.
1.  Tạo một stream từ danh sách này.
2.  Nối chuỗi hai hoạt động trung gian:
    *   `filter()` để chỉ giữ lại các chuỗi có độ dài lớn hơn 3.
    *   `limit()` để chỉ giữ lại 2 phần tử đầu tiên vượt qua bộ lọc.
3.  Thêm một hoạt động cuối `forEach()` để in các chuỗi kết quả cuối cùng.
4.  Trước hoạt động cuối, hãy thêm một hoạt động `peek(s -> System.out.println("Inspecting: " + s))` sau `filter` để xem các phần tử nào đang được xử lý.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều gì sẽ xảy ra nếu bạn cố gắng sử dụng một stream sau khi một hoạt động cuối đã được gọi trên nó?

A) Stream sẽ tự động đặt lại và có thể được sử dụng lại.
B) Stream sẽ chạy lại pipeline với cùng một kết quả.
C) Nó sẽ ném ra một `IllegalStateException`.
D) Nó sẽ dẫn đến một `NullPointerException`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Nó sẽ ném ra một `IllegalStateException`. Stream là để sử dụng một lần. Sau khi một hoạt động cuối được gọi, stream được coi là "đã tiêu thụ" hoặc "đã đóng", và bất kỳ nỗ lực nào tiếp theo để hoạt động trên nó sẽ dẫn đến một `IllegalStateException`.

### **Bài 4: Các hoạt động trung gian và cuối của Stream**

#### **1. Giải thích khái niệm**

Bài học này đi sâu vào các "động từ" của Stream API—các hoạt động bạn có thể thực hiện trên dữ liệu khi nó chảy qua pipeline.

##### **Các hoạt động trung gian (Lười biếng và Stream-vào, Stream-ra)**

Các hoạt động này là các khối xây dựng của pipeline chuyển đổi dữ liệu của bạn. Mỗi cái nhận một stream và trả về một stream mới, cho phép chúng được nối chuỗi với nhau. Chúng không thực thi cho đến khi một hoạt động cuối được gọi.

*   **`filter(Predicate<T> predicate)`:**
    *   **Mục đích:** Để lọc các phần tử từ một stream. Nó chỉ giữ lại các phần tử trả về `true` cho predicate đã cho.
    *   **Ví dụ:** `stream.filter(s -> s.startsWith("A"))`

*   **`map(Function<T, R> mapper)`:**
    *   **Mục đích:** Để biến đổi mỗi phần tử của một stream thành một object khác. Các kiểu đầu vào và đầu ra có thể khác nhau. Đó là một ánh xạ một-một.
    *   **Ví dụ:** `stream.map(String::length)` biến đổi một `Stream<String>` thành một `Stream<Integer>`.

*   **`flatMap(Function<T, Stream<R>> mapper)`:**
    *   **Mục đích:** Một hoạt động mạnh mẽ nhưng đôi khi khó hiểu. Nó được sử dụng để "làm phẳng" một stream của các stream thành một stream duy nhất. Nó ánh xạ mỗi phần tử thành một `Stream`, và sau đó nối tất cả các stream riêng lẻ đó thành một.
    *   **Ví dụ tương tự:** `map` giống như đưa một cuốn sách cho mỗi người trong một danh sách. `flatMap` giống như yêu cầu mỗi người trong một danh sách cho *bộ sưu tập* sách của họ, và sau đó đặt tất cả các cuốn sách từ tất cả các bộ sưu tập lên một kệ phẳng, duy nhất.
    *   **Ví dụ:** `List<List<Integer>> listOfLists; listOfLists.stream().flatMap(list -> list.stream())` biến đổi một `Stream<List<Integer>>` thành một `Stream<Integer>` duy nhất.

*   **`distinct()`:**
    *   **Mục đích:** Trả về một stream bao gồm các phần tử riêng biệt của stream. Nó sử dụng method `equals()` của các phần tử để xác định tính duy nhất.
    *   **Ví dụ:** `Stream.of(1, 2, 1, 3, 2).distinct()` cho kết quả là một stream của `1, 2, 3`.

*   **`sorted()` & `sorted(Comparator<T> comparator)`:**
    *   **Mục đích:** Sắp xếp các phần tử của stream. `sorted()` sử dụng thứ tự tự nhiên (`Comparable`), trong khi `sorted(comparator)` sử dụng một `Comparator` tùy chỉnh.
    *   **Lưu ý:** Đây là một hoạt động trung gian **có trạng thái**. Nó có thể cần phải xem tất cả các phần tử trước khi nó có thể tạo ra một kết quả.

*   **`limit(long maxSize)` & `skip(long n)`:**
    *   **Mục đích:** `limit` cắt ngắn stream để không dài hơn `maxSize`. `skip` loại bỏ `n` phần tử đầu tiên.
    *   **Lưu ý:** Đây là các hoạt động **ngắn mạch**. Ví dụ, `limit(5)` sẽ ngừng xử lý sau khi nó đã tìm thấy 5 phần tử, có thể là một sự tối ưu hóa hiệu suất đáng kể.

*   **`peek(Consumer<T> action)`:**
    *   **Mục đích:** Chủ yếu để gỡ lỗi. Nó cho phép bạn thực hiện một hành động trên mỗi phần tử khi nó chảy qua pipeline, mà không thay đổi phần tử.
    *   **Ví dụ:** `stream.peek(System.out::println)` sẽ in mỗi phần tử.

##### **Các hoạt động cuối (Háo hức và Tạo ra một kết quả)**

Các hoạt động này kích hoạt việc thực thi của toàn bộ pipeline và tạo ra một kết quả cuối cùng. Stream bị tiêu thụ sau một hoạt động cuối.

*   **`forEach(Consumer<T> action)`:**
    *   **Mục đích:** Thực hiện một hành động cho mỗi phần tử của stream. Điều này thường được sử dụng cho các tác dụng phụ, như in ra console.

*   **`collect(Collector collector)`:**
    *   **Mục đích:** Hoạt động cuối mạnh mẽ và phổ biến nhất. Nó biến đổi các phần tử của stream thành một dạng khác, thường là một `Collection` (như một `List` hoặc `Set`) hoặc một `Map`. Chúng ta sẽ đề cập đến `Collector` chi tiết sau.
    *   **Ví dụ:** `stream.collect(Collectors.toList())`

*   **`reduce(...)`:**
    *   **Mục đích:** Thực hiện một phép giảm trên các phần tử của stream, sử dụng một hàm tích lũy kết hợp, và trả về một kết quả duy nhất.
    *   **Ví dụ:** `numbers.stream().reduce(0, (a, b) -> a + b)` tính tổng tất cả các số, bắt đầu với một giá trị nhận dạng là 0.

*   **`count()`:**
    *   **Mục đích:** Trả về số lượng các phần tử trong stream dưới dạng một `long`.

*   **Các hoạt động khớp (Ngắn mạch):**
    *   **`anyMatch(Predicate<T> predicate)`:** Trả về `true` nếu ít nhất một phần tử khớp với predicate.
    *   **`allMatch(Predicate<T> predicate)`:** Trả về `true` nếu tất cả các phần tử đều khớp với predicate.
    *   **`noneMatch(Predicate<T> predicate)`:** Trả về `true` nếu không có phần tử nào khớp với predicate.

*   **Các hoạt động tìm kiếm:**
    *   **`findFirst()`:** Trả về một `Optional` mô tả phần tử đầu tiên của stream.
    *   **`findAny()`:** Trả về một `Optional` mô tả một phần tử nào đó của stream. Trong các stream song song, điều này có thể hiệu quả hơn `findFirst`.

---

#### **2. Ví dụ mã nguồn: Một Pipeline xử lý dữ liệu**

Ví dụ này sử dụng một danh sách các object `Transaction` và nối chuỗi một số hoạt động để tìm một kết quả cụ thể.

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

class Transaction {
    private final int id;
    private final int value;
    private final String city;

    public Transaction(int id, int value, String city) {
        this.id = id;
        this.value = value;
        this.city = city;
    }

    public int getValue() { return value; }
    public String getCity() { return city; }

    @Override
    public String toString() { return "Transaction{id=" + id + ", value=" + value + ", city='" + city + "'}"; }
}

public class StreamOperationsDemo {
    public static void main(String[] args) {
        List<Transaction> transactions = Arrays.asList(
            new Transaction(1, 100, "London"),
            new Transaction(2, 500, "Milan"),
            new Transaction(3, 800, "London"),
            new Transaction(4, 250, "Tokyo"),
            new Transaction(5, 500, "London")
        );

        // VẤN ĐỀ: Tìm ID của 2 giao dịch hàng đầu theo giá trị từ London, được sắp xếp theo giá trị.

        List<Integer> result = transactions.stream() // 1. Lấy stream
            .filter(t -> "London".equals(t.getCity()))   // 2. Chỉ giữ lại các giao dịch ở London
            .sorted(Comparator.comparing(Transaction::getValue).reversed()) // 3. Sắp xếp theo giá trị, giảm dần
            .limit(2)                                    // 4. Chỉ lấy 2 giao dịch hàng đầu
            .map(t -> t.id)                              // 5. Ánh xạ từ Transaction -> ID giao dịch (phần này của yêu cầu ban đầu không có trong mã. vì vậy tôi đang thêm nó vào)
            .collect(Collectors.toList());               // 6. Thu thập các kết quả vào một List

        System.out.println("IDs of the top 2 transactions from London:");
        System.out.println(result);
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một `List<String> words = Arrays.asList("Java", "Stream", "API", "is", "very", "powerful", "java");`
Viết một pipeline của stream để:
1.  Chuyển tất cả các từ thành chữ thường.
2.  Loại bỏ bất kỳ từ nào trùng lặp.
3.  Chỉ giữ lại những từ ngắn hơn 5 ký tự.
4.  Sắp xếp các từ còn lại theo thứ tự bảng chữ cái.
5.  Thu thập kết quả cuối cùng vào một `List<String>`.
6.  In danh sách cuối cùng ra.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Sự khác biệt cơ bản giữa `map()` và `flatMap()` là gì?

A) `map()` là một hoạt động trung gian, trong khi `flatMap()` là một hoạt động cuối.
B) `map()` thực hiện một chuyển đổi một-một (một phần tử đầu vào tạo ra một phần tử đầu ra), trong khi `flatMap()` thực hiện một chuyển đổi một-nhiều và làm phẳng các kết quả thành một stream duy nhất.
C) `map()` có thể thay đổi kiểu của stream, nhưng `flatMap()` thì không.
D) `map()` là lười biếng, trong khi `flatMap()` là háo hức.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) `map()` thực hiện một chuyển đổi một-một (một phần tử đầu vào tạo ra một phần tử đầu ra), trong khi `flatMap()` thực hiện một chuyển đổi một-nhiều và làm phẳng các kết quả thành một stream duy nhất. `map(f)` áp dụng hàm `f` cho mỗi phần tử, dẫn đến một stream mới có cùng kích thước. `flatMap(f)` áp dụng hàm `f` cho mỗi phần tử, trong đó `f` trả về một stream cho mỗi phần tử, và sau đó tất cả các stream kết quả đó được hợp nhất thành một.

### **Bài 5: Lớp `Optional`**

#### **1. Giải thích khái niệm**

##### **"Sai lầm tỷ đô": `null`**
Tony Hoare, người phát minh ra các tham chiếu `null`, đã nổi tiếng gọi nó là "sai lầm tỷ đô" của mình. `null` có vấn đề vì nó không rõ ràng. Một giá trị trả về `null` có nghĩa là "giá trị không được tìm thấy," "tính toán thất bại," hay "giá trị không xác định"? Nó buộc client của một API phải liên tục kiểm tra `null` để tránh `NullPointerException` đáng sợ.

```java
// Cách cũ: kiểm tra null dễ gây lỗi
User user = findUserById(id);
if (user != null) {
    // Các kiểm tra null lồng nhau có thể trở nên rất lộn xộn
    if (user.getAddress() != null) {
        if (user.getAddress().getCity() != null) {
            System.out.println(user.getAddress().getCity());
        }
    }
}
```

##### **Giải pháp: `Optional<T>`**
Java 8 đã giới thiệu lớp `java.util.Optional<T>` để cung cấp một cách tốt hơn, rõ ràng hơn để xử lý sự vắng mặt của một giá trị. Một `Optional` là một object chứa có thể có hoặc không có một giá trị không-null.

*   **Nó là một trình bao bọc:** Nó hoặc chứa một object của kiểu `T` (nó "có mặt") hoặc nó rỗng.
*   **Nó là một hợp đồng rõ ràng:** Khi một method trả về một `Optional<User>`, nó đang nói rõ ràng với client: "Method này có thể không tìm thấy một người dùng. Bạn phải chuẩn bị để xử lý trường hợp giá trị vắng mặt." Điều này buộc nhà phát triển phải suy nghĩ về trường hợp "không tìm thấy", biến một `NullPointerException` tiềm ẩn tại thời điểm chạy thành một cân nhắc thiết kế tại thời điểm biên dịch.

##### **Tạo `Optional`**
*   **`Optional.of(T value)`:** Tạo một `Optional` với giá trị đã cho. **Quan trọng:** Giá trị *không được* là `null`. Nếu có, method này sẽ ném ra một `NullPointerException`. Sử dụng điều này khi bạn chắc chắn giá trị là không-null.
*   **`Optional.ofNullable(T value)`:** Tạo một `Optional` bao bọc giá trị nếu nó không-null, hoặc trả về một `Optional` rỗng nếu giá trị là `null`. Đây là cách an toàn và phổ biến nhất để tạo một `Optional` từ một giá trị có thể là null.
*   **`Optional.empty()`:** Trả về một instance `Optional` rỗng singleton.

##### **Sử dụng `Optional` (Tránh `get()`)**
Sai lầm phổ biến nhất mà người mới bắt đầu mắc phải là ngay lập tức gọi `optional.get()`. Nếu `Optional` rỗng, `get()` sẽ ném ra một `NoSuchElementException`, không tốt hơn một `NullPointerException`.

**API `Optional` được thiết kế để được sử dụng theo một phong cách hàm, khai báo.**

*   **`isPresent()` & `isEmpty()` (Java 11+):** Kiểm tra xem một giá trị có mặt hay không. `isPresent()` thường nên được tránh để thay thế bằng các method hàm hơn.

*   **Cung cấp các giải pháp thay thế (Tiêu thụ giá trị):**
    *   **`orElse(T other)`:** Trả về giá trị chứa bên trong nếu có, nếu không trả về giá trị mặc định `other` được cung cấp.
    *   **`orElseGet(Supplier<? extends T> other)`:** Trả về giá trị chứa bên trong nếu có, nếu không trả về kết quả của việc gọi `Supplier` được cung cấp. Điều này hiệu quả hơn `orElse` nếu việc tạo đối tượng mặc định tốn kém, vì `Supplier` chỉ được gọi khi cần thiết.
    *   **`orElseThrow(Supplier<? extends X> exceptionSupplier)`:** Trả về giá trị chứa bên trong nếu có, nếu không ném ra ngoại lệ được tạo bởi `Supplier` được cung cấp. Đây là cách tiêu chuẩn để báo hiệu rằng một giá trị vắng mặt là một lỗi.

*   **Thực hiện các hành động:**
    *   **`ifPresent(Consumer<? super T> consumer)`:** Nếu một giá trị có mặt, nó thực thi `Consumer` đã cho với giá trị đó, nếu không thì không làm gì cả.

*   **Các biến đổi hàm:**
    *   **`map(Function<? super T, ? extends U> mapper)`:** Nếu một giá trị có mặt, nó áp dụng hàm ánh xạ cho nó và trả về một `Optional` mô tả kết quả. Nếu `Optional` rỗng, nó trả về một `Optional` rỗng. Điều này cho phép nối chuỗi an toàn.
    *   **`flatMap(Function<? super T, Optional<U>> mapper)`:** Tương tự như `map`, nhưng hàm ánh xạ chính nó phải trả về một `Optional`. Điều này được sử dụng để "làm phẳng" các `Optional` lồng nhau, tránh `Optional<Optional<User>>`.

---

#### **2. Ví dụ mã nguồn: Tái cấu trúc các kiểm tra Null**

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

class UserProfile {
    // Một method có thể trả về null trong thế giới cũ
    public String getCity_Old() {
        // ... logic có thể dẫn đến null ...
        return null;
    }

    // Cách hiện đại: nói rõ rằng giá trị có thể vắng mặt
    public Optional<String> getCity_New() {
        return Optional.empty(); // hoặc Optional.ofNullable(someValue);
    }
}

public class OptionalDemo {
    private static Map<Integer, String> userDb = new HashMap<>();
    static {
        userDb.put(1, "Alice");
    }

    // Một method repository trả về một Optional một cách chính xác
    public static Optional<String> findUsernameById(int id) {
        return Optional.ofNullable(userDb.get(id));
    }

    public static void main(String[] args) {
        // --- Tiêu thụ một Optional ---
        System.out.println("--- Handling presence and absence ---");
        // Trường hợp 1: Người dùng được tìm thấy
        String username1 = findUsernameById(1)
                            .orElse("Guest"); // Giá trị mặc định không được sử dụng
        System.out.println("User 1: " + username1);

        // Trường hợp 2: Người dùng không được tìm thấy
        String username2 = findUsernameById(99)
                            .orElse("Guest"); // Giá trị mặc định "Guest" được trả về
        System.out.println("User 99: " + username2);

        // Trường hợp 3: Ném ra một ngoại lệ nếu không tìm thấy
        try {
            String username3 = findUsernameById(99)
                                .orElseThrow(() -> new IllegalStateException("User not found"));
        } catch (IllegalStateException e) {
            System.out.println("Caught expected exception: " + e.getMessage());
        }

        // --- Nối chuỗi với map() ---
        System.out.println("\n--- Chaining with map() ---");
        // Chúng ta muốn lấy độ dài của tên người dùng nếu nó tồn tại.
        Optional<Integer> nameLength = findUsernameById(1)
                                         .map(String::length); // map() biến đổi giá trị một cách an toàn

        nameLength.ifPresent(len -> System.out.println("Username length is: " + len));
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một `Map<String, String> config` có thể chứa một khóa `"port"`.
1.  Viết một đoạn mã lấy số cổng từ map này.
2.  Nếu khóa `"port"` tồn tại, giá trị của nó (một `String`) nên được phân tích cú pháp thành một `Integer`.
3.  Nếu khóa không tồn tại, hoặc nếu giá trị không phải là một số hợp lệ, bạn nên sử dụng một cổng mặc định là `8080`.
4.  Triển khai logic này bằng `Optional`.
    *   Bắt đầu với `Optional.ofNullable(config.get("port"))`.
    *   Sử dụng `flatMap` để thử phân tích cú pháp chuỗi thành một số nguyên một cách an toàn (Gợi ý: `s -> { try { return Optional.of(Integer.parseInt(s)); } catch (NumberFormatException e) { return Optional.empty(); } }`).
    *   Sử dụng `orElse` để cung cấp giá trị mặc định.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Sự khác biệt giữa `optional.orElse(createDefault())` và `optional.orElseGet(() -> createDefault())` là gì?

A) Không có sự khác biệt; chúng có chức năng giống hệt nhau.
B) `orElse` dùng để cung cấp một giá trị mặc định, trong khi `orElseGet` dùng để ném ra một ngoại lệ.
C) Method `createDefault()` **luôn** được thực thi khi sử dụng `orElse`, ngay cả khi optional có mặt. Với `orElseGet`, lambda nhà cung cấp `() -> createDefault()` **chỉ** được thực thi nếu optional rỗng.
D) `orElse` có thể trả về `null`, nhưng `orElseGet` thì không.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Method `createDefault()` **luôn** được thực thi khi sử dụng `orElse`, ngay cả khi optional có mặt. Với `orElseGet`, lambda nhà cung cấp `() -> createDefault()` **chỉ** được thực thi nếu optional rỗng. Điều này làm cho `orElseGet` trở thành lựa chọn được ưu tiên khi việc tạo đối tượng mặc định là một hoạt động tốn kém về mặt tính toán.

### **Bài 6: Collectors và Hoạt động `collect`**

#### **1. Giải thích khái niệm**

`collect` là hoạt động cuối mạnh mẽ và linh hoạt nhất trong Stream API. Trong khi các hoạt động cuối khác như `count()` hoặc `forEach()` thực hiện một tác vụ cụ thể, `collect` là một hoạt động đa năng có thể biến đổi các phần tử của một stream thành hầu hết bất kỳ cấu trúc dữ liệu nào bạn cần.

Hành vi của method `collect` được định nghĩa bởi một `java.util.stream.Collector`.

##### **Lớp tiện ích `Collectors`**
Bạn sẽ hiếm khi tự mình triển khai interface `Collector`. Thay vào đó, bạn gần như luôn luôn sử dụng nhiều factory method tĩnh được cung cấp trong lớp `java.util.stream.Collectors`. Các collector được định nghĩa trước này bao gồm một loạt các trường hợp sử dụng phổ biến.

##### **1. Thu thập vào một Collection**
Đây là các collector phổ biến nhất.
*   **`toList()`:** Thu thập các phần tử của stream vào một `java.util.List`.
*   **`toSet()`:** Thu thập các phần tử của stream vào một `java.util.Set`, tự động loại bỏ các bản sao.
*   **`toCollection(Supplier<C> collectionFactory)`:** Thu thập các phần tử vào một loại collection cụ thể, ví dụ: `toCollection(LinkedList::new)`.

##### **2. Thu thập vào một Chuỗi**
*   **`joining()`:** Nối các phần tử của stream thành một `String` duy nhất.
*   **`joining(CharSequence delimiter)`:** Nối các phần tử với một dấu phân cách được chỉ định.
*   **`joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)`:** Thêm một tiền tố và hậu tố.

##### **3. Tổng hợp và Tóm tắt (Phép giảm)**
Các collector này thực hiện một hoạt động giảm trên stream.
*   **`counting()`:** Đếm số lượng các phần tử trong stream.
*   **`summingInt(ToIntFunction)` / `summingLong(...)` / `summingDouble(...)`:** Tính tổng của một thuộc tính của các phần tử của stream.
*   **`averagingInt(ToIntFunction)` / `averagingDouble(...)`:** Tính trung bình.
*   **`summarizingInt(ToIntFunction)` / `summarizingDouble(...)`:** Một collector mạnh mẽ tính toán số đếm, tổng, min, max, và trung bình tất cả trong một lần duyệt. Nó trả về một object tóm tắt đặc biệt (ví dụ: `IntSummaryStatistics`).

##### **4. Các hoạt động nhóm**
Đây là các collector tiên tiến và mạnh mẽ nhất, cho phép bạn thực hiện các hoạt động kiểu "GROUP BY".

*   **`groupingBy(Function classifier)`:** Nhóm các phần tử của một stream vào một `Map`. Các khóa của map là kết quả của việc áp dụng hàm `classifier`, và các giá trị là các `List` của các phần tử đã ánh xạ đến khóa đó.
    *   **Ví dụ:** `students.stream().collect(groupingBy(Student::getGrade))` sẽ tạo ra một `Map<Grade, List<Student>>`.

*   **Downstream Collectors:** Method `groupingBy` có một phiên bản quá tải nhận một `Collector` thứ hai làm đối số. "Downstream collector" này được áp dụng cho kết quả của mỗi nhóm. Điều này cho phép nhóm đa cấp và các tổng hợp phức tạp.
    *   **Ví dụ:** `students.stream().collect(groupingBy(Student::getGrade, counting()))` sẽ tạo ra một `Map<Grade, Long>` ánh xạ mỗi điểm đến *số lượng* sinh viên có điểm đó.

*   **`partitioningBy(Predicate predicate)`:** Một trường hợp đặc biệt của `groupingBy` được tối ưu hóa để phân vùng các phần tử thành hai nhóm dựa trên một predicate. Nó luôn trả về một `Map<Boolean, List<T>>`, trong đó `true` là khóa cho danh sách các phần tử khớp với predicate, và `false` là khóa cho danh sách các phần tử không khớp.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này sử dụng một `List<Dish>` để minh họa các collector mạnh mẽ khác nhau.

```java
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import static java.util.stream.Collectors.*; // Import tĩnh cho dễ đọc

class Dish {
    private final String name;
    private final boolean vegetarian;
    private final int calories;
    private final Type type;
    enum Type { MEAT, FISH, OTHER }
    // Constructor, getters, toString...
    public Dish(String name, boolean veg, int cal, Type type) { this.name=name; this.vegetarian=veg; this.calories=cal; this.type=type;}
    public String getName() { return name; }
    public boolean isVegetarian() { return vegetarian; }
    public int getCalories() { return calories; }
    public Type getType() { return type; }
    @Override public String toString() { return name; }
}

public class CollectorsDemo {
    public static void main(String[] args) {
        List<Dish> menu = List.of(
            new Dish("pork", false, 800, Dish.Type.MEAT),
            new Dish("beef", false, 700, Dish.Type.MEAT),
            new Dish("chicken", false, 400, Dish.Type.MEAT),
            new Dish("french fries", true, 530, Dish.Type.OTHER),
            new Dish("rice", true, 350, Dish.Type.OTHER),
            new Dish("salad", true, 120, Dish.Type.OTHER),
            new Dish("salmon", false, 450, Dish.Type.FISH)
        );

        // 1. joining(): Tạo một danh sách các tên món ăn được phân tách bằng dấu phẩy
        String allNames = menu.stream()
                              .map(Dish::getName)
                              .collect(joining(", "));
        System.out.println("All dishes: " + allNames);

        // 2. summingInt(): Tính tổng lượng calo của tất cả các món ăn
        int totalCalories = menu.stream()
                                .collect(summingInt(Dish::getCalories));
        System.out.println("Total calories: " + totalCalories);

        // 3. groupingBy(): Nhóm các món ăn theo loại của chúng
        Map<Dish.Type, List<Dish>> dishesByType = menu.stream()
                                                      .collect(groupingBy(Dish::getType));
        System.out.println("Dishes by type: " + dishesByType);

        // 4. groupingBy() với một downstream collector: Đếm các món ăn trong mỗi nhóm
        Map<Dish.Type, Long> dishCountByType = menu.stream()
                                                   .collect(groupingBy(Dish::getType, counting()));
        System.out.println("Dish count by type: " + dishCountByType);

        // 5. partitioningBy(): Phân vùng các món ăn thành chay và không chay
        Map<Boolean, List<Dish>> vegetarianDishes = menu.stream()
                                                        .collect(partitioningBy(Dish::isVegetarian));
        System.out.println("Vegetarian partition: " + vegetarianDishes);
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn được giao một `List<String> sentences = List.of("hello world", "java stream api", "flatmap is powerful");`.
Nhiệm vụ của bạn là tạo ra một `Map<String, Long>` đếm tần suất của mỗi từ duy nhất trên tất cả các câu.
1.  Bắt đầu với `sentences.stream()`.
2.  Bạn sẽ cần phải tách mỗi câu thành các từ. Method `s -> Arrays.stream(s.split(" "))` có thể được sử dụng cho việc này. Bạn nên sử dụng hoạt động trung gian nào để làm phẳng `Stream<Stream<String>>` kết quả thành một `Stream<String>` duy nhất của các từ?
3.  Sử dụng một `groupingBy` collector. Hàm phân loại nên là chính từ đó (`Function.identity()`).
4.  Downstream collector nên là `counting()`.
5.  In ra map cuối cùng của số đếm từ.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn có một `Stream<Employee>` và bạn muốn tạo một `Map<Department, Set<Employee>>` trong đó các nhân viên được nhóm theo phòng ban của họ, và các giá trị là các tập hợp nhân viên để loại bỏ các bản sao trong mỗi phòng ban. Bạn sẽ sử dụng collector nào?

A) `Collectors.toMap(Employee::getDepartment, employee -> employee)`
B) `Collectors.groupingBy(Employee::getDepartment)`
C) `Collectors.partitioningBy(e -> e.getDepartment() != null)`
D) `Collectors.groupingBy(Employee::getDepartment, Collectors.toSet())`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `Collectors.groupingBy(Employee::getDepartment, Collectors.toSet())`. `groupingBy(classifier)` tiêu chuẩn thu thập các phần tử được nhóm vào một `List`. Để thay đổi hành vi này, bạn cung cấp một downstream collector. Trong trường hợp này, `Collectors.toSet()` được sử dụng làm downstream collector để tập hợp các nhân viên cho mỗi phòng ban vào một `Set` thay vì một `List`.

### **Bài 7: Parallel Streams và Hiệu suất**

#### **1. Giải thích khái niệm**

##### **Stream tuần tự vs. Stream song song**
Theo mặc định, tất cả các hoạt động của stream trong Java là **tuần tự**. Một stream tuần tự được xử lý bởi một luồng duy nhất trên một lõi CPU duy nhất.
Một **stream song song** là một stream được thiết kế để được xử lý bởi nhiều luồng đồng thời, tự động tận dụng nhiều lõi CPU.

Stream API làm cho việc song song hóa trở nên cực kỳ dễ dàng:
*   Để có một stream song song, bạn có thể gọi **`collection.parallelStream()`** thay vì `collection.stream()`.
*   Bạn cũng có thể chuyển đổi một stream hiện có thành song song bằng cách gọi hoạt động trung gian **`.parallel()`**.
*   Bạn có thể chuyển đổi một stream song song trở lại tuần tự với `.sequential()`.

##### **Cách hoạt động của Parallel Streams bên trong**
Parallel stream được xây dựng trên **Fork/Join Framework** (mà chúng ta đã đề cập trong chủ đề Đồng thời).
1.  **Chia nhỏ (Splitting):** Nguồn của stream được chia nhỏ đệ quy thành các vấn đề con nhỏ hơn. Điều này được thực hiện bởi một `Spliterator`, một iterator nội bộ có thể được chia nhỏ dễ dàng.
2.  **Xử lý:** Mỗi vấn đề con sau đó được gửi như một tác vụ đến **`ForkJoinPool`** chung.
3.  **Kết hợp (Joining):** Các luồng worker của `ForkJoinPool` xử lý các vấn đề con một cách song song. Nếu một luồng hoàn thành công việc của mình, nó sẽ "đánh cắp" công việc từ hàng đợi của một luồng khác. Kết quả từ các vấn đề con sau đó được kết hợp trong bước cuối cùng.

**Sơ đồ thực thi song song:**
```
+-----------------------------------+
|      Nguồn dữ liệu ban đầu        |
+-----------------------------------+
             | (chia nhỏ)
     +-----------------------+
     |   Khối A   |   Khối B   |
     +-----------------------+
             | (chia nhỏ)
+----------+----------+----------+----------+
| Khối A1 | Khối A2 | Khối B1 | Khối B2 |
+----------+----------+----------+----------+
     |          |          |          |
     v          v          v          v
+--------+  +--------+  +--------+  +--------+
| Luồng 1|  | Luồng 2|  | Luồng 3|  | Luồng 4|  <-- ForkJoinPool
+--------+  +--------+  +--------+  +--------+
(xử lý A1) (xử lý A2) (xử lý B1) (xử lý B2)
     |          |          |          |
     |        (kết hợp)       |        |
     +-----------------------+
             | (kết hợp)
             v
+-----------------------------------+
|          Kết quả cuối cùng         |
+-----------------------------------+
```

##### **Khi nào nên sử dụng Parallel Streams (Và khi nào không)**
Việc biến một stream thành song song với `.parallel()` rất dễ dàng một cách quyến rũ, nhưng nó **không phải** là một sự tăng tốc hiệu suất kỳ diệu. Việc sử dụng nó không đúng cách có thể làm cho ứng dụng của bạn *chậm hơn* đáng kể và gây ra các lỗi đồng thời khó gỡ lỗi.

**Sử dụng Parallel Streams khi:**
1.  Bạn có một **lượng lớn dữ liệu** để xử lý (hàng chục nghìn phần tử trở lên). Chi phí của việc chia nhỏ và điều phối các luồng chỉ đáng giá đối với các tập dữ liệu lớn.
2.  Việc xử lý cho mỗi phần tử là **tốn nhiều CPU**. Song song hóa giúp ích khi CPU là nút thắt cổ chai.
3.  Các hoạt động trong pipeline của bạn là **độc lập** và **không có trạng thái**. Công việc trên một phần tử không nên phụ thuộc vào một phần tử khác.
4.  Nguồn dữ liệu chia nhỏ dễ dàng (ví dụ: `ArrayList`, mảng).

**TRÁNH Parallel Streams khi:**
1.  **Tập dữ liệu nhỏ.** Chi phí của Fork/Join framework sẽ lớn hơn lợi ích của việc song song hóa.
2.  Các tác vụ là **I/O-bound** (ví dụ: thực hiện các cuộc gọi mạng, đọc từ cơ sở dữ liệu). Một stream song song sẽ chỉ làm cho nhiều luồng bị chặn trên I/O, lãng phí tài nguyên. Đối với các tác vụ I/O, các cách tiếp cận không đồng bộ với `CompletableFuture` hoặc virtual threads vượt trội hơn rất nhiều.
3.  Các hoạt động của stream của bạn phụ thuộc vào thứ tự (ví dụ: `limit()`). Một số hoạt động tốn kém hơn nhiều trong một bối cảnh song song.
4.  Bạn đang sửa đổi **trạng thái có thể thay đổi được chia sẻ** từ bên trong các lambda của mình. Đây là mối nguy hiểm lớn nhất.

##### **Mối nguy hiểm: Trạng thái có thể thay đổi được chia sẻ**
Nếu các biểu thức lambda của bạn sửa đổi một object hoặc collection được chia sẻ, một stream song song sẽ gây ra một race condition lớn. Các luồng khác nhau sẽ cố gắng cập nhật trạng thái được chia sẻ đồng thời mà không có bất kỳ sự đồng bộ hóa nào, dẫn đến hỏng dữ liệu.

**Quy tắc:** Các lambda được sử dụng trong các pipeline của stream, đặc biệt là các pipeline song song, nên **không có trạng thái và không có tác dụng phụ**.

---

#### **2. Ví dụ mã nguồn: So sánh hiệu suất**

Ví dụ này cho thấy một tác vụ tốn nhiều CPU, nơi một stream song song mang lại lợi ích hiệu suất rõ ràng.

```java
import java.util.stream.LongStream;

public class ParallelStreamDemo {

    public static void main(String[] args) {
        long limit = 50_000_000L; // Một số lượng lớn các phần tử

        // --- 1. Tổng tuần tự ---
        long startTime = System.currentTimeMillis();
        long sequentialSum = LongStream.rangeClosed(1, limit)
                                       .sum();
        long endTime = System.currentTimeMillis();
        System.out.println("Sequential Sum: " + sequentialSum);
        System.out.println("Sequential Time: " + (endTime - startTime) + " ms");

        // --- 2. Tổng song song ---
        startTime = System.currentTimeMillis();
        long parallelSum = LongStream.rangeClosed(1, limit)
                                     .parallel() // Đây là thay đổi duy nhất cần thiết!
                                     .sum();
        endTime = System.currentTimeMillis();
        System.out.println("Parallel Sum:   " + parallelSum);
        System.out.println("Parallel Time:   " + (endTime - startTime) + " ms");
        
        // Trên một máy đa lõi, thời gian song song sẽ ít hơn đáng kể.
    }
}
```

##### **Ví dụ về một tác dụng phụ nguy hiểm:**
```java
List<Integer> unsafeList = new ArrayList<>();
IntStream.range(0, 1000).parallel().forEach(i -> {
    unsafeList.add(i); // NGUY HIỂM: Race condition! Nhiều luồng thêm vào một danh sách không an toàn cho luồng.
});
// Kích thước cuối cùng của unsafeList sẽ không thể đoán trước và nhỏ hơn 1000.
// Cách đúng là sử dụng một collector: .collect(Collectors.toList());
```

---

#### **3. Bài tập nhỏ**

Bạn có một danh sách một triệu giá trị `Double`. Nhiệm vụ của bạn là thực hiện một phép tính phức tạp, tốn nhiều CPU trên mỗi giá trị và sau đó tìm tổng của các kết quả.
1.  Tạo một `List<Double>` và điền vào đó một triệu số double ngẫu nhiên.
2.  Tạo một method static `double performComplexCalculation(double input)` mô phỏng một khối lượng công việc nặng (ví dụ: `Math.log(Math.sqrt(Math.abs(input)))` hoặc chỉ một `Thread.sleep(1)` để mô phỏng, mặc dù ngủ không tốn nhiều CPU).
3.  Đầu tiên, hãy triển khai giải pháp bằng cách sử dụng một stream tuần tự: `myList.stream().mapToDouble(MyClass::performComplexCalculation).sum()`. Đo thời gian thực hiện của nó.
4.  Thứ hai, hãy triển khai giải pháp bằng cách sử dụng một stream song song: `myList.parallelStream()...`. Đo thời gian thực hiện của nó.
5.  So sánh các thời gian.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Dưới điều kiện nào sau đây việc sử dụng một stream song song có khả năng làm cho chương trình của bạn *chậm hơn*?

A) Thực hiện một `sum()` đơn giản trên một mảng `long[]` lớn.
B) Ánh xạ một danh sách 10 triệu `String` thành các phiên bản viết hoa của chúng.
C) Xử lý một danh sách 50 URL trong đó mỗi bước xử lý liên quan đến việc thực hiện một yêu cầu mạng để tải xuống nội dung của URL.
D) Lọc một `ArrayList` lớn các số nguyên để tìm các số nguyên tố.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Xử lý một danh sách 50 URL trong đó mỗi bước xử lý liên quan đến việc thực hiện một yêu cầu mạng để tải xuống nội dung của URL. Đây là một tác vụ **I/O-bound**. `ForkJoinPool` mặc định được sử dụng bởi các stream song song có một số lượng luồng hạn chế (thường bằng số lượng lõi CPU). Tất cả các luồng này sẽ nhanh chóng bị chặn chờ phản hồi mạng, và hệ thống sẽ không thể xử lý các URL một cách song song hiệu quả. Đây là một trường hợp kinh điển mà các công cụ không đồng bộ như `CompletableFuture` là lựa chọn đúng đắn.

### **Bài 8: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Bài học cuối cùng này củng cố sự khám phá chuyên sâu của chúng ta về lập trình hàm trong Java. Chúng ta sẽ tóm tắt các khái niệm chính, xem lại các câu hỏi phỏng vấn phổ biến, và áp dụng mọi thứ trong một dự án xử lý dữ liệu thực tế.

---

#### **1. Bảng tóm tắt các khái niệm chính**

| Khái niệm | Mô tả & Điểm chính | Cú pháp ví dụ |
| :--- | :--- | :--- |
| **Biểu thức Lambda** | Một hàm ẩn danh có thể được đối xử như một giá trị. Kích hoạt "các hàm hạng nhất". | `(params) -> expression` |
| **Functional Interface** | Một interface có đúng một method trừu tượng. Kiểu đích cho một lambda. Sử dụng `@FunctionalInterface`. | `Predicate<T>`, `Function<T, R>`, `Consumer<T>`, `Supplier<T>` |
| **Tham chiếu Method** | Một cách viết tắt ngắn gọn cho một lambda gọi một method duy nhất, đã tồn tại. | `String::toUpperCase`, `System.out::println`, `ArrayList::new` |
| **Stream** | Một chuỗi các phần tử từ một nguồn hỗ trợ các hoạt động tổng hợp. Nó là về **tính toán**, không phải lưu trữ dữ liệu. Stream là lười biếng và sử dụng một lần. | `myList.stream()` |
| **Stream Pipeline**| **Nguồn → Các hoạt động trung gian → Hoạt động cuối.** Các hoạt động trung gian là lười biếng; hoạt động cuối kích hoạt việc thực thi. | `stream.filter(...).map(...).collect(...)` |
| **Các hoạt động trung gian** | `filter`, `map`, `flatMap`, `sorted`, `distinct`, `limit`. Trả về một stream mới. | `.filter(s -> s.length() > 3)` |
| **Các hoạt động cuối** | `collect`, `forEach`, `reduce`, `count`, `findFirst`, `anyMatch`. Tạo ra một kết quả và tiêu thụ stream. | `.collect(Collectors.toList())` |
| **`Collectors`** | Một lớp tiện ích cung cấp các triển khai `Collector` mạnh mẽ để sử dụng với `stream.collect()`. | `toList()`, `toSet()`, `joining()`, `groupingBy()`, `summingInt()` |
| **`Optional<T>`** | Một object chứa cho một giá trị có thể vắng mặt. Được sử dụng để xử lý rõ ràng sự vắng mặt của một giá trị và tránh `NullPointerException`. | `optional.orElse("default")`, `optional.map(...)` |
| **Parallel Stream** | Một stream xử lý các phần tử đồng thời bằng cách sử dụng `ForkJoinPool` chung. Sử dụng cho các hoạt động lớn, tốn nhiều CPU, và không có trạng thái. | `myList.parallelStream()` |
| **Tính bất biến & Tính thuần túy** | FP khuyến khích dữ liệu bất biến và các hàm thuần túy (không có tác dụng phụ) để có mã an toàn hơn, dễ dự đoán hơn, đặc biệt là trong các bối cảnh song song. | Các lambda trong stream không nên sửa đổi trạng thái bên ngoài. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Sự khác biệt giữa một Stream và một Collection là gì?"**
    *   *Trả lời:* Một Collection là một cấu trúc dữ liệu trong bộ nhớ lưu trữ các giá trị. Một Stream là một chế độ xem trên một nguồn dữ liệu cho phép bạn thể hiện các tính toán. Stream không lưu trữ dữ liệu, lười biếng, và chỉ có thể được duyệt qua một lần.

2.  **"Giải thích sự khác biệt giữa `map` và `flatMap` trong Stream API."**
    *   *Trả lời:* `map` thực hiện một chuyển đổi một-một; nó nhận một phần tử và tạo ra một phần tử trong stream đầu ra. `flatMap` thực hiện một chuyển đổi một-nhiều; nó nhận một phần tử, ánh xạ nó thành một *stream mới* của không hoặc nhiều phần tử, và sau đó làm phẳng tất cả các stream kết quả thành một stream đầu ra duy nhất. Nó được sử dụng để "mở lồng" các cấu trúc.

3.  **"Một hoạt động của stream được cho là 'lười biếng' có nghĩa là gì?"**
    *   *Trả lời:* Sự lười biếng có nghĩa là các hoạt động trung gian trong một pipeline của stream không được thực thi ngay lập tức. Chúng chỉ được thực thi khi một hoạt động cuối được gọi. Điều này cho phép Stream API thực hiện các tối ưu hóa, chẳng hạn như kết hợp các hoạt động (loop fusion) và ngắn mạch (ví dụ: `findFirst` dừng lại sau kết quả khớp đầu tiên).

4.  **"Quy tắc 'effectively final' đối với các biến được sử dụng trong lambda là gì?"**
    *   *Trả lời:* Một biểu thức lambda chỉ có thể truy cập các biến cục bộ từ phạm vi bao quanh nó nếu các biến đó là `final` hoặc "effectively final". Một biến là effectively final nếu giá trị của nó không bao giờ thay đổi sau khi khởi tạo. Quy tắc này tồn tại để ngăn chặn các vấn đề đồng thời và đảm bảo rằng lambda đang capture một giá trị cố định, không phải là một biến có thể thay đổi.

5.  **"Khi nào bạn nên sử dụng `Optional`? Một sai lầm phổ biến khi sử dụng nó là gì?"**
    *   *Trả lời:* Bạn nên sử dụng `Optional` làm kiểu trả về cho bất kỳ method nào có thể không trả về một giá trị, để làm cho khả năng này trở nên rõ ràng trong hợp đồng của method. Nó buộc người gọi phải xử lý trường hợp "vắng mặt". Một sai lầm phổ biến là ngay lập tức gọi `.get()` mà không kiểm tra `isPresent()` trước, hoặc viết `if (opt.isPresent()) { return opt.get(); } else { return null; }`, điều này làm mất đi toàn bộ mục đích của `Optional`. Cách được ưu tiên là sử dụng các method hàm như `orElse()`, `map()`, và `ifPresent()`.

6.  **"Việc sử dụng `.parallelStream()` có luôn nhanh hơn không? Khi nào nó có thể làm cho hiệu suất tồi tệ hơn?"**
    *   *Trả lời:* Không, nó không phải lúc nào cũng nhanh hơn. Nó có thể làm cho hiệu suất tồi tệ hơn nếu tập dữ liệu nhỏ (chi phí của việc fork/join quá cao), nếu tác vụ là I/O-bound (các luồng sẽ chỉ bị chặn), hoặc nếu cấu trúc dữ liệu cơ bản không chia nhỏ hiệu quả (như một `LinkedList`). Nó cũng có thể gây ra kết quả không chính xác nếu các hoạt động lambda có tác dụng phụ sửa đổi trạng thái có thể thay đổi được chia sẻ.

---

#### **3. Dự án nhỏ cuối cùng: Pipeline phân tích tệp log**

Dự án này sẽ áp dụng các khái niệm lập trình hàm để đọc, phân tích cú pháp, và phân tích một tệp log để tạo một báo cáo tóm tắt.

**🎯 Mục tiêu:** Xây dựng một pipeline xử lý log bằng cách sử dụng Stream và Collector để trích xuất các thống kê có ý nghĩa từ một tập hợp các mục log.

**Các thành phần dự án:**

1.  **Bản ghi `LogEntry`:**
    *   Tạo một `record` Java (hoặc một POJO đơn giản) để đại diện cho một mục log duy nhất:
        `record LogEntry(LocalDateTime timestamp, String level, String message) {}`
    *   `level` sẽ là "INFO", "WARN", hoặc "ERROR".

2.  **Trình phân tích cú pháp Log:**
    *   Tạo một method static `Optional<LogEntry> parseLogLine(String line)`.
    *   Method này sẽ nhận một chuỗi log thô (ví dụ: `"2023-10-27T10:00:00,INFO,User logged in"`) và cố gắng phân tích cú pháp nó thành một object `LogEntry`.
    *   Nếu dòng bị định dạng sai (ví dụ: không tách được chính xác), nó nên **trả về một `Optional` rỗng**. Nếu không, nó nên trả về một `Optional` chứa `LogEntry` đã tạo.

3.  **Nguồn dữ liệu:**
    *   Tạo một `List<String>` các dòng log mẫu. Bao gồm một sự pha trộn của các cấp độ log và một số dòng bị định dạng sai mà trình phân tích cú pháp của bạn sẽ từ chối.
        ```java
        List<String> rawLogs = List.of(
            "2023-10-27T10:00:00,INFO,User logged in",
            "2023-10-27T10:01:00,INFO,Data processed successfully",
            "2023-10-27T10:02:00,WARN,Connection timing out",
            "This is a malformed line",
            "2023-10-27T10:03:00,ERROR,Database connection failed",
            "2023-10-27T10:04:00,INFO,User logged out",
            "2023-10-27T10:05:00,ERROR,Null pointer exception in module X"
        );
        ```

4.  **Dịch vụ phân tích:**
    *   Tạo một lớp `LogAnalytics`. Đây là nơi pipeline của stream chính của bạn sẽ ở.
    *   Nó nên có một method `generateReport(List<String> rawLogs)` trả về một `Map<String, Long>`.
    *   **Logic Pipeline:** Bên trong method này, hãy xây dựng một pipeline của stream để:
        1.  Bắt đầu với `rawLogs.stream()`.
        2.  Gọi method `parseLogLine` cho mỗi dòng. Điều này sẽ tạo ra một `Stream<Optional<LogEntry>>`.
        3.  Lọc ra các `Optional` rỗng để loại bỏ các dòng bị định dạng sai.
        4.  "Mở" các `Optional` để có được một `Stream<LogEntry>`. (Gợi ý: `opt -> opt.isPresent()` và `opt -> opt.get()` hoặc `Optional::stream` của Java 9+).
        5.  Sử dụng một `groupingBy` collector để nhóm các object `LogEntry` theo cấp độ log của chúng (`LogEntry::level`).
        6.  Sử dụng một `counting` downstream collector để đếm số lượng các mục trong mỗi nhóm.
        7.  Kết quả cuối cùng sẽ là một `Map<String, Long>` ánh xạ mỗi cấp độ log đến tần suất của nó.

5.  **Lớp chính:**
    *   Method `main` nên tạo dịch vụ `LogAnalytics`, gọi `generateReport` với dữ liệu mẫu, và in ra map kết quả theo một định dạng dễ đọc.

**Đầu ra mong đợi:**
```
Log Level Summary:
- INFO: 3
- WARN: 1
- ERROR: 2
```

