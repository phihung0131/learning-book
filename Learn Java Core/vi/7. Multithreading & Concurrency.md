### **Bài 1: Hiểu về Threads và Vòng đời của chúng**

#### **1. Giải thích khái niệm**

##### **Thread là gì? Process vs. Thread**
*   Một **process** (tiến trình) là một instance của một chương trình máy tính đang được thực thi. Nó có không gian bộ nhớ riêng, được cách ly với các process khác. Hãy nghĩ về trình duyệt web của bạn hoặc một trình soạn thảo văn bản; mỗi cái là một process riêng biệt.
*   Một **thread** (luồng) là đơn vị thực thi nhỏ nhất trong một process. Một process có thể có một hoặc nhiều thread, thường được gọi là các lightweight process. Tất cả các thread trong cùng một process chia sẻ cùng một không gian bộ nhớ (bộ nhớ heap), điều này cho phép chúng chia sẻ dữ liệu dễ dàng nhưng cũng gây ra nguy cơ hỏng dữ liệu (race conditions).

**Ví dụ tương tự:** Một **process** giống như một nhà hàng. Nó có nhà bếp, nguyên liệu và nhân viên riêng (bộ nhớ, tài nguyên). Một **thread** giống như một đầu bếp trong nhà hàng đó. Một nhà hàng có một đầu bếp (process đơn luồng) chỉ có thể làm một việc tại một thời điểm. Một nhà hàng có nhiều đầu bếp (process đa luồng) có thể chuẩn bị nhiều món ăn đồng thời, tăng năng suất. Tất cả các đầu bếp đều chia sẻ cùng một nhà bếp và nguyên liệu (bộ nhớ chia sẻ).

##### **Vòng đời của Thread (Các trạng thái)**
Một thread trong Java có thể tồn tại ở một trong sáu trạng thái, được định nghĩa trong enum `Thread.State`. Hiểu rõ các trạng thái này là rất quan trọng để gỡ lỗi và phân tích các ứng dụng đồng thời.

```
                  start()
      +-------+  ---------> +-----------+
      |  NEW  |             | RUNNABLE  | <--------------------+
      +-------+  <--------- +-----------+                      |
                  (hoàn thành)     |   ^                         |
                                 |   | (yield, hoặc HĐH lập lịch) |
      +------------+ <-----------+   |                         |
      | TERMINATED |             v   | (I/O, khối synchronized) |
      +------------+      +-----------+                         |
                          |  BLOCKED  | ------------------------+
                          +-----------+   (đã có khóa)
                                 |
           (wait(), join(), LockSupport.park())
                                 v
      +-----------+ <------- +-----------+
      |  WAITING  |          |TIMED_WAITING|
      +-----------+ -------> +-----------+
       ^      (notify(),    (hết thời gian chờ,
       |       interrupt())   notify(), interrupt())
       +----------------------------+
```
*   **`NEW`**: Thread đã được tạo nhưng method `start()` của nó chưa được gọi. Nó chưa "sống".
*   **`RUNNABLE`**: Thread đủ điều kiện để được bộ lập lịch luồng (thread scheduler) chạy. Trạng thái này bao gồm cả "đang chạy" và "sẵn sàng để chạy". Một thread ở trạng thái `RUNNABLE` có thể đang tích cực thực thi mã, hoặc nó có thể đang chờ HĐH cấp cho nó một lát thời gian trên một lõi CPU.
*   **`BLOCKED`**: Thread đang chờ để có được một khóa monitor nội tại (tức là, nó đang chờ để vào một khối hoặc method `synchronized` mà một thread khác hiện đang giữ khóa).
*   **`WAITING`**: Thread đang ở trạng thái chờ không xác định. Nó đang chờ một thread khác thực hiện một hành động cụ thể, chẳng hạn như gọi `notify()` hoặc `notifyAll()` trên một object mà thread đang `wait()` trên đó, hoặc cho một thread mà nó đã `join()` để kết thúc.
*   **`TIMED_WAITING`**: Thread đang ở trạng thái chờ trong một khoảng thời gian xác định. Nó sẽ chuyển trở lại `RUNNABLE` nếu hết thời gian chờ hoặc nếu nó nhận được một `notify()`/`interrupt()`. Đây là trạng thái cho các cuộc gọi như `Thread.sleep(long)`, `wait(long)`, và `join(long)`.
*   **`TERMINATED`**: Thread đã hoàn thành việc thực thi của mình (method `run()` của nó đã thoát) hoặc đã bị kết thúc theo cách khác.

##### **Tạo và bắt đầu Threads**
1.  **Triển khai `Runnable` (Ưu tiên):**
    *   Tạo một lớp triển khai interface `java.lang.Runnable` và method `run()` của nó.
    *   Tạo một instance của lớp này.
    *   Tạo một object `Thread` mới, truyền instance `Runnable` vào constructor của nó.
    *   Gọi `thread.start()`.
    *   **Tại sao lại ưu tiên cách này?** Nó tách biệt tác vụ (`Runnable`) khỏi cơ chế thực thi (`Thread`), thúc đẩy thiết kế hướng đối tượng tốt hơn (ưu tiên composition hơn inheritance). Bạn cũng có thể triển khai các interface khác hoặc kế thừa các lớp khác.

2.  **Kế thừa `Thread`:**
    *   Tạo một lớp kế thừa `java.lang.Thread`.
    *   Ghi đè method `run()`.
    *   Tạo một instance của lớp con của bạn và gọi `start()`.
    *   Cách này ít linh hoạt hơn vì Java không hỗ trợ đa kế thừa.

**`start()` vs. `run()`:** Đây là một câu hỏi phỏng vấn kinh điển.
*   **`thread.start()`**: Đây là cách đúng để bắt đầu một thread mới. Nó yêu cầu JVM tạo một luồng thực thi mới và để luồng mới đó gọi method `run()`. Nó trả về ngay lập tức.
*   **`thread.run()`**: Đây chỉ là một cuộc gọi method thông thường. Nó thực thi mã trong method `run()` trên **luồng hiện tại**, không phải là một luồng mới. Không có đa luồng xảy ra.

##### **Joining Threads (`join()`)**
Method `thread.join()` làm cho luồng hiện tại tạm dừng việc thực thi của nó cho đến khi thread mà nó đang join (`thread`) hoàn thành (tức là, vào trạng thái `TERMINATED`). Đây là một cơ chế quan trọng để điều phối công việc giữa các luồng.

##### **Daemon vs. Non-Daemon (User) Threads**
*   **Non-Daemon (User) Threads:** Đây là mặc định. JVM sẽ **không** thoát miễn là có ít nhất một non-daemon thread vẫn còn sống, ngay cả khi `main` thread đã kết thúc.
*   **Daemon Threads:** Đây là các luồng có độ ưu tiên thấp cung cấp các dịch vụ nền. JVM **sẽ** thoát nếu các luồng duy nhất còn lại đang chạy là các daemon thread. Các method `run()` của chúng có thể không hoàn thành, và các khối `finally` không được đảm bảo sẽ được thực thi. Sử dụng `thread.setDaemon(true)` để đánh dấu một thread là daemon *trước khi* bắt đầu nó.

---

#### **2. Ví dụ mã nguồn**

```java
// Cách 1: Triển khai Runnable (Ưu tiên)
class Task implements Runnable {
    private final String name;

    public Task(String name) { this.name = name; }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Runnable Task '" + name + "' running, count: " + i);
            try {
                Thread.sleep(100); // Vào trạng thái TIMED_WAITING
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// Cách 2: Kế thừa Thread
class Worker extends Thread {
    public Worker(String name) { super(name); }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Thread '" + getName() + "' running, count: " + i);
        }
    }
}

public class ThreadCreationDemo {
    public static void main(String[] args) {
        System.out.println("Main thread started.");

        // Tạo thread bằng Runnable
        Thread t1 = new Thread(new Task("A"));

        // Tạo thread bằng cách kế thừa Thread
        Worker t2 = new Worker("B");

        // Bắt đầu cả hai thread
        t1.start(); // t1 vào trạng thái RUNNABLE
        t2.start(); // t2 vào trạng thái RUNNABLE

        try {
            // main thread CHỜ t1 và t2 kết thúc
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread finished after t1 and t2 completed.");
    }
}
```

---

#### **3. Bài tập nhỏ**
Viết một chương trình tính tổng các số từ 1 đến 1.000.000 trong một thread riêng.
1.  Tạo một lớp `Runnable` có tên `SumCalculator` nhận giới hạn trên (1.000.000) trong constructor của nó.
2.  Method `run()` nên thực hiện việc tính tổng.
3.  Lớp `SumCalculator` nên có một method `getSum()` để lấy kết quả sau khi tính toán xong. (Lưu ý: bạn sẽ cần suy nghĩ về cách làm cho biến `sum` hiển thị với main thread. Một getter public đơn giản sẽ hoạt động cho bài tập này, nhưng chúng ta sẽ thấy tại sao điều này có thể có vấn đề sau này).
4.  Trong method `main`, tạo và bắt đầu thread.
5.  `join()` thread để chờ nó kết thúc.
6.  Sau khi thread đã kết thúc, hãy lấy tổng và in nó ra.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Sự khác biệt cơ bản giữa việc gọi `myThread.start()` và `myThread.run()` là gì?

A) `start()` thực thi method `run()` trong một thread mới, trong khi `run()` thực thi nó trong thread hiện tại.
B) `start()` được sử dụng cho các daemon thread, trong khi `run()` được sử dụng cho các user thread.
C) `start()` đặt thread vào trạng thái `BLOCKED`, trong khi `run()` đặt nó vào trạng thái `RUNNABLE`.
D) Không có sự khác biệt; `start()` chỉ là một từ đồng nghĩa cho `run()`.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** A) `start()` thực thi method `run()` trong một thread mới, trong khi `run()` thực thi nó trong thread hiện tại. `start()` là method thực sự kích hoạt việc tạo ra một đường dẫn thực thi đồng thời mới. Việc gọi `run()` trực tiếp chỉ là một lời gọi method đơn giản.

### **Bài 2: Synchronization và Race Conditions**

#### **1. Giải thích khái niệm**

##### **Vấn đề: Trạng thái có thể thay đổi được chia sẻ (Shared Mutable State)**
Sức mạnh của đa luồng đến từ việc các luồng chia sẻ cùng một không gian bộ nhớ, nhưng đây cũng là mối nguy hiểm lớn nhất của nó. Khi hai hoặc nhiều luồng có quyền truy cập vào cùng một object (trạng thái được chia sẻ), và ít nhất một trong các luồng đó có thể thay đổi trạng thái của object đó (trạng thái có thể thay đổi), bạn có một công thức cho thảm họa.

Một **race condition** là một lỗi xảy ra khi kết quả của một phép tính phụ thuộc vào thời gian hoặc sự xen kẽ không thể đoán trước của các hoạt động từ nhiều luồng. Các luồng "chạy đua" để truy cập và sửa đổi trạng thái được chia sẻ, và kết quả là hỗn loạn.

Loại race condition phổ biến nhất là mẫu **check-then-act** (kiểm tra-rồi-hành động):
1.  **Thread A** kiểm tra một điều kiện (ví dụ: "giá trị có nhỏ hơn 10 không?").
2.  Bộ lập lịch luồng tạm dừng Thread A và chuyển sang **Thread B**.
3.  **Thread B** sửa đổi giá trị (ví dụ: tăng nó lên 10).
4.  Bộ lập lịch chuyển trở lại **Thread A**.
5.  **Thread A**, không biết rằng giá trị đã thay đổi, tiếp tục *hành động* dựa trên thông tin cũ, lỗi thời của nó (ví dụ: nó cũng tăng giá trị, làm cho nó thành 11, có thể là một trạng thái không hợp lệ).

##### **Tính nguyên tử (Atomicity)**
Một hoạt động là **nguyên tử (atomic)** nếu nó được thực hiện như một đơn vị duy nhất, không thể chia cắt. Không có luồng nào khác có thể thấy hoạt động ở trạng thái hoàn thành một nửa. Trong Java, việc đọc hoặc ghi một tham chiếu là nguyên tử. Việc đọc hoặc ghi hầu hết các kiểu nguyên thủy (`int`, `boolean`, v.v.) là nguyên tử. Tuy nhiên, `long` và `double` là các giá trị 64-bit, và trên một số JVM 32-bit, việc đọc/ghi của chúng có thể không phải là nguyên tử (đây là vấn đề ít hơn trên các hệ thống 64-bit hiện đại).

Quan trọng hơn, các hoạt động phức hợp như `count++` **không phải là nguyên tử**. Chúng là một chuỗi của ba hoạt động riêng biệt:
1.  Đọc giá trị hiện tại của `count`.
2.  Tăng giá trị đã đọc.
3.  Ghi giá trị mới trở lại `count`.
    Một luồng có thể bị tạm dừng giữa bất kỳ bước nào trong số này, dẫn đến một race condition.

##### **Giải pháp: Synchronization và Khóa nội tại**
Synchronization là cơ chế để thực thi quyền truy cập được kiểm soát vào các tài nguyên được chia sẻ trong một môi trường đồng thời. Công cụ đồng bộ hóa chính của Java là từ khóa `synchronized`.

Mỗi object trong Java đều có một **khóa nội tại (intrinsic lock)** (còn được gọi là khóa monitor hoặc monitor). Khóa này hoạt động giống như một token mà chỉ một luồng có thể giữ tại một thời điểm.

1.  **Method Synchronized:** Khi bạn khai báo một method là `synchronized`, một luồng phải có được khóa nội tại của **instance object** (`this`) trước khi nó có thể thực thi method. Nếu một luồng khác cố gắng gọi *bất kỳ* method synchronized nào trên *cùng một instance object*, nó sẽ bị chặn cho đến khi luồng đầu tiên giải phóng khóa bằng cách thoát khỏi method.
    *   Đối với các method `static synchronized`, khóa nằm trên chính object `Class`, không phải là một instance.

2.  **Khối Synchronized:** Điều này cung cấp sự kiểm soát chi tiết hơn. Bạn chỉ định khóa của object nào bạn muốn có được.
    `synchronized (someObject) { ... }`
    Một luồng phải có được khóa trên `someObject` trước khi thực thi mã bên trong khối. Điều này linh hoạt hơn vì bạn có thể sử dụng một object khóa chuyên dụng hoặc đồng bộ hóa trên một object khác với `this`.

**Tính tái nhập (Reentrancy):** Các khóa nội tại của Java là **tái nhập (reentrant)**. Điều này có nghĩa là nếu một luồng đã giữ khóa trên một object, nó có thể lấy lại cùng một khóa đó mà không tự chặn mình. Điều này quan trọng để ngăn chặn tự bế tắc (self-deadlock), ví dụ, khi một method synchronized gọi một method synchronized khác trên cùng một object. JVM giữ một bộ đếm số lần khóa đã được một luồng lấy. Khóa chỉ được giải phóng khi bộ đếm trở về không.

---

#### **2. Ví dụ mã nguồn: Race Condition và Synchronization**

##### **Vấn đề: Race Condition**
Mã này gần như không bao giờ tạo ra kết quả mong đợi là 20.000 vì race condition trên `count++`.

```java
class UnsafeCounter {
    private int count = 0;

    public void increment() {
        count++; // Không phải là một hoạt động nguyên tử
    }

    public int getCount() {
        return count;
    }
}

public class RaceConditionDemo {
    public static void main(String[] args) throws InterruptedException {
        UnsafeCounter counter = new UnsafeCounter();
        Runnable task = () -> {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        // Số đếm cuối cùng sẽ không thể đoán trước và nhỏ hơn 20.000.
        System.out.println("Final count (unsafe): " + counter.getCount());
    }
}
```

##### **Giải pháp: Synchronization**
Bằng cách thêm từ khóa `synchronized`, chúng ta đảm bảo rằng method `increment` là nguyên tử.

```java
class SafeCounter {
    private int count = 0;

    // Chỉ một luồng có thể thực thi method này trên cùng một instance tại một thời điểm.
    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

public class SynchronizationDemo {
    public static void main(String[] args) throws InterruptedException {
        SafeCounter counter = new SafeCounter();
        Runnable task = () -> {
            for (int i = 0; i < 10000; i++) {
                counter.increment();
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        t1.join();
        t2.join();

        // Số đếm cuối cùng sẽ luôn chính xác là 20.000.
        System.out.println("Final count (safe): " + counter.getCount());
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn có một lớp `BankAccount` với các method `deposit(double amount)` và `withdraw(double amount)`. Số dư tài khoản được lưu trữ trong một trường `private double balance`.
1.  Triển khai lớp mà không có bất kỳ đồng bộ hóa nào.
2.  Tạo một kịch bản với hai luồng: một luồng liên tục gửi 10 đô la trong một vòng lặp (1000 lần), và luồng kia liên tục rút 10 đô la trong một vòng lặp (1000 lần).
3.  Bắt đầu với số dư là 500 đô la. Sau khi cả hai luồng kết thúc, số dư cuối cùng vẫn phải là 500 đô la, nhưng do race condition, có khả năng nó sẽ không phải vậy.
4.  Nhiệm vụ của bạn là sử dụng từ khóa `synchronized` trên các method `deposit` và `withdraw` để làm cho lớp `BankAccount` an toàn cho luồng và đảm bảo số dư cuối cùng là chính xác.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Một method `static` được khai báo là `synchronized`. Khóa nội tại của object nào một luồng phải có được để thực thi method này?

A) Instance object `this` mà trên đó method được gọi.
B) Một object khóa mới được tạo riêng cho lời gọi method này.
C) Object `Class` tương ứng với lớp nơi method được định nghĩa.
D) Các method `static` không thể được đồng bộ hóa.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Object `Class` tương ứng với lớp nơi method được định nghĩa. Vì một method `static` không được liên kết với bất kỳ instance cụ thể nào (`this`), khóa được lấy trên object `java.lang.Class` cho lớp đó. Điều này có nghĩa là chỉ một luồng có thể thực thi *bất kỳ* method static synchronized nào trong lớp đó tại một thời điểm.

### **Bài 3: Mô hình bộ nhớ Java và `volatile`**

#### **1. Giải thích khái niệm**

Synchronization không chỉ về việc loại trừ lẫn nhau (tính nguyên tử); nó còn về việc đảm bảo rằng các thay đổi được thực hiện bởi một luồng có thể được nhìn thấy bởi các luồng khác. Vấn đề về **tính hiển thị (visibility)** này được điều chỉnh bởi một bộ quy tắc phức tạp được gọi là **Mô hình bộ nhớ Java (JMM)**.

##### **Vấn đề: Các luồng có bộ đệm (cache) riêng**
Các kiến trúc máy tính hiện đại rất phức tạp. Để cải thiện hiệu suất, mỗi lõi CPU có một bộ cache riêng nằm giữa lõi và bộ nhớ chính (RAM). Khi một luồng chạy trên Lõi A đọc một biến từ bộ nhớ chính, nó có thể sao chép giá trị đó vào cache cục bộ của mình. Khi nó sửa đổi biến, nó có thể chỉ cập nhật giá trị trong cache cục bộ của mình.

Điều này dẫn đến một vấn đề lớn:
1.  **Luồng A** trên **Lõi A** đọc `flag = false` từ bộ nhớ chính vào cache của nó.
2.  **Luồng B** trên **Lõi B** đọc `flag = false` từ bộ nhớ chính vào cache của nó.
3.  **Luồng A** cập nhật `flag = true`. Thay đổi này có thể chỉ được ghi vào **cache của Lõi A**. Bộ nhớ chính và cache của Lõi B vẫn thấy `flag` là `false`.
4.  **Luồng B** kiểm tra giá trị của `flag`. Nó đọc từ cache của chính mình và thấy `false`, mặc dù Luồng A đã thay đổi nó. Luồng B đang làm việc với dữ liệu lỗi thời.

**JMM** là một đặc tả định nghĩa các đảm bảo mà JVM đưa ra về thời điểm một ghi vào một biến bởi một luồng được đảm bảo sẽ được nhìn thấy bởi một lần đọc tiếp theo của cùng một biến đó bởi một luồng khác. Nó định nghĩa mối quan hệ "xảy ra trước" (happens-before).

##### **Mối quan hệ `happens-before`**
Nếu hành động A *xảy ra trước* hành động B, thì kết quả của A được đảm bảo sẽ được nhìn thấy và được sắp xếp trước B. JMM định nghĩa một số quy tắc `happens-before` chính:
1.  **Quy tắc thứ tự chương trình:** Các hành động trong một luồng duy nhất xảy ra theo thứ tự chúng xuất hiện trong mã.
2.  **Quy tắc khóa monitor:** Một *mở khóa* trên một khóa monitor (thoát khỏi một khối `synchronized`) *xảy ra trước* mọi *khóa* tiếp theo trên cùng một monitor đó.
3.  **Quy tắc biến `volatile`:** Một *ghi* vào một biến `volatile` *xảy ra trước* mọi *đọc* tiếp theo của cùng một biến `volatile` đó.
4.  **Quy tắc bắt đầu luồng:** Một lời gọi đến `Thread.start()` *xảy ra trước* bất kỳ hành động nào trong luồng mới.
5.  **Quy tắc join luồng:** Tất cả các hành động trong một luồng *xảy ra trước* một luồng khác trả về thành công từ một `join()` trên nó.

##### **Vai trò của `synchronized` trong Tính hiển thị bộ nhớ**
Từ khóa `synchronized` giải quyết cả vấn đề về tính nguyên tử và tính hiển thị.
*   Khi một luồng **vào** một khối `synchronized`, nó làm mất hiệu lực cache cục bộ của mình và buộc phải đọc các giá trị mới nhất của các biến được chia sẻ từ bộ nhớ chính.
*   Khi một luồng **thoát** khỏi một khối `synchronized`, nó đẩy bất kỳ thay đổi nào nó đã thực hiện đối với các biến được chia sẻ từ cache cục bộ của mình trở lại bộ nhớ chính.

Đây là những gì "Quy tắc khóa monitor" đảm bảo. Việc mở khóa (thoát) bởi Luồng A đẩy các thay đổi của nó, và việc khóa (vào) bởi Luồng B buộc phải đọc mới, đảm bảo Luồng B thấy công việc của Luồng A.

##### **Từ khóa `volatile`: Một dạng đồng bộ hóa yếu hơn**
Từ khóa `volatile` là một modifier trường cung cấp sự đảm bảo về **tính hiển thị** và **thứ tự**, nhưng **không phải tính nguyên tử**.

Khi bạn khai báo một trường là `volatile`:
1.  **Tính hiển thị:** Bất kỳ ghi nào vào trường `volatile` đó đều được đảm bảo sẽ được đẩy vào bộ nhớ chính ngay lập tức. Bất kỳ đọc nào của trường `volatile` đó đều được đảm bảo sẽ được đọc trực tiếp từ bộ nhớ chính. Điều này giải quyết vấn đề cache lỗi thời.
2.  **Thứ tự:** Nó ngăn trình biên dịch và CPU sắp xếp lại các chỉ thị liên quan đến biến `volatile` theo cách có thể vi phạm mối quan hệ happens-before. Nó hoạt động như một "rào cản bộ nhớ" (memory barrier).

**`volatile` vs. `synchronized`:**
*   Sử dụng `synchronized` khi bạn cần bảo vệ một hành động phức hợp (như `count++`) và đảm bảo **tính nguyên tử**. Đó là một cơ chế dựa trên khóa, loại trừ lẫn nhau.
*   Sử dụng `volatile` khi bạn có một cờ hoặc biến đơn giản đang được một luồng ghi và các luồng khác đọc, và bạn chỉ cần đảm bảo **tính hiển thị**. `volatile` nhẹ hơn nhiều so với `synchronized` vì nó không liên quan đến việc khóa và chặn các luồng.

**Một trường hợp sử dụng kinh điển cho `volatile` là một cờ trạng thái để kết thúc một luồng.**

---

#### **2. Ví dụ mã nguồn: `volatile` cho Tính hiển thị**

##### **Vấn đề: Một cờ lỗi thời**
Nếu không có `volatile`, `readerThread` có thể lưu vào cache giá trị của `flag` là `false` và không bao giờ thấy sự thay đổi được thực hiện bởi `main` thread, dẫn đến một vòng lặp vô hạn. Điều này không được đảm bảo sẽ xảy ra, nhưng đó là một khả năng được JMM cho phép.

```java
class StaleWorker {
    // Nếu không có volatile, sự thay đổi của 'flag' có thể không được nhìn thấy.
    private boolean flag = true;

    public void work() {
        while (flag) {
            // ... làm một số công việc ...
        }
        System.out.println("StaleWorker: I've been told to stop.");
    }

    public void stopWorking() {
        this.flag = false;
    }
}
```

##### **Giải pháp: Sử dụng `volatile`**
Bằng cách làm cho `flag` trở thành volatile, chúng ta đảm bảo rằng bất kỳ thay đổi nào được thực hiện bởi một luồng đều ngay lập tức được nhìn thấy bởi bất kỳ luồng nào khác đọc nó.

```java
class VolatileWorker {
    // Từ khóa volatile đảm bảo tính hiển thị.
    private volatile boolean flag = true;

    public void work() {
        while (flag) {
            // Việc đọc 'flag' sẽ luôn đến từ bộ nhớ chính.
        }
        System.out.println("VolatileWorker: I've been told to stop.");
    }

    public void stopWorking() {
        // Việc ghi vào 'flag' sẽ được đẩy vào bộ nhớ chính ngay lập tức.
        this.flag = false;
        System.out.println("Main thread set flag to false.");
    }
}

public class VolatileDemo {
    public static void main(String[] args) throws InterruptedException {
        VolatileWorker worker = new VolatileWorker();
        Thread workerThread = new Thread(worker::work);

        workerThread.start();

        // Để luồng worker chạy một lúc
        Thread.sleep(100);

        // Bảo worker dừng lại
        worker.stopWorking();

        // Chờ luồng worker kết thúc
        workerThread.join();
        System.out.println("Worker thread has terminated.");
    }
}
```

---

#### **3. Bài tập nhỏ**
Tạo một lớp `TaskRunner` với hai method: `executeTask()` và `getLatestResult()`.
1.  Nó nên có hai trường: `private int result` và `private volatile boolean ready`. Khởi tạo `result = 0` và `ready = false`.
2.  Method `executeTask()` sẽ được gọi bởi một luồng "worker". Nó nên thực hiện một phép tính đơn giản (ví dụ: đặt `result = 42`) và sau đó, ở bước cuối cùng, đặt `ready = true`.
3.  Method `getLatestResult()` sẽ được gọi bởi một luồng "main". Nó nên lặp (`while (!ready)`) cho đến khi cờ `ready` trở thành true. Đây là một dạng "chờ bận rộn" (chúng ta sẽ thấy các cách tốt hơn để xử lý sau này). Khi `ready` là true, nó nên trả về `result`.
4.  Giải thích tại sao `ready` phải là `volatile`. (Gợi ý: Hãy nghĩ về quy tắc happens-before và việc sắp xếp lại chỉ thị. Điều gì sẽ xảy ra nếu trình biên dịch sắp xếp lại mã sao cho `ready = true` được đặt *trước* `result = 42`?)

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn có một biến đếm được chia sẻ `private int count = 0;` được tăng bởi nhiều luồng bằng hoạt động `count++;`. Từ khóa nào là lựa chọn đúng để làm cho hoạt động này an toàn cho luồng?

A) `volatile`, vì nó đảm bảo giá trị mới nhất của `count` luôn được đọc từ bộ nhớ chính.
B) `final`, vì nó ngăn biến `count` khỏi bị gán lại.
C) `synchronized`, vì `count++` là một hoạt động phức hợp (đọc-sửa-ghi) phải là nguyên tử.
D) `static`, vì nó làm cho biến được chia sẻ giữa tất cả các instance.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `synchronized`. `volatile` không đủ ở đây. Mặc dù `volatile` sẽ đảm bảo rằng mỗi luồng đều thấy giá trị mới nhất của `count`, nó **không** làm cho hoạt động `count++` trở thành nguyên tử. Hai luồng vẫn có thể đọc cùng một giá trị (ví dụ: 5), cả hai đều tăng nó lên 6, và cả hai đều ghi lại 6, làm mất một lần tăng. `synchronized` là cần thiết để khóa toàn bộ chuỗi đọc-sửa-ghi, đảm bảo tính nguyên tử.

### **Bài 4: Giao tiếp giữa các luồng (`wait()`, `notify()`, `notifyAll()`)**

#### **1. Giải thích khái niệm**

Trong khi `volatile` tốt cho giao tiếp một chiều (báo hiệu), việc điều phối phức tạp hơn giữa các luồng đòi hỏi một cơ chế để một luồng tạm dừng việc thực thi của nó cho đến khi một luồng khác báo hiệu rằng một điều kiện nào đó đã được đáp ứng. Cơ chế kinh điển cho việc này trong Java là bộ ba method: `wait()`, `notify()`, và `notifyAll()`.

Các method này được định nghĩa trong lớp `java.lang.Object`, có nghĩa là mọi object trong Java đều có thể hoạt động như một hàng đợi điều kiện.

##### **Khóa nội tại và "Hàng đợi điều kiện"**
Mỗi object Java có hai bộ máy liên quan cho việc đồng thời:
1.  **Một Khóa nội tại (hoặc Monitor):** Đây là những gì từ khóa `synchronized` sử dụng để loại trừ lẫn nhau. Chỉ một luồng có thể "sở hữu" khóa tại một thời điểm.
2.  **Một Hàng đợi điều kiện (hoặc Wait Set):** Đây là một tập hợp các luồng vô hình được liên kết với object. Đây là các luồng đã gọi `wait()` trên object và hiện đang bị tạm dừng.

##### **Cách `wait()`, `notify()`, và `notifyAll()` hoạt động**

*   **`wait()`:**
    1.  Một luồng **trước tiên phải sở hữu khóa nội tại** của một object để gọi `wait()` trên nó. Nếu không, nó sẽ ném ra một `IllegalMonitorStateException`. Điều này có nghĩa là `wait()` phải được gọi từ bên trong một khối hoặc method `synchronized`.
    2.  Khi một luồng gọi `object.wait()`, nó **giải phóng khóa một cách nguyên tử** trên `object` và vào trạng thái `WAITING`.
    3.  Sau đó, nó được đặt vào hàng đợi điều kiện của object và vẫn không hoạt động cho đến khi một luồng khác gọi `notify()` hoặc `notifyAll()` trên *cùng một object*.
    4.  Khi luồng đang chờ được đánh thức, nó **không** ngay lập tức tiếp tục thực thi. Trước tiên, nó phải **lấy lại khóa** trên object. Nó sẽ được chuyển từ trạng thái `WAITING` sang trạng thái `BLOCKED` cho đến khi khóa có sẵn.

*   **`notify()`:**
    1.  Một luồng **cũng phải sở hữu khóa nội tại** của một object để gọi `notify()` trên nó.
    2.  Nó đánh thức một **luồng duy nhất, được chọn tùy ý** từ tập hợp các luồng đang chờ trên hàng đợi điều kiện của object đó.
    3.  Luồng được đánh thức sau đó sẽ cố gắng lấy lại khóa. Luồng thông báo không giải phóng khóa cho đến khi nó thoát khỏi khối `synchronized` của mình.

*   **`notifyAll()`:**
    1.  Giống như `notify()`, nhưng nó đánh thức **tất cả** các luồng đang chờ trên hàng đợi điều kiện của object.
    2.  Tất cả các luồng được đánh thức sau đó sẽ cạnh tranh để có được khóa. Chỉ một luồng sẽ thắng tại một thời điểm, nhưng cuối cùng, tất cả sẽ có cơ hội chạy.
    *   **Thực hành tốt nhất:** **Luôn ưu tiên `notifyAll()` hơn `notify()`**. Sử dụng `notify()` là một sự tối ưu hóa rủi ro. Bạn có thể vô tình đánh thức sai loại luồng (nếu nhiều điều kiện đang được chờ đợi), hoặc bạn có thể không đánh thức được một luồng cần chạy, dẫn đến bế tắc. `notifyAll()` an toàn và mạnh mẽ hơn.

##### **Spurious Wakeups và Vòng lặp `while`**
Vì những lý do phức tạp liên quan đến việc lập lịch luồng của HĐH, một luồng đang chờ có thể thức dậy *mà không* được thông báo (một "spurious wakeup"). Do đó, đặc tả của Java yêu cầu `wait()` phải **luôn** được gọi bên trong một vòng lặp `while` để kiểm tra lại điều kiện mà nó đang chờ đợi.

**Vòng lặp `wait()` kinh điển:**
```java
synchronized (lockObject) {
    while (!conditionIsMet) { // KHÔNG sử dụng câu lệnh 'if' ở đây!
        lockObject.wait();
    }
    // Tiếp tục, điều kiện bây giờ được đảm bảo là đã được đáp ứng.
}
```
Vòng lặp này bảo vệ chống lại các spurious wakeup. Nếu luồng thức dậy vì bất kỳ lý do gì và điều kiện vẫn chưa đúng, nó sẽ chỉ cần gọi `wait()` một lần nữa và quay trở lại ngủ.

---

#### **2. Ví dụ mã nguồn: Vấn đề Producer-Consumer**

Đây là vấn đề kinh điển mà `wait()` và `notifyAll()` được thiết kế để giải quyết. Một luồng "producer" tạo ra các mục và thêm chúng vào một bộ đệm được chia sẻ, và một luồng "consumer" lấy các mục từ bộ đệm.

```java
import java.util.LinkedList;
import java.util.Queue;

// Lớp này đại diện cho bộ đệm được chia sẻ
class MessageQueue {
    private final Queue<String> queue = new LinkedList<>();
    private final int capacity;

    public MessageQueue(int capacity) {
        this.capacity = capacity;
    }

    // Producer gọi method này
    public synchronized void produce(String message) throws InterruptedException {
        // Chờ trong khi hàng đợi đầy
        while (queue.size() == capacity) {
            System.out.println("Queue is full, producer is waiting...");
            wait(); // Giải phóng khóa và chờ
        }
        queue.add(message);
        System.out.println("Produced: " + message);
        notifyAll(); // Thông báo cho bất kỳ consumer nào đang chờ rằng một mục đã có sẵn
    }

    // Consumer gọi method này
    public synchronized String consume() throws InterruptedException {
        // Chờ trong khi hàng đợi trống
        while (queue.isEmpty()) {
            System.out.println("Queue is empty, consumer is waiting...");
            wait(); // Giải phóng khóa và chờ
        }
        String message = queue.poll();
        System.out.println("Consumed: " + message);
        notifyAll(); // Thông báo cho bất kỳ producer nào đang chờ rằng không gian đã có sẵn
        return message;
    }
}

public class ProducerConsumerDemo {
    public static void main(String[] args) {
        MessageQueue queue = new MessageQueue(2); // Một dung lượng nhỏ để thấy việc chặn

        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    queue.produce("Message " + i);
                    Thread.sleep(500);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    queue.consume();
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        producer.start();
        consumer.start();
    }
}
```

---

#### **3. Bài tập nhỏ**

Tạo một mô phỏng `CountDownLatch` bằng cách sử dụng `wait()` và `notifyAll()`. Một countdown latch là một cơ chế cho phép một hoặc nhiều luồng chờ cho đến khi một tập hợp các hoạt động được thực hiện trong các luồng khác hoàn thành.
1.  Tạo một lớp `MyLatch` với một constructor nhận một `count`.
2.  Nó nên có một trường `private int count`.
3.  Triển khai một method `countDown()`. Method này nên là `synchronized`, giảm `count`, và nếu `count` đạt đến 0, nó nên gọi `notifyAll()`.
4.  Triển khai một method `await()`. Method này nên là `synchronized`. Bên trong một vòng lặp `while`, nó nên kiểm tra xem `count` có lớn hơn 0 không. Nếu có, nó nên gọi `wait()`.
5.  Trong `main`, tạo một latch với `count` là 3. Bắt đầu ba luồng "worker" mà mỗi luồng ngủ trong một thời gian ngẫu nhiên và sau đó gọi `countDown()`. `main` thread nên gọi `await()` ngay sau khi bắt đầu các worker và sau đó in "All workers have finished."

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Một luồng gọi `myObject.wait()`. Câu nào sau đây là **đúng**?

A) Luồng ngay lập tức tiếp tục thực thi ngay khi một luồng khác gọi `myObject.notify()`.
B) Luồng phải sở hữu khóa trên `myObject` trước khi gọi `wait()`, và nó giải phóng khóa này trong khi chờ.
C) `wait()` chỉ có thể được gọi bên ngoài một khối `synchronized`.
D) Luồng vào trạng thái `BLOCKED` trong khi chờ.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Luồng phải sở hữu khóa trên `myObject` trước khi gọi `wait()`, và nó giải phóng khóa này trong khi chờ. Đây là cơ chế cốt lõi của `wait()`. Nó phải giữ khóa để đảm bảo điều kiện nó đang kiểm tra là ổn định, và nó phải giải phóng khóa để các luồng khác (như một producer) có thể có được khóa để thay đổi điều kiện và gọi `notify()`. Trong khi chờ, luồng ở trạng thái `WAITING`, không phải `BLOCKED`.

### **Bài 5: Executor Framework**

#### **1. Giải thích khái niệm**

Việc tạo, bắt đầu và quản lý các luồng thủ công (`new Thread(...)`) là khả thi cho các ứng dụng đơn giản, nhưng nó trở nên cồng kềnh và không hiệu quả cho các hệ thống phức tạp, cấp doanh nghiệp. Cách tiếp cận này có một số nhược điểm:
*   **Chi phí cao:** Việc tạo một object `Thread` mới là một hoạt động tương đối tốn kém.
*   **Cạn kiệt tài nguyên:** Việc tạo ra một số lượng luồng không giới hạn có thể nhanh chóng tiêu thụ bộ nhớ và tài nguyên CPU của hệ thống, dẫn đến hiệu suất kém hoặc thậm chí là sập ứng dụng.
*   **Thiếu quản lý:** Không có cách nào tích hợp để dễ dàng quản lý vòng đời, hàng đợi, hoặc thống kê của các luồng được tạo thủ công.

**Executor Framework**, một phần của package `java.util.concurrent`, giải quyết các vấn đề này bằng cách tách rời **việc gửi tác vụ (task submission)** khỏi **việc thực thi tác vụ (task execution)**.

**Ví dụ tương tự:** Thay vì thuê một công nhân tạm thời mới (tạo một `Thread`) mỗi khi bạn có một tác vụ duy nhất, bạn thuê một đội ngũ công nhân cố định (một **thread pool**). Bạn, người quản lý (mã chính của bạn), chỉ cần giao các tác vụ từ một danh sách việc cần làm (một `BlockingQueue`) cho trưởng nhóm của bạn (`ExecutorService`). Trưởng nhóm sẽ giao các tác vụ cho các công nhân có sẵn. Điều này hiệu quả hơn rất nhiều.

##### **Các Interface và Lớp cốt lõi**

*   **`Executor`:** Một interface đơn giản với một method duy nhất, `execute(Runnable command)`. Đây là cách cơ bản nhất để gửi một tác vụ. Nó "bắn và quên" – bạn không thể nhận lại kết quả.

*   **`ExecutorService`:** Interface quan trọng nhất. Nó kế thừa `Executor` và thêm các method để quản lý vòng đời của executor và để xử lý các tác vụ tạo ra kết quả.
    *   **`submit(Runnable task)` / `submit(Callable<T> task)`:** Gửi một tác vụ để thực thi và trả về một object `Future`, đại diện cho kết quả đang chờ xử lý của tác vụ.
    *   **`shutdown()`:** Bắt đầu một quá trình tắt có trật tự. Nó ngừng chấp nhận các tác vụ mới nhưng cho phép các tác vụ đã gửi trước đó hoàn thành.
    *   **`shutdownNow()`:** Cố gắng dừng tất cả các tác vụ đang thực thi tích cực, tạm dừng việc xử lý các tác vụ đang chờ, và trả về một danh sách các tác vụ đang chờ thực thi.
    *   **`awaitTermination(long timeout, TimeUnit unit)`:** Chặn cho đến khi tất cả các tác vụ đã hoàn thành sau một yêu cầu tắt, hoặc hết thời gian chờ.

*   **`Executors` (Lớp Factory):** Một lớp tiện ích cung cấp các factory method tiện lợi để tạo các loại thread pool được cấu hình sẵn khác nhau. Bạn thường nên sử dụng cái này cho các trường hợp đơn giản.

##### **Các loại Thread Pool**

1.  **Fixed Thread Pool (`Executors.newFixedThreadPool(int nThreads)`)**
    *   **Hành vi:** Tạo một pool với một số lượng luồng cố định. Nếu tất cả các luồng đều bận và có thêm tác vụ được gửi, các tác vụ sẽ được đặt trong một `LinkedBlockingQueue` không giới hạn để chờ.
    *   **Trường hợp sử dụng:** Lý tưởng cho các tác vụ tốn nhiều CPU, nơi số lượng luồng nên gần bằng số lượng lõi CPU có sẵn để tránh chuyển đổi ngữ cảnh quá mức. Nó cung cấp việc sử dụng tài nguyên có thể dự đoán được.

2.  **Cached Thread Pool (`Executors.newCachedThreadPool()`)**
    *   **Hành vi:** Tạo một pool phát triển và thu hẹp một cách linh hoạt. Nó tạo ra các luồng mới khi cần thiết nếu tất cả các luồng hiện có đều bận. Các luồng không hoạt động trong 60 giây sẽ bị kết thúc và xóa khỏi pool.
    *   **Trường hợp sử dụng:** Tuyệt vời cho một số lượng lớn các tác vụ không đồng bộ, tồn tại ngắn, thường là các tác vụ I/O, nơi các luồng dành nhiều thời gian để chờ.
    *   **Rủi ro:** Có thể dẫn đến cạn kiệt tài nguyên nếu một số lượng lớn các tác vụ được gửi đồng thời, vì nó có thể tạo ra một số lượng luồng không giới hạn.

3.  **Scheduled Thread Pool (`Executors.newScheduledThreadPool(int corePoolSize)`)**
    *   **Hành vi:** Tạo một pool có thể lập lịch cho các lệnh chạy sau một độ trễ nhất định, hoặc để thực thi định kỳ.
    *   **Methods:** `schedule()`, `scheduleAtFixedRate()`, `scheduleWithFixedDelay()`.
    *   **Trường hợp sử dụng:** Cho các tác vụ cần được chạy vào các thời điểm hoặc khoảng thời gian cụ thể, như các công việc dọn dẹp nền hoặc kiểm tra sức khỏe.

##### **`Callable<V>` và `Future<V>`**

*   **Hạn chế của `Runnable`:** Method `run()` là `void` và không thể ném ra các checked exception.
*   **`Callable<V>`:** Một tác vụ có thể **trả về một kết quả** và **ném ra một checked exception**. Nó có một method duy nhất: `V call() throws Exception`.
*   **`Future<V>`:** Một object đại diện cho kết quả của một tính toán không đồng bộ. Khi bạn `submit` một `Callable`, bạn nhận lại một `Future` ngay lập tức. `Future` hoạt động như một trình giữ chỗ cho kết quả, có thể chưa có sẵn.
    *   **`V get()`:** Method này **chặn** cho đến khi tính toán hoàn tất và sau đó lấy kết quả của nó.
    *   **`isDone()`:** Kiểm tra xem tác vụ đã hoàn thành chưa.
    *   **`cancel(boolean mayInterruptIfRunning)`:** Cố gắng hủy tác vụ.

---

#### **2. Ví dụ mã nguồn: Sử dụng một Fixed Thread Pool**

Ví dụ này minh họa việc gửi các tác vụ đến một `ExecutorService` và lấy kết quả của chúng bằng `Future`.

```java
import java.util.concurrent.*;

// Một tác vụ trả về một kết quả và có thể ném ra một ngoại lệ
class FactorialCalculator implements Callable<Long> {
    private final int number;

    public FactorialCalculator(int number) {
        if (number < 0) {
            throw new IllegalArgumentException("Number must be non-negative.");
        }
        this.number = number;
    }

    @Override
    public Long call() throws Exception {
        long result = 1;
        for (int i = 2; i <= number; i++) {
            result *= i;
            Thread.sleep(100); // Mô phỏng một tính toán dài
        }
        System.out.println("Factorial of " + number + " is " + result);
        return result;
    }
}

public class ExecutorServiceDemo {
    public static void main(String[] args) {
        // Tạo một pool với 2 luồng
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Gửi một tác vụ và nhận lại một Future
        System.out.println("Submitting task for 10...");
        Future<Long> future10 = executor.submit(new FactorialCalculator(10));

        System.out.println("Submitting task for 5...");
        Future<Long> future5 = executor.submit(new FactorialCalculator(5));

        try {
            // Method get() chặn cho đến khi kết quả có sẵn.
            System.out.println("Waiting for result of 10...");
            long result10 = future10.get();
            System.out.println("Result of factorial(10) is: " + result10);

            System.out.println("Waiting for result of 5...");
            long result5 = future5.get();
            System.out.println("Result of factorial(5) is: " + result5);

        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            // Luôn tắt executor service!
            executor.shutdown();
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn được giao nhiệm vụ tải xuống nội dung của một số URL đồng thời.
1.  Tạo một lớp `Callable<String>` có tên `UrlContentDownloader` nhận một chuỗi URL trong constructor của nó.
2.  Method `call()` nên mô phỏng việc tải xuống bằng cách ngủ trong một khoảng thời gian ngẫu nhiên và sau đó trả về một chuỗi giả như "Content of [URL]".
3.  Trong `main`, tạo một `List<String>` các URL.
4.  Tạo một fixed thread pool.
5.  Lặp qua danh sách URL của bạn, tạo một `UrlContentDownloader` cho mỗi cái, và `submit` nó vào executor, lưu trữ các object `Future<String>` được trả về trong một `List<Future<String>>`.
6.  Sau khi gửi tất cả các tác vụ, hãy lặp qua danh sách các `Future` và gọi `get()` trên mỗi cái để lấy và in nội dung.
7.  Tắt executor service một cách đúng đắn trong một khối `finally`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Sự khác biệt chính giữa `executor.execute(Runnable)` và `executor.submit(Runnable)` là gì?

A) `execute()` dành cho `Runnable`, trong khi `submit()` chỉ dành cho `Callable`.
B) `execute()` có thể ném ra ngoại lệ, trong khi `submit()` thì không.
C) `execute()` trả về `void` ("bắn và quên"), trong khi `submit()` trả về một object `Future` có thể được sử dụng để theo dõi sự hoàn thành và kết quả của tác vụ.
D) `execute()` sử dụng một fixed thread pool, trong khi `submit()` sử dụng một cached thread pool.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) `execute()` trả về `void` ("bắn và quên"), trong khi `submit()` trả về một object `Future` có thể được sử dụng để theo dõi sự hoàn thành và kết quả của tác vụ. Ngay cả khi gửi một `Runnable`, `submit()` trả về một `Future<?>` có thể được sử dụng để kiểm tra xem tác vụ đã xong chưa hoặc để hủy nó. Điều này làm cho `submit()` mạnh mẽ hơn và thường được ưu tiên hơn.

### **Bài 6: Các hoạt động nguyên tử và Framework Locks**

#### **1. Giải thích khái niệm**

Trong khi `synchronized` là một công cụ mạnh mẽ, nó là một cơ chế chặn, nặng nề. Package `java.util.concurrent` cung cấp các công cụ tinh vi và chi tiết hơn để quản lý an toàn luồng: **các biến nguyên tử (atomic variables)** cho các hoạt động không cần khóa và **Framework Locks** cho các mẫu khóa nâng cao.

##### **Các biến nguyên tử và CAS (Compare-And-Swap)**

Package `java.util.concurrent.atomic` cung cấp một tập hợp các lớp (`AtomicInteger`, `AtomicLong`, `AtomicReference`, `AtomicBoolean`) hỗ trợ lập trình an toàn luồng, không cần khóa trên các biến đơn lẻ.

*   **Vấn đề với `volatile`:** Một `volatile int count;` với một hoạt động `count++` không an toàn cho luồng. `volatile` đảm bảo tính hiển thị, nhưng `count++` không phải là một hoạt động nguyên tử.
*   **Giải pháp với `AtomicInteger`:** Một `AtomicInteger` bao bọc một giá trị `int` và cung cấp các hoạt động phức hợp nguyên tử như `incrementAndGet()`, `getAndAdd()`, và `compareAndSet()`.

**Cơ chế nội bộ: Compare-And-Swap (CAS)**
Các biến nguyên tử đạt được sự an toàn cho luồng của chúng mà không cần sử dụng khóa. Thay vào đó, chúng dựa vào một chỉ thị nguyên tử cấp thấp, được hỗ trợ bởi phần cứng được gọi là **Compare-And-Swap (CAS)**. Một hoạt động CAS là một cách tiếp cận lạc quan bao gồm ba toán hạng:
1.  **V:** Vị trí bộ nhớ sẽ được sửa đổi (biến).
2.  **A:** Giá trị cũ "dự kiến" mà luồng nghĩ rằng đang ở trong V.
3.  **B:** Giá trị mới sẽ được đặt.

Chỉ thị CAS sẽ cập nhật nguyên tử giá trị tại V thành B **khi và chỉ khi** giá trị hiện tại tại V bằng A. Chỉ thị trả về một boolean cho biết việc cập nhật có thành công hay không.

**Ví dụ tương tự:** Hãy tưởng tượng một cuộc đấu giá im lặng. Bạn muốn trả giá 110 đô la. Bạn viết trên phiếu của mình: "Nếu giá thầu hiện tại là 100 đô la (A), giá thầu mới của tôi là 110 đô la (B)." Bạn đưa cái này cho người bán đấu giá.
*   **Thành công:** Nếu giá thầu hiện tại vẫn là 100 đô la khi người bán đấu giá đọc phiếu của bạn, họ sẽ cập nhật giá lên 110 đô la. Hoạt động của bạn đã thành công.
*   **Thất bại:** Nếu một người trả giá khác nhanh hơn và giá đã là 120 đô la, điều kiện của bạn ("nếu giá thầu hiện tại là 100 đô la") là sai. Người bán đấu giá từ chối phiếu của bạn. Hoạt động của bạn đã thất bại. Bây giờ bạn phải lấy giá hiện tại mới (120 đô la) và gửi một giá thầu mới.

Các method như `incrementAndGet()` trong `AtomicInteger` thường sử dụng CAS trong một vòng lặp:
```java
// Logic khái niệm của incrementAndGet()
int current;
do {
    current = get(); // Đọc giá trị hiện tại
} while (!compareAndSet(current, current + 1)); // Thử hoán đổi nó với giá trị đã tăng
// Nếu một luồng khác đã thay đổi 'current' trong thời gian chờ, compareAndSet sẽ thất bại, và chúng ta lặp lại để thử lại.
```
Đây là một cách tiếp cận **non-blocking** hoặc **lock-free**, có thể cung cấp hiệu suất tốt hơn đáng kể dưới sự cạnh tranh cao so với các khóa truyền thống.

##### **Framework `java.util.concurrent.locks`**

Interface `Lock` cung cấp một cơ chế khóa linh hoạt và mạnh mẽ hơn từ khóa `synchronized`.

**`ReentrantLock`**
Một `ReentrantLock` là một sự thay thế trực tiếp cho `synchronized` cung cấp nhiều tính năng hơn.

| Tính năng | Từ khóa `synchronized` | `ReentrantLock` |
| :--- | :--- | :--- |
| **Lấy khóa** | Chặn vô thời hạn. | Có thể chặn (`lock()`), nhưng cũng hỗ trợ `tryLock()` không chặn và `tryLock(time, unit)` có thời gian chờ. |
| **Tính có thể bị ngắt**| Một luồng không thể bị ngắt trong khi chờ một khóa. | Một luồng có thể bị ngắt trong khi chờ một khóa thông qua `lockInterruptibly()`. |
| **Tính công bằng** | Không công bằng theo mặc định (không đảm bảo thứ tự lấy khóa). | Có thể được cấu hình là "công bằng" hoặc "không công bằng" trong constructor. Một khóa công bằng cấp quyền truy cập cho luồng chờ đợi lâu nhất. |
| **Mở khóa** | Tự động (khi khối/method được thoát). | **Thủ công**. Bạn **phải** gọi `unlock()` trong một khối `finally` để đảm bảo khóa được giải phóng. |

**Mẫu `try-finally` bắt buộc cho Locks:**
```java
Lock myLock = new ReentrantLock();
...
myLock.lock(); // Lấy khóa
try {
    // ... phần quan trọng ...
} finally {
    myLock.unlock(); // PHẢI ở trong một khối finally
}
```

**`ReadWriteLock` và `ReentrantReadWriteLock`**
Khóa này duy trì một cặp khóa liên quan, một để đọc và một để ghi. Nó được thiết kế để giải quyết một vấn đề phổ biến: nếu một tài nguyên được chia sẻ được đọc thường xuyên hơn nhiều so với việc được ghi, việc sử dụng một khóa độc quyền duy nhất (`synchronized` hoặc `ReentrantLock`) là không hiệu quả vì nó ngăn cản nhiều người đọc truy cập tài nguyên cùng một lúc.

*   **Quy tắc:** Nhiều luồng có thể giữ **khóa đọc** đồng thời, miễn là không có luồng nào giữ **khóa ghi**. Chỉ một luồng có thể giữ **khóa ghi** tại một thời điểm, và nó loại trừ tất cả những người đọc.
*   **Trường hợp sử dụng:** Hoàn hảo cho các hệ thống bộ đệm, các object cấu hình, hoặc bất kỳ cấu trúc dữ liệu nào được đọc thường xuyên nhưng được sửa đổi không thường xuyên.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này cho thấy một bộ đếm an toàn cho luồng được triển khai với `AtomicInteger` và một bộ đệm an toàn cho luồng được triển khai với `ReentrantReadWriteLock`.

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

// 1. Bộ đếm sử dụng AtomicInteger (lock-free)
class AtomicCounter {
    private AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // Hoạt động nguyên tử
    }

    public int getCount() {
        return count.get();
    }
}

// 2. Bộ đệm sử dụng ReadWriteLock
class ThreadSafeCache<K, V> {
    private final Map<K, V> map = new HashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock readLock = lock.readLock();
    private final Lock writeLock = lock.writeLock();

    public V get(K key) {
        readLock.lock(); // Nhiều luồng có thể có được khóa đọc
        try {
            return map.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public void put(K key, V value) {
        writeLock.lock(); // Chỉ một luồng có thể có được khóa ghi
        try {
            map.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Tái cấu trúc lớp `BankAccount` từ Bài 2.
1.  Thay vì sử dụng các method `synchronized`, hãy cung cấp cho `BankAccount` một trường `private final ReentrantLock lock`.
2.  Sửa đổi các method `deposit(double amount)` và `withdraw(double amount)`.
3.  Bên trong mỗi method, hãy lấy khóa bằng cách sử dụng `lock.lock()`.
4.  Đặt logic sửa đổi `balance` bên trong một khối `try`.
5.  Đảm bảo rằng `lock.unlock()` được gọi trong một khối `finally` tương ứng để đảm bảo khóa luôn được giải phóng.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Điều nào sau đây là một khả năng của `ReentrantLock` mà **không** có sẵn khi sử dụng một khối `synchronized`?

A) Nó là tái nhập, cho phép một luồng lấy một khóa mà nó đã giữ.
B) Nó cung cấp một mối quan hệ happens-before, đảm bảo tính hiển thị bộ nhớ.
C) Nó cho phép một luồng cố gắng lấy một khóa trong một khoảng thời gian xác định và từ bỏ nếu nó không có sẵn.
D) Nó có thể được sử dụng để bảo vệ các method static.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Nó cho phép một luồng cố gắng lấy một khóa trong một khoảng thời gian xác định và từ bỏ nếu nó không có sẵn. Điều này được thực hiện bằng cách sử dụng method `tryLock(long time, TimeUnit unit)`. Các khối `synchronized` sẽ chờ vô thời hạn để có được một khóa. Cả hai đều là tái nhập (A) và cung cấp các đảm bảo happens-before (B). Cả hai đều có thể được sử dụng để bảo vệ các thành viên static (C, bằng cách sử dụng một object khóa static).

### **Bài 8: Fork/Join Framework và Song song**

#### **1. Giải thích khái niệm**

##### **Đồng thời (Concurrency) vs. Song song (Parallelism)**
Hai thuật ngữ này thường được sử dụng thay thế cho nhau, nhưng chúng đại diện cho các khái niệm khác nhau.
*   **Concurrency:** Là việc xử lý nhiều tác vụ cùng một lúc bằng cách xen kẽ việc thực thi của chúng. Đó là việc cấu trúc một chương trình để xử lý nhiều tác vụ độc lập. Một CPU đơn lõi có thể đạt được sự đồng thời bằng cách chuyển đổi nhanh chóng giữa các luồng (chuyển đổi ngữ cảnh).
*   **Parallelism:** Là việc thực hiện nhiều tác vụ cùng một lúc. Nó đòi hỏi phần cứng có nhiều đơn vị xử lý (ví dụ: một CPU đa lõi). Song song là một tập hợp con của đồng thời, trong đó các tác vụ xen kẽ thực sự được thực thi đồng thời.

**Ví dụ tương tự:**
*   **Concurrency:** Một đầu bếp duy nhất trong nhà bếp đang nấu hai món. Họ thái rau cho món A, sau đó đặt một cái nồi lên bếp cho món B, sau đó quay lại món A, v.v. Họ đang *quản lý* hai tác vụ cùng một lúc, nhưng chỉ *làm* một việc tại bất kỳ một micro giây nào.
*   **Parallelism:** Hai đầu bếp trong cùng một nhà bếp. Một đầu bếp dành riêng cho món A, và người kia dành riêng cho món B. Cả hai đều đang làm việc *đồng thời*.

**Fork/Join Framework**, được giới thiệu trong Java 7, là một công cụ được thiết kế đặc biệt để đạt được **parallelism**.

##### **Fork/Join Framework**
Framework này là một triển khai của `ExecutorService` được thiết kế để chạy hiệu quả một số lượng lớn các tác vụ bằng cách sử dụng một pool các luồng worker. Nó được xây dựng đặc biệt cho các thuật toán **"chia để trị" (divide and conquer)**. Ý tưởng cốt lõi là lấy một vấn đề lớn, đệ quy chia nó thành các vấn đề con nhỏ hơn, độc lập cho đến khi chúng đủ đơn giản để được giải quyết trực tiếp, và sau đó kết hợp kết quả của các vấn đề con để có được giải pháp cuối cùng.

Nó phù hợp nhất cho các **tác vụ tốn nhiều CPU**, không phải các tác vụ I/O, nơi các luồng sẽ không hoạt động chờ đợi.

##### **Các thành phần cốt lõi**
1.  **`ForkJoinPool`:**
    *   Đây là thread pool quản lý các luồng worker và thực thi các tác vụ.
    *   **Thuật toán Work-Stealing:** Đây là chìa khóa cho hiệu quả của nó. Mỗi luồng worker trong pool có một hàng đợi hai đầu (deque) riêng của các tác vụ. Một luồng xử lý các tác vụ từ đầu deque của chính nó. Khi deque của một luồng trống, nó trở nên không hoạt động. Thay vì ngủ, nó nhìn vào **đuôi** deque của một luồng bận rộn khác và "đánh cắp" một tác vụ để thực thi. Điều này đảm bảo rằng tất cả các luồng đều được giữ bận rộn, tối đa hóa việc sử dụng CPU.

2.  **`RecursiveTask<V>`:**
    *   Một tác vụ trả về một kết quả. Bạn kế thừa lớp này và triển khai method `compute()` của nó. Đây là lớp cơ sở phổ biến nhất.

3.  **`RecursiveAction`:**
    *   Một tác vụ không trả về kết quả (method `compute()` của nó là `void`).

##### **Các bước "Fork" và "Join"**
Logic bên trong method `compute()` thường tuân theo mẫu này:
1.  **Trường hợp cơ sở:** Kiểm tra xem khối công việc hiện tại có đủ nhỏ để được giải quyết trực tiếp mà không cần chia nhỏ thêm không.
2.  **Bước đệ quy (Fork):** Nếu công việc quá lớn, "fork" nó bằng cách chia nó thành hai hoặc nhiều tác vụ con.
3.  **Thực thi các tác vụ con:** Bắt đầu các tác vụ con để thực thi không đồng bộ.
4.  **Kết hợp kết quả (Join):** Chờ cho các tác vụ con hoàn thành và sau đó kết hợp kết quả của chúng.

---

#### **2. Ví dụ mã nguồn: Tính tổng song song**

Ví dụ này sử dụng Fork/Join framework để tính tổng của tất cả các phần tử trong một mảng lớn một cách song song.

```java
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

// Một tác vụ trả về một kết quả Long
class ArraySumTask extends RecursiveTask<Long> {
    // Một ngưỡng kích thước vấn đề mà dưới đó chúng ta không chia nhỏ thêm.
    private static final int THRESHOLD = 10_000;
    private final long[] array;
    private final int start;
    private final int end;

    public ArraySumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        int length = end - start;
        // 1. Trường hợp cơ sở: Nếu tác vụ đủ nhỏ, hãy tính toán trực tiếp.
        if (length <= THRESHOLD) {
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        }

        // 2. Bước đệ quy: Tác vụ quá lớn, vì vậy hãy chia nó.
        int mid = start + (length / 2);
        ArraySumTask leftTask = new ArraySumTask(array, start, mid);
        ArraySumTask rightTask = new ArraySumTask(array, mid, end);

        // 3. Fork: Thực thi không đồng bộ tác vụ con bên trái.
        leftTask.fork();

        // Tính toán tác vụ con bên phải một cách đồng bộ trên luồng hiện tại.
        // Đây là một tối ưu hóa phổ biến để giảm chi phí quản lý luồng.
        long rightResult = rightTask.compute();

        // 4. Join: Chờ cho tác vụ con bên trái hoàn thành và lấy kết quả của nó.
        long leftResult = leftTask.join();

        // 5. Kết hợp các kết quả.
        return leftResult + rightResult;
    }
}

public class ForkJoinDemo {
    public static void main(String[] args) {
        long[] numbers = new long[1_000_000];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = i + 1;
        }

        // Sử dụng common pool, là một pool tĩnh, được chia sẻ.
        ForkJoinPool pool = ForkJoinPool.commonPool();
        
        // Tạo tác vụ chính
        ArraySumTask task = new ArraySumTask(numbers, 0, numbers.length);

        // Gửi tác vụ vào pool và lấy kết quả
        long result = pool.invoke(task);

        System.out.println("Sum calculated in parallel: " + result);
        
        // Common pool không nên được tắt.
    }
}
```

---

#### **3. Bài tập nhỏ**

Bạn cần tìm số lớn nhất trong một mảng số nguyên rất lớn bằng cách sử dụng Fork/Join framework.
1.  Tạo một lớp `MaxFinderTask` kế thừa `RecursiveTask<Integer>`.
2.  Method `compute()` nên có một trường hợp cơ sở: nếu kích thước của đoạn mảng dưới một ngưỡng, hãy tìm số lớn nhất bằng một vòng lặp đơn giản.
3.  Trong bước đệ quy, hãy chia tác vụ làm hai.
4.  Fork tác vụ con bên trái, tính toán tác vụ con bên phải, và join tác vụ con bên trái.
5.  Bước "kết hợp kết quả" sẽ là trả về `Math.max()` của các kết quả từ các tác vụ con bên trái và bên phải.
6.  Trong `main`, tạo một mảng lớn các số nguyên ngẫu nhiên và sử dụng một `ForkJoinPool` để tìm và in giá trị lớn nhất.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Ưu điểm chính của thuật toán work-stealing được `ForkJoinPool` sử dụng là gì?

A) Nó đảm bảo rằng các tác vụ nhỏ hơn luôn được thực thi trước các tác vụ lớn hơn.
B) Nó giảm thiểu việc sử dụng bộ nhớ bằng cách tái sử dụng các object `RecursiveTask`.
C) Nó tối đa hóa việc sử dụng CPU bằng cách đảm bảo rằng các luồng worker trở nên không hoạt động sẽ lấy các tác vụ từ các luồng bận rộn khác.
D) Nó đơn giản hóa mã bằng cách tự động kết hợp kết quả của các tác vụ con.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Nó tối đa hóa việc sử dụng CPU bằng cách đảm bảo rằng các luồng worker trở nên không hoạt động sẽ lấy các tác vụ từ các luồng bận rộn khác. Mục đích cốt lõi của work-stealing là giữ cho tất cả các lõi CPU có sẵn đều bận rộn, ngăn chặn các luồng ngồi không trong khi vẫn còn công việc cần làm ở nơi khác trong pool. Điều này dẫn đến thông lượng cao hơn cho các tính toán song song.

### **Bài 9: Virtual Threads (Java 21+)**

#### **1. Giải thích khái niệm**

##### **Vấn đề với các luồng truyền thống ("Platform")**
Như chúng ta đã thấy, các luồng Java truyền thống (`java.lang.Thread`) là các "platform thread". Mỗi platform thread là một trình bao bọc mỏng xung quanh một luồng hệ điều hành (HĐH) nặng nề.
*   **Nặng nề:** Các luồng HĐH là một tài nguyên khan hiếm. Chúng tiêu thụ một lượng bộ nhớ đáng kể (thường là 1-2 MB cho ngăn xếp) và có chi phí chuyển đổi ngữ cảnh cao.
*   **Nút thắt cổ chai về khả năng mở rộng:** Sự khan hiếm này tạo ra một giới hạn cơ bản về khả năng mở rộng, đặc biệt là đối với các ứng dụng có mô hình **một luồng cho mỗi yêu cầu** (phổ biến trong các máy chủ web). Nếu mỗi trong số 100.000 yêu cầu người dùng đồng thời có một platform thread riêng, máy chủ sẽ nhanh chóng hết bộ nhớ và bị sập. Đây là lý do tại sao các mô hình lập trình không đồng bộ phức tạp (như NIO với selector hoặc các framework phản ứng) đã được phát minh ra—để quản lý nhiều tác vụ với ít luồng HĐH.

##### **Giải pháp: Virtual Threads (Project Loom)**
**Virtual threads**, được giới thiệu như một tính năng cuối cùng trong Java 21, là một giải pháp mang tính cách mạng cho vấn đề này.

*   **Chúng là gì?** Virtual threads là các **luồng nhẹ được quản lý bởi Java runtime (JVM)**, không phải trực tiếp bởi HĐH. Nhiều virtual thread chạy mã Java của chúng trên *cùng một* luồng HĐH.
*   **Ý tưởng chính:** Khi một virtual thread thực thi mã sẽ bị chặn trên một hoạt động I/O (ví dụ: đọc từ một socket mạng), nó **không** chặn luồng HĐH bên dưới. Thay vào đó, JVM **tháo gỡ (unmounts)** virtual thread khỏi luồng HĐH của nó (luồng "carrier") và làm cho luồng HĐH có sẵn để chạy một virtual thread khác. Khi hoạt động I/O hoàn tất, JVM **gắn (mounts)** virtual thread trở lại một luồng carrier có sẵn để tiếp tục thực thi.

**Ví dụ tương tự:**
*   **Platform Threads:** Một đội xe tải giao hàng (các luồng HĐH). Mỗi xe tải chỉ có thể xử lý một lần giao hàng tại một thời điểm. Nếu một lần giao hàng yêu cầu chờ đợi tại một nhà kho, toàn bộ xe tải bị kẹt và không thể sử dụng cho các lần giao hàng khác.
*   **Virtual Threads:** Một đội ngũ lớn các tài xế giao hàng (virtual threads) và một đội xe tải nhỏ, được chia sẻ (các luồng HĐH "carrier"). Khi một tài xế đến một nhà kho để chờ một gói hàng, họ ra khỏi xe tải, và một tài xế khác ngay lập tức lấy xe tải đó để thực hiện một lần giao hàng khác. Tài xế đang chờ không giữ xe tải làm con tin. Khi gói hàng của họ sẵn sàng, họ được chỉ định xe tải có sẵn tiếp theo.

##### **Sự khác biệt: Platform vs. Virtual Threads**

| Tính năng | Platform Threads | Virtual Threads |
| :--- | :--- | :--- |
| **Ánh xạ** | Ánh xạ 1-1 với một luồng HĐH. | Ánh xạ nhiều-1 với một luồng HĐH. |
| **Trọng lượng** | Nặng nề (khan hiếm, dung lượng bộ nhớ cao). | Nhẹ (có thể có hàng triệu, dung lượng bộ nhớ rất thấp). |
| **Quản lý**| Được quản lý bởi Hệ điều hành. | Được quản lý bởi Java Virtual Machine (JVM). |
| **Chặn** | I/O chặn chặn luồng HĐH. | I/O chặn **không** chặn luồng HĐH (nó tháo gỡ). |
| **Tạo** | Tương đối chậm và tốn kém. | Cực kỳ nhanh và rẻ. |
| **Pooling** | **Pooling là cần thiết** để quản lý tài nguyên khan hiếm. | **Pooling là một anti-pattern.** Bạn nên tạo một virtual thread mới cho mỗi tác vụ. |

##### **Cách sử dụng Virtual Threads**
API được thiết kế để cực kỳ đơn giản và quen thuộc.
1.  **`Thread.startVirtualThread(Runnable)`:** Một factory method tĩnh để tạo và bắt đầu một virtual thread cho một tác vụ đã cho.
2.  **`Executors.newVirtualThreadPerTaskExecutor()`:** Cách được ưu tiên. Điều này tạo ra một `ExecutorService` tạo một virtual thread mới cho mỗi tác vụ được gửi. Nó không pool chúng.

**Tác động đến mã:** Lợi ích đáng kể nhất của virtual threads là chúng cho phép bạn viết mã I/O đồng bộ, chặn đơn giản (kiểu "một luồng cho mỗi yêu cầu") dễ đọc, viết và gỡ lỗi, nhưng có khả năng mở rộng như mã không đồng bộ phức tạp.

---

#### **2. Ví dụ mã nguồn**

Ví dụ này mô phỏng việc thực hiện hàng nghìn cuộc gọi mạng đồng thời, một tác vụ không thể thực hiện được với các platform thread nhưng lại tầm thường với các virtual thread.

```java
import java.time.Duration;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

public class VirtualThreadsDemo {
    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        // Cách hiện đại, được ưu tiên để sử dụng virtual threads.
        // Executor này tạo một virtual thread mới cho mỗi trong số 100.000 tác vụ.
        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {

            IntStream.range(0, 100_000).forEach(i -> {
                executor.submit(() -> {
                    // Mô phỏng một hoạt động I/O chặn (ví dụ: một cuộc gọi mạng)
                    try {
                        Thread.sleep(Duration.ofSeconds(1));
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                    // System.out.println("Task " + i + " completed.");
                });
            });

        } // Executor được tự động tắt và chờ các tác vụ hoàn thành.

        long endTime = System.currentTimeMillis();
        System.out.printf("Processed 100,000 tasks in %d ms\n", (endTime - startTime));
        // Điều này sẽ hoàn thành trong hơn 1 giây, không phải 100.000 giây,
        // vì tất cả các tác vụ chạy đồng thời mà không tiêu thụ hàng nghìn luồng HĐH.
    }
}
```

---

#### **3. Bài tập nhỏ**

Tái cấu trúc bài tập tải xuống URL từ Bài 5 để sử dụng virtual threads.
1.  Lấy `Callable` `UrlContentDownloader` từ bài tập trước.
2.  Thay vì sử dụng `Executors.newFixedThreadPool()`, hãy sử dụng `Executors.newVirtualThreadPerTaskExecutor()`.
3.  Tăng số lượng URL trong danh sách của bạn lên 1.000.
4.  Chạy chương trình và quan sát cách nó xử lý số lượng lớn các tác vụ chặn (mô phỏng) đồng thời này mà không có vấn đề gì. Lưu ý rằng bạn không cần quản lý kích thước pool; executor sẽ xử lý nó cho bạn.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Lợi ích đáng kể nhất của việc sử dụng virtual threads là gì?

A) Chúng làm cho các tính toán tốn nhiều CPU chạy nhanh hơn các platform thread.
B) Chúng cho phép bạn viết mã I/O chặn, đơn giản có khả năng mở rộng để xử lý một số lượng rất lớn các kết nối đồng thời.
C) Chúng hoàn toàn loại bỏ sự cần thiết của các nguyên thủy đồng bộ hóa như `synchronized` và `ReentrantLock`.
D) Chúng không tiêu thụ bộ nhớ, không giống như các platform thread có một ngăn xếp lớn.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Chúng cho phép bạn viết mã I/O chặn, đơn giản có khả năng mở rộng để xử lý một số lượng rất lớn các kết nối đồng thời. Virtual threads không làm cho mã tốn nhiều CPU nhanh hơn (đó là công việc của song song với Fork/Join framework). Chúng không loại bỏ sự cần thiết của đồng bộ hóa khi truy cập trạng thái có thể thay đổi được chia sẻ. Mặc dù chúng rất nhẹ, chúng vẫn tiêu thụ một lượng nhỏ bộ nhớ. Mục đích chính của chúng là cải thiện đáng kể khả năng mở rộng của các ứng dụng bị chi phối bởi các hoạt động I/O chặn.

### **Bài 10: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Bài học cuối cùng này cung cấp một bản tóm tắt toàn diện về các khái niệm chính trong đa luồng và đồng thời của Java, trình bày các câu hỏi phỏng vấn phổ biến để củng cố kiến thức của bạn, và đưa ra một dự án nhỏ thực tế để áp dụng các nguyên tắc này.

---

#### **1. Bảng tóm tắt các khái niệm chính**

| Khái niệm | Mô tả & Điểm chính |
| :--- | :--- |
| **Vòng đời luồng** | `NEW` → `RUNNABLE` ↔ `BLOCKED` / `WAITING` / `TIMED_WAITING` → `TERMINATED`. Hiểu rõ các trạng thái này là rất quan trọng để gỡ lỗi. |
| **Race Condition** | Một lỗi gây ra bởi thời gian không thể đoán trước của các luồng truy cập **trạng thái có thể thay đổi được chia sẻ**. Được giải quyết bằng đồng bộ hóa. |
| **`synchronized`** | Cung cấp **tính nguyên tử** và **tính hiển thị**. Sử dụng khóa nội tại của một object để loại trừ lẫn nhau. Tái nhập. |
| **`volatile`** | Cung cấp các đảm bảo về **tính hiển thị** và **thứ tự**, nhưng **không phải tính nguyên tử**. Sử dụng cho các cờ đơn giản, không phải các hoạt động phức hợp như `count++`. |
| **Mô hình bộ nhớ Java** | Định nghĩa mối quan hệ "xảy ra trước", đảm bảo khi nào các ghi bởi một luồng có thể được nhìn thấy bởi các luồng khác. `synchronized`, `volatile`, và `final` tạo ra các rào cản bộ nhớ. |
| **`wait`/`notifyAll`** | Cơ chế kinh điển để điều phối luồng. `wait()` giải phóng khóa và tạm dừng. `notifyAll()` đánh thức các luồng đang chờ. **Phải được sử dụng trong một khối `synchronized` và một vòng lặp `while`.** |
| **Executor Framework** | Tách rời việc gửi tác vụ khỏi việc thực thi. **Sử dụng thread pool thay vì `new Thread()`**. `ExecutorService` là interface chính. `Callable` trả về một kết quả thông qua một `Future`. |
| **Concurrent Collections**| `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`. Các collection hiệu suất cao, an toàn cho luồng từ `java.util.concurrent`. |
| **Locks Framework** | `ReentrantLock` là một sự thay thế linh hoạt hơn cho `synchronized`. `ReadWriteLock` cho phép nhiều người đọc đồng thời. **Phải sử dụng một khối `try-finally` cho `unlock()`**. |
| **Các biến nguyên tử** | `AtomicInteger`, `AtomicReference`, v.v. Cung cấp các hoạt động an toàn cho luồng, không cần khóa trên các biến đơn lẻ bằng cơ chế **Compare-And-Swap (CAS)**. |
| **Các tiện ích đồng thời**| **`CountDownLatch`**: Chờ cho N sự kiện hoàn thành. **`CyclicBarrier`**: Chờ cho N luồng đến một điểm chung. **`Semaphore`**: Hạn chế quyền truy cập vào một tài nguyên. |
| **Fork/Join Framework**| `ExecutorService` cho **song song**. Sử dụng một thuật toán **work-stealing** cho các tác vụ tốn nhiều CPU, "chia để trị". |
| **Virtual Threads** | Các luồng nhẹ, được quản lý bởi JVM. Lý tưởng cho các tác vụ I/O. Cho phép viết mã chặn, đơn giản có khả năng mở rộng đến hàng triệu hoạt động đồng thời mà không cần pooling. |
| **Deadlock** | Một tình huống trong đó hai hoặc nhiều luồng bị chặn mãi mãi, mỗi luồng chờ một khóa được giữ bởi luồng kia. Tránh bằng cách lấy các khóa theo một thứ tự toàn cục nhất quán. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Sự khác biệt giữa đồng thời và song song là gì?"**
    *   *Trả lời:* Đồng thời là việc *đối phó* với nhiều tác vụ cùng một lúc bằng cách xen kẽ việc thực thi, có thể được thực hiện trên một lõi CPU duy nhất. Song song là việc *thực hiện* nhiều tác vụ cùng một lúc, đòi hỏi nhiều lõi CPU. Song song là một dạng của đồng thời.

2.  **"Giải thích sự khác biệt giữa `synchronized` và `volatile`."**
    *   *Trả lời:* `synchronized` cung cấp cả loại trừ lẫn nhau (tính nguyên tử) và tính hiển thị bộ nhớ. Nó được sử dụng để bảo vệ các hành động phức hợp. `volatile` chỉ cung cấp các đảm bảo về tính hiển thị bộ nhớ và thứ tự; nó không cung cấp tính nguyên tử. Nó phù hợp cho các cờ hoặc biến đơn giản, nơi các ghi và đọc là nguyên tử tự thân.

3.  **"Tại sao `wait()` và `notify()` phải được gọi từ một khối `synchronized`?"**
    *   *Trả lời:* Chúng phải được gọi từ một khối `synchronized` để tránh các race condition. Một luồng phải sở hữu khóa monitor của object để đảm bảo rằng điều kiện mà nó sắp chờ đợi không thay đổi giữa thời điểm nó kiểm tra điều kiện và thời điểm nó đi vào trạng thái ngủ. Lời gọi `wait()` giải phóng khóa này một cách nguyên tử, ngăn chặn các bế tắc.

4.  **"Một `Future` là gì và nó được sử dụng như thế nào?"**
    *   *Trả lời:* Một `Future` là một trình giữ chỗ cho kết quả của một tính toán không đồng bộ. Khi bạn gửi một `Callable` đến một `ExecutorService`, bạn ngay lập tức nhận lại một `Future`. Mã của bạn có thể tiếp tục làm việc khác. Khi bạn cần kết quả, bạn gọi `future.get()`, nó sẽ chặn cho đến khi tính toán hoàn tất và kết quả có sẵn.

5.  **"Khi nào bạn nên sử dụng một platform thread so với một virtual thread?"**
    *   *Trả lời:* Sử dụng các platform thread cho một số lượng nhỏ các tác vụ tốn nhiều CPU, chạy dài, nơi bạn muốn có một ánh xạ một-một với một luồng HĐH (ví dụ: sử dụng một fixed thread pool có kích thước bằng số lượng lõi CPU). Sử dụng các virtual thread cho một số lượng lớn các tác vụ I/O hoặc chặn. Đối với các virtual thread, bạn không nên pool chúng; hãy tạo một cái mới cho mỗi tác vụ.

6.  **"Làm thế nào bạn có thể ngăn chặn một deadlock?"**
    *   *Trả lời:* Cách phổ biến nhất là thực thi một thứ tự toàn cục, nghiêm ngặt cho việc lấy khóa. Nếu tất cả các luồng luôn lấy khóa A trước khi lấy khóa B, một deadlock trong đó một luồng có A và chờ B, trong khi một luồng khác có B và chờ A, sẽ trở nên không thể. Các chiến lược khác bao gồm sử dụng `tryLock` với một thời gian chờ hoặc thiết kế hệ thống để tránh các khóa lồng nhau.

---

#### **3. Dự án nhỏ cuối cùng: Trình thu thập dữ liệu web đồng thời**

Dự án này sẽ kết hợp nhiều khái niệm mà chúng ta đã học—`ExecutorService`, `Future`, `ConcurrentHashMap`, và an toàn luồng—để xây dựng một trình thu thập dữ liệu web đơn giản có thể lấy nhiều trang đồng thời.

**🎯 Mục tiêu:** Tạo một chương trình bắt đầu từ một URL duy nhất, tìm tất cả các liên kết trên trang đó, và sau đó "thu thập" đồng thời các liên kết đó đến một độ sâu xác định.

**Yêu cầu dự án:**

1.  **Lớp `WebPageFetcher`:**
    *   Tạo một lớp trợ giúp đơn giản hoặc method `String fetch(String url)`.
    *   Method này sẽ mô phỏng việc lấy nội dung của một URL. Nó nên `Thread.sleep()` trong một khoảng thời gian ngẫu nhiên để mô phỏng một cuộc gọi mạng chặn.
    *   Đối với dự án này, nó có thể chỉ trả về một `String` giả chứa một vài liên kết giả. Ví dụ, nếu bạn lấy `"http://example.com"`, nó có thể trả về `"<html>...<a href='http://example.com/page1'>...<a href='http://example.com/page2'>...</html>"`.

2.  **Lớp `ConcurrentCrawler`:**
    *   **ExecutorService:** Trình thu thập dữ liệu nên sử dụng một `ExecutorService` để quản lý các tác vụ lấy dữ liệu. Vì đây là một tác vụ I/O, lựa chọn tốt cho executor là gì? Một **virtual thread executor (`Executors.newVirtualThreadPerTaskExecutor()`)** là lựa chọn hiện đại hoàn hảo. Một cached thread pool sẽ là lựa chọn truyền thống.
    *   **Các liên kết đã truy cập:** Trình thu thập dữ liệu cần theo dõi các URL mà nó đã truy cập để tránh bị kẹt trong các vòng lặp và xử lý lại cùng một trang. Cấu trúc dữ liệu nào là tốt nhất cho việc này? Một `Set` an toàn cho luồng, có thể được tạo từ một **`ConcurrentHashMap.newKeySet()`**.
    *   **Logic thu thập đệ quy:**
        *   Method chính nên là `crawl(String startUrl, int depth)`.
        *   Method này nên gửi URL ban đầu như một tác vụ đến executor.
        *   Bạn sẽ cần một method trợ giúp đệ quy đại diện cho tác vụ cho một URL duy nhất. Method này nên:
            1.  Kiểm tra xem URL đã được truy cập chưa hoặc nếu đã đạt đến độ sâu tối đa. Nếu vậy, hãy trả về.
            2.  Thêm URL vào tập hợp đã truy cập.
            3.  "Lấy" nội dung trang.
            4.  Phân tích cú pháp nội dung để tìm tất cả các liên kết.
            5.  Đối với mỗi liên kết mới được tìm thấy, hãy gửi đệ quy một tác vụ thu thập mới đến executor cho liên kết đó với `depth - 1`.

3.  **Lớp chính:**
    *   Method `main` nên tạo một instance của `ConcurrentCrawler`.
    *   Gọi method `crawl()` với một URL bắt đầu và một độ sâu (ví dụ: 2).
    *   Tắt `ExecutorService` một cách đúng đắn và chờ cho tất cả các tác vụ thu thập hoàn thành bằng cách sử dụng `awaitTermination()`.
    *   In một thông báo cuối cùng với tổng số trang duy nhất đã được truy cập.

Dự án này sẽ thách thức bạn quản lý các tác vụ không đồng bộ, xử lý trạng thái được chia sẻ (tập hợp `visited`) một cách an toàn cho luồng, và cấu trúc một thuật toán đệ quy, đồng thời.

