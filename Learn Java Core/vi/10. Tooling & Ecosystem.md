### **Bài 1: Công cụ xây dựng - Nguyên tắc cơ bản của Maven & Gradle**

#### **1. Giải thích khái niệm**

##### **Tại sao các công cụ xây dựng lại cần thiết?**
Khi một dự án chỉ có vài tệp, việc biên dịch bằng `javac` và chạy bằng `java` là có thể quản lý được. Tuy nhiên, các ứng dụng thực tế có hàng trăm tệp, hàng chục thư viện của bên thứ ba (phụ thuộc), các bước xây dựng phức tạp (như chạy kiểm thử, đóng gói, và triển khai), và cần được xây dựng một cách nhất quán trên các máy của nhà phát triển và các máy chủ khác nhau.

Các công cụ xây dựng tự động hóa toàn bộ quá trình này. Chúng xử lý:
*   **Quản lý phụ thuộc:** Tự động tải xuống và quản lý các thư viện của bên thứ ba (các tệp JAR) mà dự án của bạn cần.
*   **Cấu trúc dự án tiêu chuẩn hóa:** Thực thi một bố cục thư mục quy ước để các nhà phát triển có thể dễ dàng điều hướng bất kỳ dự án nào.
*   **Vòng đời xây dựng:** Định nghĩa một chuỗi các bước tiêu chuẩn (ví dụ: biên dịch, kiểm thử, đóng gói) để tạo ra sản phẩm cuối cùng của ứng dụng (như một tệp JAR hoặc WAR).
*   **Tính di động:** Đảm bảo rằng dự án có thể được xây dựng một cách đáng tin cậy ở bất cứ đâu bởi bất kỳ ai.

##### **Maven: Quy ước hơn là cấu hình**
Maven là một công cụ xây dựng khai báo tuân theo nguyên tắc "quy ước hơn là cấu hình". Nó có một quan điểm mạnh mẽ về cách một dự án nên được cấu trúc và xây dựng. Bạn khai báo *bạn muốn gì* trong một tệp XML (`pom.xml`), và vòng đời cứng nhắc, được xác định trước của Maven sẽ lo liệu *cách thực hiện*.

*   **Project Object Model (POM):** `pom.xml` là trái tim của một dự án Maven. Đó là một tệp XML mô tả dự án, các phụ thuộc, các plugin, và các cài đặt xây dựng của nó.
*   **Vòng đời xây dựng:** Maven có một chuỗi các giai đoạn cố định, chẳng hạn như `validate`, `compile`, `test`, `package`, `install`, và `deploy`. Khi bạn chạy một lệnh như `mvn package`, Maven thực thi tất cả các giai đoạn cho đến và bao gồm cả `package` theo thứ tự.
*   **Các phụ thuộc:** Các thư viện được xác định bởi các tọa độ của chúng (`groupId`, `artifactId`, `version`) và được tải xuống từ các kho lưu trữ (như Maven Central).

##### **Gradle: Linh hoạt và Hiệu suất**
Gradle là một công cụ xây dựng hiện đại hơn, cung cấp sự linh hoạt lớn hơn và thường có hiệu suất tốt hơn Maven. Nó sử dụng một Ngôn ngữ dành riêng cho miền (DSL) dựa trên Groovy hoặc Kotlin cho các kịch bản xây dựng của mình, có nghĩa là cấu hình xây dựng của bạn về cơ bản là mã.

*   **Các kịch bản xây dựng:** Tệp `build.gradle` (hoặc `build.gradle.kts` cho Kotlin) định nghĩa việc xây dựng của dự án. Bởi vì nó là mã, bạn có thể thêm logic tùy chỉnh, các vòng lặp, và các điều kiện, làm cho nó rất linh hoạt.
*   **Các tác vụ:** Mọi thứ trong Gradle đều là một "tác vụ" (ví dụ: `compileJava`, `test`, `build`). Các tác vụ có thể phụ thuộc vào các tác vụ khác, tạo ra một Đồ thị không tuần hoàn có hướng (DAG) của các phụ thuộc. Gradle thực thi một cách thông minh chỉ các tác vụ cần thiết.
*   **Hiệu suất:** Gradle có một cơ chế lưu vào bộ đệm mạnh mẽ và một hệ thống xây dựng gia tăng tránh việc chạy lại các tác vụ nếu đầu vào của chúng không thay đổi, thường làm cho nó nhanh hơn nhiều so với Maven đối với các dự án lớn.
*   **Gradle Wrapper (`gradlew`):** Đây là một kịch bản nhỏ được bao gồm trong một dự án, tự động tải xuống và sử dụng phiên bản Gradle chính xác được chỉ định cho dự án đó. Điều này đảm bảo tính nhất quán của việc xây dựng trên tất cả các môi trường mà không yêu cầu các nhà phát triển phải cài đặt Gradle thủ công.

| Tính năng | Maven | Gradle |
| :--- | :--- | :--- |
| **Cấu hình** | XML (`pom.xml`) - Khai báo, dài dòng | DSL Groovy/Kotlin (`build.gradle`) - Có thể lập trình, ngắn gọn |
| **Triết lý** | Quy ước hơn là cấu hình (Cứng nhắc) | Linh hoạt và "Mã như là cấu hình" (Có thể lập trình) |
| **Vòng đời** | Cố định, dựa trên giai đoạn (`compile`, `test`, `package`) | Dựa trên tác vụ (một đồ thị của các tác vụ phụ thuộc) |
| **Hiệu suất** | Có thể chậm hơn; chạy lại các giai đoạn | Nhanh hơn; hỗ trợ xây dựng gia tăng và lưu vào bộ đệm xuất sắc |
| **Linh hoạt** | Kém linh hoạt; logic tùy chỉnh đòi hỏi phải viết một plugin | Rất linh hoạt; logic tùy chỉnh có thể được viết trực tiếp trong kịch bản xây dựng |

---

#### **2. Ví dụ về cấu hình**

##### **Maven: `pom.xml`**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!-- Tọa độ dự án -->
    <groupId>com.example</groupId>
    <artifactId>my-app</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <!-- Các phụ thuộc thư viện -->
    <dependencies>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>5.9.1</version>
            <scope>test</scope> <!-- Phụ thuộc này chỉ dành cho việc kiểm thử -->
        </dependency>
    </dependencies>
</project>
```

##### **Gradle: `build.gradle` (Groovy DSL)**
```groovy
// Các plugin áp dụng hành vi được cấu hình sẵn (như hỗ trợ Java)
plugins {
    id 'java'
}

// Tọa độ dự án
group = 'com.example'
version = '1.0-SNAPSHOT'

// Cấu hình phiên bản Java
java {
    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

// Các kho lưu trữ để tải xuống các phụ thuộc từ đó
repositories {
    mavenCentral()
}

// Các phụ thuộc thư viện
dependencies {
    // 'testImplementation' là cấu hình cho các phụ thuộc kiểm thử
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.1'
}
```

---

#### **3. Bài tập nhỏ**

Tạo một dự án Java đơn giản sử dụng một thư viện ghi log bên ngoài.
1.  **Chọn công cụ của bạn (Maven hoặc Gradle).**
2.  Tạo cấu trúc thư mục tiêu chuẩn: `src/main/java/com/example/Main.java`.
3.  Trong tệp `pom.xml` hoặc `build.gradle` của bạn, hãy thêm một phụ thuộc cho **SLF4J API**.
    *   Maven: `<groupId>org.slf4j</groupId>`, `<artifactId>slf4j-api</artifactId>`, `<version>2.0.5</version>`
    *   Gradle: `implementation 'org.slf4j:slf4j-api:2.0.5'`
4.  Trong `Main.java`, hãy viết một ứng dụng "Hello World" đơn giản nhưng sử dụng logger của SLF4J để in thông điệp.
    ```java
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;

    public class Main {
        private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);
        public static void main(String[] args) {
            LOGGER.info("Hello, Build Tools!");
        }
    }
    ```
5.  Từ terminal của bạn, hãy chạy lệnh biên dịch cho công cụ bạn đã chọn (`mvn compile` hoặc `./gradlew compileJava`). Công cụ sẽ tải xuống thư viện SLF4J và biên dịch lớp của bạn thành công.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một `pom.xml` của Maven, mục đích chính của phần tử `<scope>test</scope>` trong một khai báo phụ thuộc là gì?

A) Nó yêu cầu Maven chạy các bài kiểm thử cho thư viện cụ thể đó.
B) Nó đảm bảo phụ thuộc chỉ có sẵn trên classpath trong các giai đoạn biên dịch và thực thi kiểm thử, và không được bao gồm trong ứng dụng được đóng gói cuối cùng (ví dụ: tệp JAR).
C) Nó chỉ định rằng phụ thuộc là tùy chọn và chỉ nên được tải xuống nếu các bài kiểm thử đang được chạy.
D) Nó cấu hình phụ thuộc để chỉ được sử dụng cho các bài kiểm thử tích hợp, không phải các bài kiểm thử đơn vị.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Nó đảm bảo phụ thuộc chỉ có sẵn trên classpath trong các giai đoạn biên dịch và thực thi kiểm thử, và không được bao gồm trong ứng dụng được đóng gói cuối cùng (ví dụ: tệp JAR). Điều này rất quan trọng để giữ cho sản phẩm sản xuất của bạn gọn gàng và không có các thư viện chỉ dành cho kiểm thử như JUnit hoặc Mockito.

### **Bài 2: Các Framework kiểm thử (JUnit & Mockito)**

#### **1. Giải thích khái niệm**

##### **Tầm quan trọng của Kiểm thử tự động**
Kiểm thử tự động là thực hành viết mã để kiểm tra mã ứng dụng của bạn. Nó là một nền tảng của phát triển phần mềm hiện đại vì một số lý do:
*   **Lưới an toàn cho việc Tái cấu trúc:** Một bộ kiểm thử toàn diện cho bạn sự tự tin để tái cấu trúc và cải thiện mã của mình, biết rằng nếu bạn làm hỏng thứ gì đó, một bài kiểm thử sẽ thất bại.
*   **Tài liệu sống:** Các bài kiểm thử được viết tốt mô tả cách một đoạn mã được dự định sẽ được sử dụng.
*   **Ngăn ngừa lỗi:** Nó giúp phát hiện lỗi sớm trong chu kỳ phát triển, khi chúng rẻ nhất để sửa chữa.
*   **Cho phép CI/CD:** Các bài kiểm thử tự động là một điều kiện tiên quyết cho Tích hợp liên tục (Continuous Integration), nơi các thay đổi mã được tự động xây dựng và kiểm thử.

##### **JUnit 5: Tiêu chuẩn cho Kiểm thử đơn vị**
JUnit là framework kiểm thử tiêu chuẩn trên thực tế cho Java. Một **kiểm thử đơn vị (unit test)** là một bài kiểm thử xác minh hành vi của một đoạn mã nhỏ, biệt lập (một "đơn vị", thường là một method hoặc một lớp duy nhất) trong sự cô lập khỏi các phụ thuộc của nó.

**Các Annotation chính của JUnit 5:**
*   `@Test`: Đánh dấu một method là một method kiểm thử.
*   `@BeforeEach` / `@AfterEach`: Đánh dấu một method sẽ được chạy **trước** hoặc **sau** *mỗi* method `@Test` trong lớp. Được sử dụng để thiết lập và dọn dẹp trạng thái cho các bài kiểm thử riêng lẻ.
*   `@BeforeAll` / `@AfterAll`: Đánh dấu một method `static` sẽ được chạy **một lần** **trước** hoặc **sau** *tất cả* các bài kiểm thử trong lớp. Được sử dụng cho việc thiết lập tốn kém, được chia sẻ (như bắt đầu một kết nối cơ sở dữ liệu).
*   `@DisplayName`: Cung cấp một tên tùy chỉnh, có thể đọc được bởi con người cho một lớp hoặc method kiểm thử.
*   `@Disabled`: Vô hiệu hóa một method hoặc lớp kiểm thử.

**Các Assertion:**
Assertion là các method tĩnh (chủ yếu từ `org.junit.jupiter.api.Assertions`) kiểm tra xem một điều kiện có đúng không. Nếu một assertion thất bại, bài kiểm thử sẽ thất bại.
*   `assertEquals(expected, actual)`: Kiểm tra xem hai giá trị có bằng nhau không.
*   `assertTrue(condition)` / `assertFalse(condition)`: Kiểm tra một điều kiện boolean.
*   `assertNotNull(object)`: Kiểm tra xem một object có phải là null không.
*   `assertThrows(ExpectedException.class, () -> { ... })`: Khẳng định rằng khối mã được cung cấp ném ra một ngoại lệ cụ thể.

##### **Vấn đề của các phụ thuộc: Sự cần thiết của các Mock**
Kiểm thử đơn vị đòi hỏi phải kiểm thử một lớp trong **sự cô lập**. Nhưng nếu lớp `OrderService` của bạn phụ thuộc vào một `PaymentGateway` để xử lý thanh toán thì sao? Bạn không muốn bài kiểm thử đơn vị của mình thực hiện một cuộc gọi mạng thực sự đến một nhà cung cấp thanh toán.

Đây là lúc **mocking** xuất hiện. Một **mock object** là một triển khai "giả" hoặc "dummy" của một lớp hoặc interface mà bạn kiểm soát hoàn toàn từ bài kiểm thử của mình. Bạn có thể yêu cầu nó làm gì và trả về cái gì khi các method của nó được gọi.

##### **Mockito: Framework Mocking hàng đầu**
Mockito là framework mocking phổ biến nhất cho Java. Nó cho phép bạn tạo và cấu hình các mock object với một API sạch sẽ, trôi chảy.

**Các khái niệm cốt lõi của Mockito:**
1.  **Mocking:** Tạo một mock object.
    `PaymentGateway mockGateway = Mockito.mock(PaymentGateway.class);`
2.  **Stubbing:** Định nghĩa hành vi của các method của một mock. "Khi method này được gọi, thì trả về giá trị này."
    `when(mockGateway.charge(100.0)).thenReturn(new PaymentResponse(true));`
3.  **Verifying:** Kiểm tra xem một method trên mock có thực sự được gọi với các đối số mong đợi hay không.
    `verify(mockGateway).charge(100.0);`

**Các Annotation của Mockito (để có các bài kiểm thử sạch hơn):**
*   `@Mock`: Tạo một mock object cho trường được chú thích.
*   `@InjectMocks`: Tạo một instance của lớp đang được kiểm thử và tự động tiêm các trường được chú thích bằng `@Mock` vào nó.
*   `@Spy`: Tạo một "spy" trên một object thực. Một spy gọi các method thực của object theo mặc định, nhưng bạn vẫn có thể stub các method cụ thể nếu cần.

---

#### **2. Ví dụ mã nguồn: Kiểm thử một Service với các Mock**

##### **Mã cần được kiểm thử**
```java
// Interface phụ thuộc
interface UserRepository {
    Optional<String> findUsernameById(int id);
}

// Lớp đang được kiểm thử
class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // Logic nghiệp vụ: Chào người dùng, hoặc trả về một lời chào mặc định.
    public String getGreetingForUser(int id) {
        return userRepository.findUsernameById(id)
                             .map(name -> "Hello, " + name)
                             .orElse("Hello, Guest");
    }
}
```

##### **Bài kiểm thử JUnit 5 và Mockito**
```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.Optional;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

// Sử dụng extension của Mockito để bật các annotation như @Mock
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    // 1. Tạo một mock cho phụ thuộc
    @Mock
    private UserRepository mockUserRepository;

    // 2. Tạo một instance của lớp đang được kiểm thử và tiêm các mock vào
    @InjectMocks
    private UserService userService;

    @Test
    @DisplayName("Nên trả về một lời chào với tên người dùng khi người dùng được tìm thấy")
    void getGreetingForUser_whenUserFound() {
        // --- Sắp xếp (Stubbing) ---
        // "Khi findUsernameById với 101 được gọi, thì trả về một Optional của 'Alice'"
        when(mockUserRepository.findUsernameById(101)).thenReturn(Optional.of("Alice"));

        // --- Hành động ---
        String greeting = userService.getGreetingForUser(101);

        // --- Khẳng định ---
        assertEquals("Hello, Alice", greeting);
    }

    @Test
    @DisplayName("Nên trả về một lời chào khách khi người dùng không được tìm thấy")
    void getGreetingForUser_whenUserNotFound() {
        // --- Sắp xếp (Stubbing) ---
        // "Khi findUsernameById với 999 được gọi, thì trả về một Optional rỗng"
        when(mockUserRepository.findUsernameById(999)).thenReturn(Optional.empty());

        // --- Hành động ---
        String greeting = userService.getGreetingForUser(999);

        // --- Khẳng định ---
        assertEquals("Hello, Guest", greeting);
    }
}
```

---

#### **3. Bài tập nhỏ**
Bạn được giao một lớp `DiscountService` tính toán một khoản chiết khấu dựa trên trạng thái của khách hàng.
```java
public interface CustomerRepository {
    String getStatus(String customerId); // Trả về "GOLD", "SILVER", hoặc "BRONZE"
}

public class DiscountService {
    private final CustomerRepository customerRepository;
    // constructor...

    public double getDiscount(String customerId) {
        String status = customerRepository.getStatus(customerId);
        switch (status) {
            case "GOLD": return 0.20; // 20%
            case "SILVER": return 0.10; // 10%
            default: return 0.0;
        }
    }
}
```
Nhiệm vụ của bạn là viết một bài kiểm thử JUnit 5 cho method `getDiscount`.
1.  Sử dụng Mockito để tạo một mock của `CustomerRepository`.
2.  Viết một trường hợp kiểm thử cho một khách hàng "GOLD".
3.  **Sắp xếp:** Stub method `getStatus` trên mock của bạn để khi nó được gọi với một ID khách hàng cụ thể, nó sẽ trả về "GOLD".
4.  **Hành động:** Gọi method `getDiscount`.
5.  **Khẳng định:** Sử dụng `assertEquals` để xác minh rằng khoản chiết khấu được trả về là `0.20`.
6.  (Tùy chọn) Viết một trường hợp kiểm thử khác cho một khách hàng "BRONZE".

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một lớp kiểm thử JUnit 5, mục đích của một method được chú thích bằng `@BeforeEach` là gì?

A) Nó được chạy một lần trước tất cả các method kiểm thử trong lớp để thực hiện việc thiết lập tốn kém.
B) Nó được chạy sau mỗi method kiểm thử để dọn dẹp tài nguyên.
C) Nó được chạy trước mỗi method kiểm thử riêng lẻ để thiết lập một trạng thái sạch sẽ, nhất quán cho mọi bài kiểm thử.
D) Nó đánh dấu chính method đó là một trường hợp kiểm thử.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Nó được chạy trước mỗi method kiểm thử riêng lẻ để thiết lập một trạng thái sạch sẽ, nhất quán cho mọi bài kiểm thử. Điều này đảm bảo rằng các bài kiểm thử là độc lập và không can thiệp lẫn nhau. `@BeforeAll` được sử dụng cho việc thiết lập "chạy một lần".

### **Bài 3: Các Framework ghi log (SLF4J & Logback)**

#### **1. Giải thích khái niệm**

##### **Tại sao ghi log lại cần thiết (so với `System.out.println`)**
Sử dụng `System.out.println()` để gỡ lỗi là ổn cho các kịch bản nhỏ, tạm thời. Trong bất kỳ ứng dụng thực tế nào, đó là một thực hành tồi tệ vì một số lý do:
*   **Không có kiểm soát:** Bạn không thể bật hoặc tắt nó. Nó luôn bật.
*   **Không có độ chi tiết:** Mọi thông điệp đều được đối xử như nhau. Bạn không thể phân biệt giữa một lỗi nghiêm trọng và một thông điệp thông tin đơn giản.
*   **Không có ngữ cảnh:** Nó không cung cấp thông tin về thời điểm thông điệp được ghi lại, nó đến từ lớp nào, hoặc luồng nào đang chạy.
*   **Đích đến không linh hoạt:** Nó luôn in ra console tiêu chuẩn. Bạn không thể dễ dàng chuyển hướng nó đến một tệp, một cơ sở dữ liệu, hoặc một máy chủ ghi log tập trung.

Một **framework ghi log** giải quyết tất cả các vấn đề này bằng cách cung cấp một hệ thống mạnh mẽ, có thể cấu hình, và hiệu suất cao để ghi lại các sự kiện của ứng dụng.

##### **Facade ghi log vs. Triển khai ghi log**
Hệ sinh thái ghi log của Java có một mẫu thiết kế quan trọng: sự tách biệt của **API (facade)** khỏi **triển khai (implementation)**.

*   **Facade (Cái "Gì"):** Đây là một tập hợp các interface mà mã ứng dụng của bạn sử dụng để viết các thông điệp log. Đó là một lớp trừu tượng. Facade phổ biến nhất là **SLF4J (Simple Logging Facade for Java)**.
*   **Triển khai (Cái "Làm thế nào"):** Đây là động cơ ghi log thực tế nhận các thông điệp từ facade và ghi chúng đến một đích (console, tệp, v.v.). Các triển khai phổ biến bao gồm **Logback** và **Log4j2**.

**Ví dụ tương tự:** SLF4J giống như interface `Connection` của JDBC. Mã của bạn chỉ tương tác với API `Connection` tiêu chuẩn. Công việc thực tế được thực hiện bởi *driver* JDBC (triển khai), có thể là cho PostgreSQL, MySQL, hoặc Oracle. Bạn có thể chuyển đổi driver mà không cần thay đổi mã ứng dụng của mình.

**Tại sao lại sử dụng sự tách biệt này?**
Bằng cách lập trình ứng dụng của bạn dựa trên facade SLF4J, bạn không bị ràng buộc vào một triển khai ghi log cụ thể. Bạn có thể chuyển từ Logback sang Log4j2 (hoặc bất kỳ logger nào tương thích với SLF4J khác) trong tương lai chỉ bằng cách thay đổi một phụ thuộc trong tệp xây dựng của bạn, mà không cần thay đổi một dòng mã ứng dụng nào.

##### **SLF4J và Logback**
*   **SLF4J:** API ghi log. Bạn lấy một instance `Logger` và gọi các method trên nó.
*   **Logback:** Một triển khai ghi log hiệu suất cao được tạo ra bởi cùng một nhà phát triển của SLF4J. Nó là triển khai bản địa cho API SLF4J và là một lựa chọn rất phổ biến.

##### **Các cấp độ log**
Các cấp độ log cung cấp độ chi tiết. Chúng cho phép bạn kiểm soát mức độ chi tiết đang được ghi lại. Các cấp độ tiêu chuẩn, theo thứ tự tăng dần của mức độ nghiêm trọng, là:
*   `TRACE`: Thông tin chi tiết nhất, để gỡ lỗi chi tiết.
*   `DEBUG`: Thông tin hữu ích cho các nhà phát triển để gỡ lỗi ứng dụng.
*   `INFO`: Các thông điệp cấp cao làm nổi bật tiến trình của ứng dụng.
*   `WARN`: Các tình huống có khả năng gây hại hoặc các cảnh báo không phải là lỗi nghiêm trọng.
*   `ERROR`: Các sự kiện lỗi vẫn có thể cho phép ứng dụng tiếp tục chạy.

Bạn cấu hình một cấp độ log cho ứng dụng của mình (ví dụ: `INFO`). Chỉ các thông điệp được ghi ở cấp độ đó hoặc một mức độ nghiêm trọng cao hơn mới được in. (ví dụ: nếu cấp độ là `INFO`, thì các thông điệp `INFO`, `WARN`, và `ERROR` sẽ được hiển thị, nhưng `DEBUG` và `TRACE` sẽ bị ẩn).

##### **Ghi log có tham số**
Một tính năng chính của SLF4J là việc sử dụng các thông điệp có tham số.
```java
// Tệ: Việc nối chuỗi xảy ra ngay cả khi DEBUG bị tắt.
logger.debug("Processing user: " + user.getId());

// Tốt: Chuỗi chỉ được xây dựng nếu cấp độ DEBUG được bật.
logger.debug("Processing user: {}", user.getId());```Điều này là một sự tối ưu hóa hiệu suất đáng kể, vì nó tránh được việc nối chuỗi tốn kém cho các thông điệp log sẽ không được in.

---

#### **2. Ví dụ về cấu hình**

##### **1. Các phụ thuộc Maven (`pom.xml`)**
Để sử dụng SLF4J với Logback, bạn cần hai phụ thuộc: facade và triển khai.
```xml
<dependencies>
    <!-- SLF4J API (Facade) -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>2.0.5</version>
    </dependency>

    <!-- Triển khai Logback -->
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.4.5</version>
        <scope>runtime</scope> <!-- Triển khai là cần thiết tại thời gian chạy, không phải thời gian biên dịch -->
    </dependency>
</dependencies>
```

##### **2. Cấu hình Logback (`src/main/resources/logback.xml`)**
Logback được cấu hình thông qua một tệp XML được đặt trong thư mục `src/main/resources`.

```xml
<configuration>

    <!-- 1. Định nghĩa một Appender (ghi log vào đâu) -->
    <!-- Appender này ghi log vào console -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!-- Định nghĩa mẫu của thông điệp log -->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 2. Cấu hình các Logger (ghi log cái gì và ở cấp độ nào) -->
    
    <!-- Cấu hình cấp độ ghi log cho một package cụ thể -->
    <!-- Ở đây, mã ứng dụng của chúng ta sẽ ghi log ở cấp độ DEBUG -->
    <logger name="com.example" level="DEBUG"/>

    <!-- Root Logger là mặc định cho tất cả các lớp khác -->
    <!-- Ở đây, tất cả các thư viện (như Spring, Hibernate) sẽ ghi log ở cấp độ INFO -->
    <root level="INFO">
        <appender-ref ref="STDOUT" />
    </root>

</configuration>
```

##### **3. Mã Java (`com/example/MyApplication.java`)**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyApplication {
    // Lấy một instance logger cho lớp cụ thể này
    private static final Logger logger = LoggerFactory.getLogger(MyApplication.class);

    public void performTask(String userId) {
        logger.debug("Starting task for user: {}", userId); // Sẽ hiển thị

        try {
            // Mô phỏng một số công việc
            if (userId == null) {
                throw new IllegalArgumentException("User ID cannot be null");
            }
            logger.info("Task for user {} completed successfully.", userId); // Sẽ hiển thị
        } catch (Exception e) {
            logger.error("Task failed for user: {}", userId, e); // Sẽ hiển thị (lưu ý ngoại lệ được truyền làm đối số cuối cùng)
        }
    }
}
```

---

#### **3. Bài tập nhỏ**

Nâng cao cấu hình `logback.xml` từ ví dụ trên.
1.  Thêm một appender mới có tên `"FILE"` ghi log vào một tệp. Lớp cho việc này là `ch.qos.logback.core.FileAppender`.
2.  Cấu hình nó để ghi vào một tệp có tên `my-app.log`.
3.  Thêm cùng một khối `<encoder>` vào file appender.
4.  Sửa đổi logger `<root>` để gửi các thông điệp log đến **cả** console và tệp bằng cách thêm một `<appender-ref>` thứ hai.
5.  Chạy ứng dụng của bạn và xác minh rằng các thông điệp log xuất hiện ở cả console và tệp `my-app.log`.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một câu lệnh ghi log của SLF4J như `logger.debug("Found {} records for user {}", count, userId);`, lợi ích hiệu suất chính của việc sử dụng các trình giữ chỗ `{}` là gì?

A) Nó làm cho các thông điệp log dễ đọc hơn trong mã.
B) Nó cho phép các thông điệp log được dịch sang các ngôn ngữ khác nhau.
C) Nó tránh được chi phí của việc nối chuỗi và các cuộc gọi `toString()` trên các đối số nếu cấp độ log `DEBUG` bị tắt.
D) Nó tự động mã hóa các đối số trước khi ghi log chúng.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Nó tránh được chi phí của việc nối chuỗi và các cuộc gọi `toString()` trên các đối số nếu cấp độ log `DEBUG` bị tắt. Method `debug` trước tiên kiểm tra xem cấp độ `DEBUG` có được bật không. Chỉ khi được bật, nó mới tiến hành định dạng thông điệp log cuối cùng bằng cách thay thế các trình giữ chỗ. "Thực thi trì hoãn" này là một tính năng hiệu suất chính.

### **Bài 4: Quản lý phụ thuộc**

#### **1. Giải thích khái niệm**

##### **Phụ thuộc là gì?**
Một phụ thuộc là một thư viện của bên thứ ba bên ngoài (thường là một tệp JAR) mà dự án của bạn cần để hoạt động. Gần như tất cả các ứng dụng hiện đại đều được xây dựng trên nhiều thư viện mã nguồn mở (ví dụ: Spring Framework cho các ứng dụng web, JUnit để kiểm thử, Jackson để xử lý JSON). Việc tải xuống, quản lý và cập nhật thủ công các tệp JAR này và các phụ thuộc của chính chúng sẽ là một nhiệm vụ bất khả thi.

##### **Các phụ thuộc bắc cầu**
Sự phức tạp bùng nổ vì các phụ thuộc của bạn có các phụ thuộc của riêng chúng. Điều này được gọi là **phụ thuộc bắc cầu (transitive dependency)**.
*   Ứng dụng của bạn **→** Thư viện A
*   Thư viện A **→** Thư viện B
*   Thư viện B **→** Thư viện C

Trong chuỗi này, ứng dụng của bạn bây giờ ngầm phụ thuộc vào Thư viện B và C. Một công cụ xây dựng như Maven hoặc Gradle tự động quản lý toàn bộ cây phụ thuộc này, không chỉ tải xuống các phụ thuộc trực tiếp của bạn mà còn tất cả các phụ thuộc bắc cầu.

**Sơ đồ của một Cây phụ thuộc:**
```
your-app:1.0
+--- spring-boot-starter-web:2.7.5
|    +--- spring-boot-starter-json:2.7.5
|    |    +--- jackson-databind:2.13.4  <-- Phụ thuộc bắc cầu
|    |    \--- jackson-datatype-jsr310:2.13.4
|    \--- spring-boot-starter-tomcat:2.7.5
\--- junit-jupiter-api:5.9.1
```

##### **Vấn đề xung đột phụ thuộc "Kim cương"**
Một vấn đề phổ biến và khó khăn trong quản lý phụ thuộc phát sinh khi dự án của bạn phụ thuộc vào hai thư viện khác nhau, mà đến lượt chúng, lại phụ thuộc vào các phiên bản khác nhau, không tương thích của một thư viện thứ ba.

*   Ứng dụng của bạn **→** Thư viện A **→** Thư viện C (phiên bản 1.0)
*   Ứng dụng của bạn **→** Thư viện B **→** Thư viện C (phiên bản 2.0)

Phiên bản nào của Thư viện C nên được sử dụng trên classpath của dự án của bạn? Đây là xung đột "kim cương". Các công cụ xây dựng có các chiến lược để giải quyết vấn đề này:

*   **Chiến lược của Maven:** "Cái gần nhất thắng." Maven duyệt qua cây phụ thuộc và chọn phiên bản của thư viện xung đột gần nhất với dự án của bạn. Trong ví dụ trên, cả hai đều ở cùng một độ sâu, vì vậy cái được khai báo đầu tiên trong `pom.xml` của bạn có khả năng sẽ thắng.
*   **Chiến lược của Gradle:** "Phiên bản cao nhất thắng." Theo mặc định, Gradle sẽ chọn phiên bản mới nhất của thư viện xung đột (phiên bản 2.0 trong trường hợp này), giả sử nó tương thích ngược.

##### **Các phạm vi phụ thuộc**
Không phải tất cả các phụ thuộc đều cần thiết cho tất cả các giai đoạn của việc xây dựng. Các phạm vi phụ thuộc cho phép bạn kiểm soát khi nào một phụ thuộc được bao gồm trên classpath.

Các phạm vi phổ biến nhất (tên thay đổi một chút giữa Maven và Gradle) là:
*   **`compile` (Maven) / `implementation` (Gradle):**
    *   Đây là phạm vi mặc định. Phụ thuộc có sẵn ở mọi nơi: để biên dịch mã của bạn, để chạy các bài kiểm thử, và nó được bao gồm trong ứng dụng được đóng gói cuối cùng.
*   **`test` (Maven) / `testImplementation` (Gradle):**
    *   Phụ thuộc chỉ có sẵn để biên dịch và chạy các bài kiểm thử của bạn. Nó **không** được bao gồm trong ứng dụng được đóng gói cuối cùng. Điều này được sử dụng cho các thư viện như JUnit và Mockito.
*   **`runtime` (Maven) / `runtimeOnly` (Gradle):**
    *   Phụ thuộc không cần thiết để biên dịch nhưng được yêu cầu tại thời gian chạy. Một ví dụ kinh điển là một trình điều khiển JDBC. Mã của bạn biên dịch dựa trên API JDBC tiêu chuẩn, nhưng tại thời gian chạy, bạn cần triển khai trình điều khiển cụ thể cho cơ sở dữ liệu của mình.
*   **`provided` (Maven) / `compileOnly` (Gradle):**
    *   Phụ thuộc là cần thiết để biên dịch, nhưng bạn giả định rằng nó sẽ được "cung cấp" bởi môi trường thời gian chạy và không nên được đóng gói trong ứng dụng của bạn. Ví dụ kinh điển là Servlet API khi xây dựng một tệp WAR để triển khai trên một máy chủ Tomcat. Tomcat tự cung cấp các tệp JAR của Servlet API.

##### **Thực hành tốt nhất và Semantic Versioning (SemVer)**
*   **Semantic Versioning:** Một lược đồ phiên bản được chấp nhận rộng rãi: **`MAJOR.MINOR.PATCH`** (ví dụ: `2.7.5`).
    *   **`PATCH`:** Một bản sửa lỗi tương thích ngược. Bạn gần như luôn có thể cập nhật cái này một cách an toàn.
    *   **`MINOR`:** Một tính năng mới tương thích ngược. Thường an toàn để cập nhật.
    *   **`MAJOR`:** Một thay đổi **không** tương thích ngược (một thay đổi phá vỡ). Việc cập nhật cái này đòi hỏi phải xem xét và kiểm tra mã cẩn thận.
*   **Quản lý xung đột:** Khi một xung đột phát sinh, bạn có các công cụ để giải quyết nó:
    *   **Cây phụ thuộc:** Sử dụng `mvn dependency:tree` hoặc `./gradlew dependencies` để hình dung toàn bộ đồ thị phụ thuộc và tìm ra thư viện xung đột đến từ đâu.
    *   **Loại trừ:** Bạn có thể loại trừ một phụ thuộc bắc cầu một cách tường minh.
    *   **Quản lý phụ thuộc:** Trong Maven, phần `<dependencyManagement>` cho phép bạn tập trung và thực thi các phiên bản cụ thể cho các thư viện trên một dự án đa mô-đun.

---

#### **2. Ví dụ về cấu hình**

##### **Maven: Quản lý một xung đột với một loại trừ**
Hãy tưởng tượng `spring-boot-starter` mang đến một phiên bản cũ của `log4j`, nhưng bạn muốn sử dụng một phiên bản mới hơn.

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
        <version>2.7.5</version>
        <!-- Loại trừ phụ thuộc bắc cầu cũ, không mong muốn -->
        <exclusions>
            <exclusion>
                <groupId>org.apache.logging.log4j</groupId>
                <artifactId>log4j-api</artifactId>
            </exclusion>
        </exclusions>
    </dependency>

    <!-- Bây giờ, hãy khai báo tường minh phiên bản bạn muốn sử dụng -->
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-api</artifactId>
        <version>2.19.0</version>
    </dependency>
</dependencies>
```

##### **Gradle: Ép buộc một phiên bản cụ thể**
Gradle làm cho việc ép buộc một phiên bản cụ thể cho một phụ thuộc bắc cầu trở nên dễ dàng.

```groovy
dependencies {
    implementation('org.springframework.boot:spring-boot-starter:2.7.5') {
        // Bạn có thể loại trừ như trong Maven
        exclude group: 'org.apache.logging.log4j', module: 'log4j-api'
    }
    implementation 'org.apache.logging.log4j:log4j-api:2.19.0'

    // Hoặc, bạn có thể ép buộc một phiên bản cho tất cả các phụ thuộc bắc cầu
    // Đây là một cách mạnh mẽ để giải quyết các xung đột.
    constraints {
        implementation('org.apache.logging.log4j:log4j-api:2.19.0') {
            because 'chúng ta cần thực thi bản vá bảo mật mới nhất'
        }
    }
}
```

---

#### **3. Bài tập nhỏ**
1.  Tạo một dự án Maven mới.
2.  Thêm một phụ thuộc vào `org.springframework:spring-core:5.3.23`.
3.  Chạy lệnh `mvn dependency:tree` từ terminal của bạn trong thư mục gốc của dự án.
4.  Kiểm tra đầu ra. Bạn sẽ thấy rằng `spring-core` mang đến một phụ thuộc bắc cầu có tên `spring-jcl`.
5.  Bây giờ, hãy sửa đổi `pom.xml` của bạn để loại trừ `spring-jcl` khỏi phụ thuộc `spring-core`.
6.  Chạy lại `mvn dependency:tree` và xác minh rằng `spring-jcl` không còn là một phần của đồ thị phụ thuộc của dự án của bạn.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang xây dựng một ứng dụng web dưới dạng một tệp WAR để triển khai trên một máy chủ Tomcat bên ngoài. Bạn cần Servlet API để biên dịch mã của mình, nhưng bạn không muốn bao gồm tệp JAR của Servlet API trong tệp WAR cuối cùng của mình vì Tomcat đã cung cấp nó. Bạn nên sử dụng phạm vi phụ thuộc nào cho phụ thuộc Servlet API?

A) `compile`
B) `runtime`
C) `test`
D) `provided`

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** D) `provided`. Phạm vi `provided` (hoặc `compileOnly` trong Gradle) yêu cầu công cụ xây dựng rằng phụ thuộc là cần thiết để biên dịch nhưng sẽ được cung cấp bởi môi trường thời gian chạy (máy chủ Tomcat, trong trường hợp này), vì vậy nó không nên được đóng gói vào sản phẩm cuối cùng.

### **Bài 5: Các công cụ tài liệu & chất lượng mã**

#### **1. Giải thích khái niệm**

Việc viết mã hoạt động chỉ là bước đầu tiên. Phát triển phần mềm chuyên nghiệp đòi hỏi phải viết mã **dễ đọc, dễ bảo trì, và nhất quán**. Hệ sinh thái Java cung cấp các công cụ mạnh mẽ để ghi lại tài liệu mã của bạn và tự động thực thi các tiêu chuẩn chất lượng.

##### **JavaDoc: Ghi lại tài liệu API của bạn**
JavaDoc là trình tạo tài liệu chính thức cho Java. Nó phân tích cú pháp các chú thích được định dạng đặc biệt trong mã nguồn của bạn để tạo ra một tập hợp các tệp HTML mô tả API của bạn. Tài liệu được viết tốt là điều cần thiết cho bất kỳ ai sẽ sử dụng các lớp hoặc thư viện của bạn.

**Cú pháp chú thích JavaDoc:**
Một chú thích JavaDoc bắt đầu bằng `/**` và kết thúc bằng `*/`. Nó sử dụng các thẻ đặc biệt có tiền tố `@` để mô tả các khía cạnh khác nhau của mã.

**Các thẻ JavaDoc chính:**
*   `@param <name> <description>`: Mô tả một tham số của method.
*   `@return <description>`: Mô tả giá trị trả về của một method.
*   `@throws <exception_type> <description>`: Mô tả một ngoại lệ mà method có thể ném ra.
*   `@see <reference>`: Cung cấp một liên kết "Xem thêm" đến một lớp hoặc method khác.
*   `@since <version>`: Chỉ ra phiên bản của phần mềm mà trong đó tính năng này đã được giới thiệu.
*   `@deprecated <description>`: Đánh dấu một method hoặc lớp là không dùng nữa, cảnh báo người dùng không nên sử dụng nó và đề xuất một giải pháp thay thế.

**Tạo JavaDoc:**
Cả Maven và Gradle đều có các plugin để tự động tạo các tệp HTML JavaDoc như một phần của quá trình xây dựng.
*   **Maven:** `mvn javadoc:javadoc`
*   **Gradle:** `./gradlew javadoc`

##### **Phân tích tĩnh: Người đánh giá mã tự động**
Các công cụ phân tích tĩnh là các chương trình đọc mã nguồn của bạn (mà không thực thi nó) và tìm kiếm các lỗi tiềm ẩn, các thực hành tồi, và các lỗi về phong cách. Việc tích hợp chúng vào quá trình xây dựng của bạn giống như có một người đánh giá mã tự động kiểm tra mọi thay đổi.

**"Bộ ba lớn" của các công cụ phân tích tĩnh cho Java:**
1.  **Checkstyle:**
    *   **Tập trung:** Thực thi **phong cách và quy ước** viết mã.
    *   **Nó kiểm tra gì:** Quy ước đặt tên, thứ tự import, việc sử dụng khoảng trắng đúng cách, kiểu dấu ngoặc nhọn, độ dài dòng, v.v. Nó đảm bảo rằng toàn bộ cơ sở mã có một giao diện và cảm giác nhất quán. Nó có thể cấu hình cao.
2.  **PMD (Programming Mistake Detector):**
    *   **Tập trung:** Tìm các **lỗi lập trình phổ biến và các thực hành tồi**.
    *   **Nó kiểm tra gì:** Các biến không sử dụng, các khối catch trống, việc tạo đối tượng không cần thiết, các method quá phức tạp, mã không tối ưu. Nó giúp bạn viết mã hiệu quả và mạnh mẽ hơn.
3.  **SpotBugs (trước đây là FindBugs):**
    *   **Tập trung:** Tìm các **lỗi** tiềm ẩn bằng cách phân tích bytecode đã được biên dịch.
    *   **Nó kiểm tra gì:** Bởi vì nó phân tích bytecode, nó có thể tìm thấy các lỗi tinh vi hơn mà việc phân tích mã nguồn có thể bỏ sót. Các ví dụ bao gồm các tham chiếu con trỏ null, rò rỉ tài nguyên (các stream không được đóng), và việc sử dụng `equals()` không chính xác.

##### **SonarQube và SonarLint**
*   **SonarLint:** Một plugin IDE cung cấp phản hồi ngay lập tức, làm nổi bật các vấn đề trực tiếp trong trình soạn thảo của bạn khi bạn gõ. Nó tích hợp các quy tắc từ SonarQube.
*   **SonarQube:** Một nền tảng dựa trên máy chủ, toàn diện để kiểm tra chất lượng mã liên tục. Nó cung cấp một bảng điều khiển để theo dõi các "code smell", lỗi, lỗ hổng, và nợ kỹ thuật theo thời gian. Nó là một phần trung tâm của nhiều pipeline CI/CD.

---

#### **2. Ví dụ hoặc Đoạn mã cấu hình**

##### **Ví dụ JavaDoc**
```java
/**
 * Đại diện cho một tài khoản người dùng trong hệ thống.
 * Lớp này là bất biến.
 *
 * @see com.example.security.Authenticator
 * @since 1.0
 */
public final class User {

    /**
     * Tìm một người dùng trong cơ sở dữ liệu bằng định danh duy nhất của họ.
     *
     * @param userId ID duy nhất của người dùng cần tìm. Không được là null hoặc rỗng.
     * @return một {@code Optional<User>} chứa người dùng nếu tìm thấy, nếu không thì là một Optional rỗng.
     * @throws IllegalArgumentException nếu userId là null hoặc trống.
     */
    public Optional<User> findById(String userId) {
        // ... triển khai ...
    }
}
```

##### **Cấu hình Plugin Checkstyle của Maven (`pom.xml`)**
Đoạn mã này cho thấy cách tích hợp plugin Checkstyle vào một bản dựng Maven. Bản dựng sẽ thất bại nếu tìm thấy bất kỳ vi phạm phong cách nào.

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-checkstyle-plugin</artifactId>
            <version>3.2.0</version>
            <configuration>
                <!-- Sử dụng một bộ quy tắc tiêu chuẩn, như hướng dẫn phong cách Java của Google -->
                <configLocation>google_checks.xml</configLocation>
                <failOnViolation>true</failOnViolation>
                <consoleOutput>true</consoleOutput>
            </configuration>
            <executions>
                <execution>
                    <phase>validate</phase> <!-- Chạy Checkstyle sớm trong quá trình xây dựng -->
                    <goals>
                        <goal>check</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

---

#### **3. Bài tập nhỏ**
1.  Lấy một lớp Java đơn giản mà bạn đã viết trước đây.
2.  Thêm các chú thích JavaDoc đầy đủ vào lớp và các method public của nó. Bao gồm các thẻ `@param`, `@return`, và `@throws` ở những nơi thích hợp.
3.  Nếu bạn đã cài đặt Maven, hãy tạo một `pom.xml` cho dự án và chạy `mvn javadoc:javadoc`.
4.  Điều hướng đến thư mục `target/site/apidocs` và mở tệp `index.html` trong trình duyệt của bạn để xem tài liệu đã được tạo.
5.  (Tùy chọn) Cài đặt plugin SonarLint trong IDE của bạn (IntelliJ, Eclipse, hoặc VS Code) và xem nó có tìm thấy bất kỳ vấn đề chất lượng nào trong mã của bạn không.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trưởng nhóm của bạn nói, "Bản dựng đang thất bại vì một khối catch trống." Công cụ phân tích tĩnh nào có khả năng nhất chịu trách nhiệm phát hiện và đánh dấu vấn đề này?

A) JavaDoc, vì nó kiểm tra tài liệu bị thiếu.
B) Một công cụ quản lý phụ thuộc như Maven.
C) PMD (Programming Mistake Detector), vì nó được thiết kế để tìm các lỗi lập trình phổ biến.
D) JUnit, vì một khối catch trống là một loại thất bại của bài kiểm thử.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) PMD (Programming Mistake Detector). Các bộ quy tắc của PMD được thiết kế đặc biệt để bắt các lỗi lập trình phổ biến và các thực hành tồi, và việc "nuốt" các ngoại lệ trong một khối catch trống là một ví dụ kinh điển về những gì nó tìm kiếm. Checkstyle tập trung nhiều hơn vào định dạng, và SpotBugs tập trung nhiều hơn vào việc tìm lỗi trong bytecode.

### **Bài 6: Làm chủ IDE và Gỡ lỗi**

#### **1. Giải thích khái niệm**

Một Môi trường phát triển tích hợp (IDE) là công cụ quan trọng nhất của một nhà phát triển. Mặc dù bạn *có thể* viết mã Java trong một trình soạn thảo văn bản đơn giản và biên dịch nó từ dòng lệnh, một IDE cung cấp một sự tăng tốc năng suất lớn thông qua việc hoàn thành mã thông minh, các công cụ tái cấu trúc, tích hợp hệ thống xây dựng, và, quan trọng nhất, một trình gỡ lỗi trực quan mạnh mẽ. Các IDE Java phổ biến nhất là IntelliJ IDEA, Eclipse, và Visual Studio Code với các tiện ích mở rộng Java.

##### **Các tính năng cốt lõi của IDE để tăng năng suất**

*   **Hoàn thành mã thông minh:** Vượt ra ngoài việc hoàn thành văn bản đơn giản. Nó hiểu ngữ cảnh của mã của bạn, đề xuất các method, biến liên quan, và thậm chí tạo ra toàn bộ các khối mã. (ví dụ: `Ctrl+Space` trong hầu hết các IDE).
*   **Điều hướng mã:** Khả năng nhảy ngay lập tức đến định nghĩa của một lớp, method, hoặc biến (`Ctrl+Click` hoặc `F12`), tìm tất cả các lần sử dụng của nó (`Alt+F7`), hoặc điều hướng một hệ thống phân cấp lớp phức tạp.
*   **Tái cấu trúc (Refactoring):** Các chuyển đổi mã tự động, an toàn. Đây là những thứ không thể thiếu để duy trì một cơ sở mã sạch sẽ.
    *   **Đổi tên (`Shift+F6`):** Đổi tên một biến, method, hoặc lớp một cách an toàn ở mọi nơi nó được sử dụng.
    *   **Trích xuất Method (`Ctrl+Alt+M`):** Biến một khối mã được chọn thành một method mới.
    *   **Giới thiệu Biến (`Ctrl+Alt+V`):** Tạo một biến mới từ một biểu thức được chọn.
    *   **Nội tuyến (`Ctrl+Alt+N`):** Ngược lại với việc trích xuất; thay thế một lời gọi method hoặc biến bằng nội dung của nó.
*   **Mẫu trực tiếp / Đoạn mã:** Cho phép bạn tạo mã soạn sẵn với một từ viết tắt ngắn. Ví dụ, gõ `sout` và nhấn Tab trong IntelliJ sẽ mở rộng thành `System.out.println();`.

##### **Trình gỡ lỗi trực quan: Công cụ mạnh mẽ nhất của bạn**
Trình gỡ lỗi cho phép bạn tạm dừng việc thực thi chương trình của mình tại các điểm cụ thể và kiểm tra trạng thái của nó. Đây là một cách mạnh mẽ hơn vô hạn để tìm lỗi so với việc rải rác mã của bạn bằng `System.out.println()`.

**Các khái niệm gỡ lỗi chính:**
1.  **Điểm ngắt (Breakpoints):** Một dấu bạn đặt trên một dòng mã. Khi việc thực thi của chương trình đến một điểm ngắt, nó sẽ tạm dừng, và giao diện người dùng của trình gỡ lỗi trở nên hoạt động.
    *   **Điểm ngắt có điều kiện:** Bạn có thể cấu hình một điểm ngắt để chỉ tạm dừng khi một điều kiện cụ thể là đúng (ví dụ: `i == 500`). Điều này rất quan trọng để gỡ lỗi các vấn đề bên trong các vòng lặp dài.
2.  **Các điều khiển bước:** Sau khi tạm dừng, bạn có một số tùy chọn để kiểm soát luồng thực thi:
    *   **Step Over (`F8`):** Thực thi dòng mã hiện tại và tạm dừng trên dòng tiếp theo trong *cùng một method*. Nếu dòng hiện tại là một lời gọi method, nó sẽ thực thi toàn bộ method mà không đi vào bên trong nó.
    *   **Step Into (`F7`):** Nếu dòng hiện tại là một lời gọi method, điều này sẽ di chuyển điểm thực thi đến *dòng đầu tiên bên trong* method đó, cho phép bạn gỡ lỗi nó.
    *   **Step Out (`Shift+F8`):** Thực thi phần còn lại của method hiện tại và tạm dừng trên dòng ngay sau lời gọi method ban đầu.
    *   **Resume Program (`F9`):** Tiếp tục thực thi bình thường cho đến khi gặp điểm ngắt tiếp theo hoặc chương trình kết thúc.
3.  **Kiểm tra trạng thái:** Trong khi tạm dừng, bạn có thể kiểm tra mọi thứ về trạng thái hiện tại của chương trình:
    *   **Chế độ xem biến:** Hiển thị các giá trị hiện tại của tất cả các biến cục bộ và các trường (`this`).
    *   **Theo dõi (Watches):** Cho phép bạn nhập các biểu thức tùy chỉnh (ví dụ: `user.getAddress().getCity()`) được đánh giá trong ngữ cảnh hiện tại.
    *   **Đánh giá biểu thức (`Alt+F8`):** Một tính năng mạnh mẽ cho phép bạn thực thi mã tùy ý trong ngữ cảnh của ứng dụng đang bị tạm dừng, cho phép bạn kiểm tra các lời gọi method hoặc thay đổi các giá trị biến ngay lập tức.
4.  **Call Stack:** Hiển thị chuỗi các lời gọi method đã dẫn đến điểm thực thi hiện tại. Điều này vô giá để hiểu làm thế nào bạn đã đến được nơi bạn đang ở.

---

#### **2. Ví dụ hoặc Đoạn mã cấu hình**

**Một kịch bản gỡ lỗi:**
Hãy tưởng tượng bạn có đoạn mã có lỗi này được cho là để tính tổng các số chẵn nhưng lại tạo ra kết quả sai.

```java
public class BuggyCalculator {
    public int sumEvenNumbers(int limit) {
        int sum = 0;
        for (int i = 0; i <= limit; i++) {
            // Đây là dòng có lỗi
            if (i % 2 != 0) {
                sum += i;
            }
        }
        return sum;
    }

    public static void main(String[] args) {
        BuggyCalculator calculator = new BuggyCalculator();
        int result = calculator.sumEvenNumbers(10);
        // Mong đợi: 2 + 4 + 6 + 8 + 10 = 30
        // Thực tế: 1 + 3 + 5 + 7 + 9 = 25
        System.out.println("Result: " + result);
    }
}
```

**Các bước gỡ lỗi trong IDE:**
1.  **Đặt một Điểm ngắt:** Đặt một điểm ngắt trên dòng `if (i % 2 != 0) {`.
2.  **Chạy ở chế độ gỡ lỗi:** Thay vì "Run", hãy chọn "Debug". Chương trình sẽ bắt đầu và sau đó tạm dừng khi việc thực thi đến điểm ngắt của bạn.
3.  **Kiểm tra trạng thái:** Chế độ xem "Variables" sẽ cho bạn thấy các giá trị hiện tại của `sum` và `i`.
4.  **Step Over:** Nhấn `F8`. Việc thực thi sẽ di chuyển đến lần lặp tiếp theo của vòng lặp. Hãy xem các giá trị của `i` và `sum` thay đổi như thế nào.
5.  **Xác định lỗi:** Khi bạn bước qua, bạn sẽ nhanh chóng nhận thấy rằng điều kiện `if` là sai. Nó đang cộng các số *lẻ*, không phải các số chẵn. Bạn đã tìm thấy lỗi mà không cần thêm một `println` nào.
6.  **Đánh giá biểu thức (Tùy chọn):** Trong khi tạm dừng, bạn có thể mở cửa sổ "Evaluate Expression" và gõ `i % 2 == 0`. Điều này sẽ cho phép bạn kiểm tra logic đúng ngay lập tức.
7.  **Sửa và chạy lại:** Dừng trình gỡ lỗi, sửa mã (`if (i % 2 == 0)`), và chạy lại để xác nhận kết quả đúng.

---

#### **3. Bài tập nhỏ**
1.  Nếu bạn chưa có, hãy cài đặt một IDE Java hiện đại như IntelliJ IDEA (Community Edition là miễn phí) hoặc Visual Studio Code với "Extension Pack for Java".
2.  Viết một chương trình đơn giản với một method gọi hai method trợ giúp private khác theo trình tự.
3.  Đặt một điểm ngắt ở đầu method chính.
4.  Bắt đầu trình gỡ lỗi.
5.  Thực hành sử dụng **Step Over (`F8`)** để di chuyển qua method chính từng dòng một.
6.  Khi bạn đến lời gọi đến method trợ giúp đầu tiên của mình, hãy sử dụng **Step Into (`F7`)** để nhảy vào bên trong nó.
7.  Khi ở bên trong method trợ giúp, hãy sử dụng **Step Out (`Shift+F8`)** để nhanh chóng hoàn thành việc thực thi của nó và quay trở lại method chính.
8.  Làm quen với giao diện người dùng của trình gỡ lỗi và các chế độ xem "Variables" và "Call Stack".

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Bạn đang bị tạm dừng tại một điểm ngắt trên một dòng gọi một method phức tạp, `processData()`. Bạn tin rằng `processData()` hoạt động chính xác và bạn không quan tâm đến việc gỡ lỗi logic nội bộ của nó. Bạn chỉ muốn thực thi nó và di chuyển đến dòng tiếp theo trong method hiện tại của mình. Bạn nên sử dụng hành động gỡ lỗi nào?

A) Step Into
B) Step Out
C) Step Over
D) Resume Program

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** C) Step Over. "Step Over" thực thi toàn bộ lời gọi method trên dòng hiện tại như một bước duy nhất và tạm dừng trên dòng tiếp theo, cho phép bạn tiếp tục gỡ lỗi trong ngữ cảnh hiện tại của mình mà không bị phân tâm bởi các chi tiết nội bộ của các method khác.

### **Bài 7: Hệ thống Module Java (JPMS)**

#### **1. Giải thích khái niệm**

##### **Vấn đề trước Java 9: Classpath nguyên khối**
Trước Java 9, môi trường thời gian chạy Java là một thực thể khổng lồ, nguyên khối (`rt.jar`). Bất kỳ ứng dụng nào, dù nhỏ đến đâu, đều có quyền truy cập vào toàn bộ thư viện chuẩn của Java. Mã của chính ứng dụng và tất cả các thư viện của bên thứ ba của nó được đặt trên một **classpath** phẳng, duy nhất. Điều này đã dẫn đến một số vấn đề đáng kể:

1.  **Đóng gói yếu:** Không có cách nào để ngăn chặn mã trong một JAR truy cập các lớp `public` trong một JAR khác, ngay cả khi các lớp đó chỉ dành cho mục đích sử dụng nội bộ. Điều này đã phá vỡ sự đóng gói và làm cho các thư viện khó phát triển.
2.  **Địa ngục JAR (JAR Hell):** Xung đột có thể dễ dàng phát sinh nếu hai thư viện khác nhau trên classpath phụ thuộc vào các phiên bản khác nhau của một thư viện thứ ba. JVM sẽ chỉ chọn cái nào nó tìm thấy đầu tiên, thường dẫn đến các ngoại lệ `NoSuchMethodError` bí ẩn tại thời gian chạy.
3.  **Dấu chân JRE lớn:** Mỗi cài đặt JRE đều bao gồm toàn bộ thư viện chuẩn (AWT cho đồ họa, CORBA cho mạng kế thừa, v.v.), ngay cả khi một ứng dụng chỉ cần package `java.lang` cốt lõi. Đây là một vấn đề đối với các thiết bị nhỏ, có bộ nhớ hạn chế và các microservice.
4.  **Khởi động chậm:** JVM phải quét toàn bộ classpath để tìm và tải các lớp, điều này có thể làm chậm quá trình khởi động của các ứng dụng lớn.

##### **Giải pháp: Hệ thống Module Nền tảng Java (JPMS)**
Java 9 đã giới thiệu **Hệ thống Module Nền tảng Java (JPMS)**, còn được gọi là Project Jigsaw. Đây là một thay đổi cơ bản đối với cấu trúc của nền tảng và các ứng dụng Java. Ý tưởng cốt lõi là chia nhỏ JRE và các ứng dụng thành các đơn vị nhỏ hơn, được xác định rõ ràng, và tự chứa được gọi là **module**.

Một **module** là một tập hợp các package liên quan, cùng với một tệp mô tả đặc biệt xác định các thuộc tính của nó.

##### **`module-info.java`: Trình mô tả Module**
Tệp này là trái tim của một module. Nó được đặt ở gốc của thư mục nguồn của bạn và định nghĩa "hợp đồng API" của module.

**Các chỉ thị chính:**
*   **`module com.example.mymodule { ... }`:** Khai báo một module mới.
*   **`requires <module_name>;`:** Chỉ định rằng module này *phụ thuộc vào* một module khác. Mã trong module này bây giờ có thể truy cập các package *được xuất* của module được yêu cầu.
    *   `requires transitive <module_name>;`: Một chỉ thị nâng cao hơn. Nó có nghĩa là bất kỳ module nào `requires` module của bạn sẽ *cũng* ngầm `require` module bắc cầu này.
*   **`exports <package_name>;`:** Làm cho các loại `public` trong package được chỉ định có thể truy cập được bởi các module khác `require` module này. Đây là **API công khai** của module. Bất kỳ package nào không được liệt kê ở đây đều được đóng gói mạnh mẽ và không thể truy cập từ bên ngoài, ngay cả khi các lớp của nó là `public`.
*   **`opens <package_name>;`:** Cho phép các module khác sử dụng **phản xạ (reflection)** để truy cập các thành viên private của các lớp trong package này. Điều này là cần thiết cho các framework dựa vào phản xạ, như Spring hoặc Jackson.
*   **`uses <interface_name>;` / `provides <interface_name> with <implementation_class>;`:** Được sử dụng để triển khai một mẫu nhà cung cấp dịch vụ, một phần quan trọng của cơ chế ServiceLoader của Java để tạo ra các ứng dụng có thể mở rộng, được tách rời.

##### **Classpath vs. Module Path**
Với JPMS, JVM bây giờ có hai đường dẫn khác nhau để tải mã:
1.  **Classpath:** Cách cũ. Bất kỳ JAR nào trên classpath đều được coi là một phần của một "module không tên" duy nhất. Tất cả các loại public đều có thể truy cập được bởi mọi người. Điều này tồn tại để tương thích ngược.
2.  **Module Path:** Cách mới. JVM tìm kiếm các module (hoặc dưới dạng các JAR có module hoặc các thư mục được giải nén) trên đường dẫn này. Nó đọc các tệp `module-info.java` của chúng để xây dựng một "đồ thị module", đảm bảo rằng tất cả các phụ thuộc đều được đáp ứng và không có xung đột nào trước khi khởi chạy ứng dụng. Nếu một module bị thiếu hoặc hai module xuất cùng một package, JVM sẽ không khởi động được. Điều này cung cấp **cấu hình đáng tin cậy** và **sự đóng gói mạnh mẽ**.

---

#### **2. Ví dụ hoặc Đoạn mã cấu hình**

Hãy mô hình hóa một ứng dụng đơn giản với hai module: một module dịch vụ và một module ứng dụng chính sử dụng nó.

**Cấu trúc dự án:**
```
my-modular-app/
├── src/
│   ├── com.example.app/
│   │   ├── module-info.java
│   │   └── com/example/app/Main.java
│   └── com.example.service/
│       ├── module-info.java
│       └── com/example/service/GreeterService.java
└── out/
    ├── modules/
    │   ├── com.example.app/
    │   └── com.example.service/```

**1. Module dịch vụ (`com.example.service`)**
```java
// src/com.example.service/module-info.java
module com.example.service {
    // Chúng ta khai báo package nào là API công khai của chúng ta.
    exports com.example.service;
}

// src/com.example.service/com/example/service/GreeterService.java
package com.example.service;

public class GreeterService {
    public String greet(String name) {
        return "Hello, " + name + "!";
    }
}
```

**2. Module ứng dụng (`com.example.app`)**
```java
// src/com.example.app/module-info.java
module com.example.app {
    // Chúng ta khai báo rằng chúng ta phụ thuộc vào module dịch vụ.
    requires com.example.service;
}

// src/com.example.app/com/example/app/Main.java
package com.example.app;

import com.example.service.GreeterService; // Import này bây giờ được cho phép.

public class Main {
    public static void main(String[] args) {
        GreeterService service = new GreeterService();
        System.out.println(service.greet("Modular World"));
    }
}
```

**3. Biên dịch và Chạy:**
```bash
# Biên dịch cả hai module vào thư mục 'out/modules'
javac -d out/modules/com.example.service src/com.example.service/module-info.java src/com.example.service/com/example/service/GreeterService.java
javac --module-path out/modules -d out/modules/com.example.app src/com.example.app/module-info.java src/com.example.app/com/example/app/Main.java

# Chạy ứng dụng bằng cách sử dụng module path
java --module-path out/modules --module com.example.app/com.example.app.Main
```

---

#### **3. Bài tập nhỏ**
1.  Trong ví dụ trên, hãy tạo một package mới `com.example.service.internal` bên trong module `com.example.service`.
2.  Tạo một lớp `public` `InternalHelper` bên trong package mới này.
3.  Đi đến lớp `Main.java` trong module `com.example.app` và thử import và sử dụng lớp `InternalHelper`.
4.  Quan sát rằng điều này dẫn đến một **lỗi tại thời điểm biên dịch**.
5.  Giải thích tại sao lỗi xảy ra, mặc dù `InternalHelper` là một lớp `public`.

**Cái nhìn sâu sắc về câu trả lời:** Lỗi xảy ra vì module `com.example.service` không `export` package `com.example.service.internal` trong tệp `module-info.java` của nó. Điều này minh họa **sự đóng gói mạnh mẽ**. Mặc dù lớp là `public`, nó không phải là một phần của API công khai của module và do đó không thể truy cập được bởi các module khác.

---

#### **4. Câu hỏi trắc nghiệm**

**Câu hỏi:** Trong một tệp `module-info.java`, mục đích của chỉ thị `exports` là gì?

A) Để chỉ định các module khác mà module này phụ thuộc vào.
B) Để làm cho các loại `public` trong một package cụ thể có thể nhìn thấy và truy cập được bởi các module khác.
C) Để cho phép các module khác sử dụng phản xạ để truy cập các thành viên private của một package.
D) Để liệt kê tất cả các package có trong module.

*(Cuộn xuống để xem đáp án)*

...

**Đáp án:** B) Để làm cho các loại `public` trong một package cụ thể có thể nhìn thấy và truy cập được bởi các module khác. Từ khóa `exports` là cơ chế chính để định nghĩa API công khai của một module. Bất kỳ package nào không được xuất một cách tường minh đều được coi là một chi tiết triển khai nội bộ của module.

### **Bài 8: Tóm tắt chủ đề, Câu hỏi phỏng vấn, và Dự án cuối cùng**

Bài học cuối cùng này cung cấp một bản tóm tắt về hệ sinh thái công cụ của Java, trình bày các câu hỏi phỏng vấn phổ biến liên quan đến các công cụ này, và phác thảo một dự án nhỏ để tích hợp chúng vào một vòng đời xây dựng-kiểm thử-ghi tài liệu hoàn chỉnh.

---

#### **1. Bảng tóm tắt các công cụ chính**

| Thể loại | Công cụ | Vai trò & Mục đích | Ưu / Nhược điểm |
| :--- | :--- | :--- | :--- |
| **Công cụ xây dựng** | **Maven** | Quản lý các phụ thuộc, vòng đời xây dựng, và cấu trúc dự án bằng một XML khai báo (`pom.xml`). | **Ưu:** Rất trưởng thành, hệ sinh thái lớn, cấu trúc cứng nhắc dễ học. **Nhược:** XML dài dòng, có thể chậm, kém linh hoạt. |
| | **Gradle** | Quản lý các phụ thuộc và xây dựng bằng một DSL linh hoạt, có thể lập trình (`build.gradle`). | **Ưu:** Nhanh (xây dựng gia tăng, lưu vào bộ đệm), ngắn gọn, có thể tùy chỉnh cao. **Nhược:** Đường cong học tập dốc hơn do sự linh hoạt của nó. |
| **Kiểm thử** | **JUnit 5** | Framework tiêu chuẩn để viết và chạy các bài kiểm thử đơn vị trong Java. | **Ưu:** Kiến trúc hiện đại, mô-đun, bộ tính năng phong phú. **Nhược:** Không có gì đáng kể cho mục đích của nó. |
| | **Mockito** | Một framework mocking được sử dụng để tạo các object "giả" để cô lập lớp đang được kiểm thử khỏi các phụ thuộc của nó. | **Ưu:** API sạch sẽ, xác minh và stubbing mạnh mẽ. **Nhược:** Có thể khuyến khích việc kiểm thử các chi tiết triển khai nếu bị lạm dụng. |
| **Ghi log** | **SLF4J** | Một **facade** ghi log (API). Mã ứng dụng của bạn nên phụ thuộc vào cái này. | **Ưu:** Tách rời mã của bạn khỏi một triển khai ghi log cụ thể. |
| | **Logback/Log4j2**| Các **triển khai** ghi log. Các động cơ thực sự ghi các thông điệp log. | **Ưu:** Hiệu suất cao, có thể cấu hình cao (các cấp độ log, các appender). |
| **Chất lượng mã** | **Checkstyle** | Thực thi một **phong cách** và định dạng viết mã nhất quán. | **Ưu:** Đảm bảo tính dễ đọc và sự nhất quán trong toàn đội. |
| | **PMD/SpotBugs**| Các công cụ phân tích tĩnh tìm các **lỗi lập trình** phổ biến và các **lỗi** tiềm ẩn. | **Ưu:** Hoạt động như một người đánh giá mã tự động để phát hiện các sai sót sớm. |
| **Tài liệu** | **JavaDoc** | Công cụ tiêu chuẩn để tạo tài liệu API từ các chú thích trong mã nguồn. | **Ưu:** Tích hợp với JDK, được hiểu phổ biến. |
| **Module (JPMS)**| **`module-info.java`**| Cung cấp sự đóng gói mạnh mẽ và cấu hình đáng tin cậy cho các ứng dụng Java (Java 9+). | **Ưu:** Loại bỏ "Địa ngục JAR", cải thiện bảo mật và hiệu suất. **Nhược:** Có thể phức tạp để di chuyển các ứng dụng kế thừa. |
| **Kiểm soát phiên bản**| **Git** | Hệ thống kiểm soát phiên bản phân tán tiêu chuẩn để theo dõi các thay đổi trong mã nguồn. | **Ưu:** Mạnh mẽ, nhanh, hỗ trợ các quy trình làm việc phân nhánh phức tạp. |

---

#### **2. Các câu hỏi phỏng vấn phổ biến**

1.  **"Các trách nhiệm chính của một công cụ xây dựng như Maven hoặc Gradle là gì?"**
    *   *Trả lời:* Các trách nhiệm chính là: 1) **Quản lý phụ thuộc:** để tự động tải xuống và quản lý các thư viện của bên thứ ba. 2) **Tự động hóa vòng đời xây dựng:** để biên dịch mã nguồn, chạy các bài kiểm thử, và đóng gói ứng dụng thành một định dạng có thể phân phối (như một JAR). 3) **Tiêu chuẩn hóa:** để thực thi một cấu trúc dự án và quy trình xây dựng nhất quán.

2.  **"Sự khác biệt giữa một facade ghi log (như SLF4J) và một triển khai ghi log (như Logback) là gì?"**
    *   *Trả lời:* Một facade là một lớp trừu tượng, một API mà mã ứng dụng của bạn tương tác. Một triển khai là động cơ cụ thể thực hiện công việc ghi log thực tế. Việc sử dụng một facade tách rời ứng dụng của bạn khỏi một triển khai cụ thể, cho phép bạn chuyển đổi các framework ghi log (ví dụ: từ Logback sang Log4j2) chỉ bằng cách thay đổi một phụ thuộc, mà không cần sửa đổi mã nguồn của bạn.

3.  **"Mục đích của việc mocking trong một bài kiểm thử đơn vị là gì? Giải thích bằng một ví dụ."**
    *   *Trả lời:* Mocking được sử dụng để cô lập lớp đang được kiểm thử khỏi các phụ thuộc bên ngoài của nó. Ví dụ, nếu bạn đang kiểm thử một `UserService` phụ thuộc vào một `UserRepository` để nói chuyện với một cơ sở dữ liệu, bạn sẽ mock `UserRepository`. Trong bài kiểm thử của mình, sau đó bạn có thể yêu cầu mock, "Khi `findById(1)` được gọi, hãy trả về object User cụ thể này." Điều này cho phép bạn kiểm thử logic của `UserService` mà không cần một cơ sở dữ liệu thực, làm cho bài kiểm thử nhanh, đáng tin cậy, và chỉ tập trung vào đơn vị đang được kiểm thử.

4.  **"Phạm vi phụ thuộc `provided` trong Maven biểu thị điều gì?"**
    *   *Trả lời:* Phạm vi `provided` chỉ ra rằng một phụ thuộc là cần thiết để biên dịch mã, nhưng nó không nên được đóng gói vào sản phẩm cuối cùng vì nó sẽ được cung cấp bởi môi trường thời gian chạy. Một ví dụ kinh điển là Servlet API, được cung cấp bởi một máy chủ web như Tomcat, vì vậy bạn không cần phải đóng gói nó trong tệp WAR của mình.

5.  **"Những lợi ích chính của Hệ thống Module Nền tảng Java (JPMS) được giới thiệu trong Java 9 là gì?"**
    *   *Trả lời:* Các lợi ích chính là: 1) **Đóng gói mạnh mẽ:** Các module có thể ẩn các package nội bộ của chúng, ngăn chặn việc sử dụng không chủ ý. 2) **Cấu hình đáng tin cậy:** JVM xác thực đồ thị module khi khởi động, ngăn chặn các vấn đề "Địa ngục JAR" như xung đột phiên bản hoặc thiếu phụ thuộc. 3) **Khả năng mở rộng:** Nó cho phép tạo ra các JRE tùy chỉnh, nhỏ hơn chỉ chứa các module mà một ứng dụng cần, giảm dấu chân của ứng dụng.

---

#### **3. Dự án nhỏ cuối cùng: Xây dựng một thư viện Java nhỏ**

Dự án này sẽ tích hợp tất cả các công cụ chúng ta đã thảo luận để xây dựng, kiểm thử, và ghi tài liệu cho một thư viện Java đơn giản, có thể tái sử dụng.

**🎯 Mục tiêu:** Tạo một thư viện tiện ích chuỗi với một vài method trợ giúp. Dự án phải được xây dựng bằng Maven, có các bài kiểm thử đơn vị với JUnit, bao gồm ghi log với SLF4J/Logback, và tạo tài liệu JavaDoc.

**Các thành phần dự án:**

1.  **Thiết lập dự án (Maven):**
    *   Tạo một dự án Maven mới.
    *   Trong `pom.xml`, hãy cấu hình nó với Java 17.
    *   Thêm các phụ thuộc sau:
        *   `org.slf4j:slf4j-api` (phạm vi compile)
        *   `ch.qos.logback:logback-classic` (phạm vi runtime)
        *   `org.junit.jupiter:junit-jupiter-api` (phạm vi test)
        *   `org.junit.jupiter:junit-jupiter-engine` (phạm vi test)

2.  **Mã thư viện (`StringUtils.java`):**
    *   Tạo một lớp `com.example.utils.StringUtils`.
    *   Thêm một `private static final Logger`.
    *   Triển khai một method: `public static boolean isPalindrome(String input)`.
        *   Method này nên trả về `true` nếu chuỗi đầu vào giống nhau khi đọc xuôi và ngược (bỏ qua chữ hoa/thường và các ký tự không phải là chữ và số).
        *   Thêm ghi log: ghi log ở cấp độ `DEBUG` khi method được gọi, và ở cấp độ `INFO` với kết quả. Nếu đầu vào là null, hãy ghi log một `WARN` và trả về `false`.
    *   **Thêm các chú thích JavaDoc đầy đủ** cho lớp và method.

3.  **Mã kiểm thử (`StringUtilsTest.java`):**
    *   Trong `src/test/java`, tạo một lớp kiểm thử `com.example.utils.StringUtilsTest`.
    *   Viết một vài method `@Test` sử dụng các assertion của JUnit 5 để bao quát:
        *   Một palindrome đơn giản (ví dụ: "racecar").
        *   Một palindrome với chữ hoa/thường và dấu câu hỗn hợp (ví dụ: "A man, a plan, a canal: Panama").
        *   Một chuỗi không phải là palindrome.
        *   Một đầu vào null.
        *   Một chuỗi rỗng.

4.  **Cấu hình ghi log (`logback.xml`):**
    *   Trong `src/main/resources`, tạo một tệp `logback.xml`.
    *   Cấu hình nó để ghi các thông điệp cấp độ `INFO` trở lên vào console.

5.  **Xây dựng và Thực thi:**
    *   Từ dòng lệnh, hãy chạy các lệnh Maven sau và quan sát đầu ra:
        1.  `mvn clean compile`: Biên dịch mã nguồn của bạn.
        2.  `mvn test`: Biên dịch và chạy các bài kiểm thử JUnit của bạn. Bạn sẽ thấy kết quả kiểm thử trong console.
        3.  `mvn package`: Làm tất cả những điều trên và đóng gói thư viện của bạn thành một tệp JAR trong thư mục `target/`.
        4.  `mvn javadoc:javadoc`: Tạo tài liệu API trong `target/site/apidocs/`.

Dự án này mô phỏng vòng đời hoàn chỉnh của việc tạo ra một thành phần Java chất lượng chuyên nghiệp, từ việc viết mã và các bài kiểm thử đến việc xây dựng và ghi tài liệu cho nó bằng các công cụ tiêu chuẩn của ngành.

