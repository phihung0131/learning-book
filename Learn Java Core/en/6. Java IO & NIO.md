### **Lesson 1: Understanding the Java I/O Hierarchy**

#### **1. Concept Explanation**

##### **What is I/O?**
Input/Output (I/O) is the mechanism that allows a Java program to communicate with the outside world. This "outside world" can be a file on a disk, a network connection, the system console, or another program. I/O is fundamental for any application that needs to persist data, send/receive data, or interact with a user.

##### **The Two Worlds of Classic I/O: Byte vs. Character Streams**
The `java.io` package is built on a crucial distinction between two types of data:
1.  **Byte Streams:** Handle raw binary data, one 8-bit byte at a time. They are suitable for any kind of data, including images, audio files, executable programs, and character data where you manage the encoding manually.
    *   **Base Abstract Classes:** `InputStream` and `OutputStream`.
2.  **Character Streams:** Handle character data, one 16-bit Unicode character at a time. They are the preferred choice for working with text files because they automatically handle the conversion between bytes and characters using a specified character set (like UTF-8). Using character streams for text prevents common errors related to character encoding.
    *   **Base Abstract Classes:** `Reader` and `Writer`.

**Analogy:** Think of a **byte stream** as a pipe carrying raw, uninspected materials (like crude oil). A **character stream** is like a specialized bottling plant pipe that takes the raw material, refines it into a specific product (like Coca-Cola, representing characters), and ensures it's handled correctly. You would never send a complex machine (like an image file) through the bottling plant.

##### **The Decorator Pattern in Java I/O**
The `java.io` library is a classic example of the **Decorator design pattern**. The core idea is that you start with a basic, "raw" stream that connects to a source (like a file) and then you "wrap" or "decorate" it with other streams to add functionality.

*   **Core Stream (The Component):** `FileInputStream` connects directly to a file to read bytes.
*   **Decorator Stream:** `BufferedInputStream` can wrap a `FileInputStream`. It doesn't connect to the file itself; it adds the functionality of **buffering** (reading large chunks of data into memory at once) to the underlying stream, which dramatically improves performance.

**Diagram of Decoration:**
```
+-----------------------------------+
| Your Code                         |
+-----------------------------------+
       | reads from
+-----------------------------------+
| new BufferedInputStream( ... )    |  <- Decorator (adds buffering)
+-----------------------------------+
       | wraps
+-----------------------------------+
| new FileInputStream("file.txt")   |  <- Component (connects to the source)
+-----------------------------------+
       | reads from
+-----------------------------------+
|           File on Disk            |
+-----------------------------------+
```

##### **The `File` Class**
The `java.io.File` class is the legacy way of representing a file or a directory path. It provides methods to interact with the file system, such as creating files, deleting directories, checking permissions, and listing contents. While still widely used, it has several limitations (e.g., poor error handling, platform-dependent path separators, limited attribute support). The modern approach, introduced in Java 7, is to use the `java.nio.file.Path` and `Files` classes, which we will cover later.

##### **Checked Exceptions in I/O**
Nearly all methods in the `java.io` package that perform actual I/O operations are declared to throw `java.io.IOException` or one of its subclasses (like `FileNotFoundException`). This is a **checked exception**, which forces you, the developer, to handle potential I/O errors in your code using a `try-catch` block or by declaring it in a `throws` clause.

---

#### **2. Example Code: Using the `File` Class**

This code demonstrates basic file system introspection using the `File` class. It does not read or write data yet.

```java
import java.io.File;
import java.io.IOException;

public class FileClassDemo {
    public static void main(String[] args) {
        // Create a File object representing a path. The file may not exist yet.
        File myFile = new File("my-sample-file.txt");

        System.out.println("File object created for path: " + myFile.getAbsolutePath());

        try {
            // --- Basic File Information ---
            if (myFile.exists()) {
                System.out.println("File exists.");
                System.out.println("Is it a directory? " + myFile.isDirectory());
                System.out.println("File size: " + myFile.length() + " bytes");
            } else {
                System.out.println("File does not exist.");
                // Let's create it
                if (myFile.createNewFile()) {
                    System.out.println("File was created successfully.");
                }
            }

            // --- Working with Directories ---
            File myDir = new File("sample-directory");
            if (!myDir.exists()) {
                if (myDir.mkdir()) { // mkdir() creates a single directory
                    System.out.println("\nDirectory created: " + myDir.getAbsolutePath());
                }
            }
            if (myDir.isDirectory()) {
                System.out.println("\nListing contents of directory: " + myDir.getName());
                String[] contents = myDir.list();
                if (contents != null && contents.length > 0) {
                    for (String item : contents) {
                        System.out.println("- " + item);
                    }
                } else {
                    System.out.println("Directory is empty.");
                }
            }

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
        }
    }
}
```

---

#### **3. Mini Exercise**

Write a program that accepts a directory path as a command-line argument.
1.  Use the `File` class to represent this path.
2.  Check if the path exists and if it is a directory.
3.  If it is a directory, iterate through its contents (`file.listFiles()`).
4.  For each item in the directory, print its name and whether it is a file (`[F]`) or a directory (`[D]`).
    *Example Output:*
    ```
    [D] .git
    [F] .gitignore
    [D] src
    [F] pom.xml
    ```

---

#### **4. Quiz Question**

**Question:** You need to write a program that copies an MP3 audio file from one location to another. Which pair of base classes from the `java.io` package is the correct choice for this task?

A) `Reader` and `Writer`
B) `File` and `RandomAccessFile`
C) `InputStream` and `OutputStream`
D) `BufferedReader` and `BufferedWriter`

*(Scroll down for the answer)*

...

**Answer:** C) `InputStream` and `OutputStream`. An MP3 file contains raw binary data, not text. Byte streams are designed to handle any type of binary data without trying to interpret it. Using character streams (`Reader`/`Writer`) would corrupt the file because they would attempt to decode the binary data as text characters, altering the bytes.

### **Lesson 2: Byte Streams and Buffered Streams**

#### **1. Concept Explanation**

Byte streams are the fundamental building blocks of Java I/O. They read and write data as a stream of 8-bit bytes and are the correct choice for handling any kind of raw binary data, such as images, executable files, serialized objects, or network packets.

##### **Core Abstract Classes**
*   **`InputStream`:** An abstract class that is the superclass of all classes representing an input stream of bytes.
    *   **Key Method:** `int read()`: Reads the next byte of data from the input stream. It returns the byte as an `int` value from 0 to 255. It returns **-1** if the end of the stream has been reached. This `-1` is the standard signal for "end-of-stream."
*   **`OutputStream`:** An abstract class that is the superclass of all classes representing an output stream of bytes.
    *   **Key Method:** `void write(int b)`: Writes the specified byte (the 8 low-order bits of the `int`) to the output stream.

##### **Common Concrete Implementations**

*   **File Streams (`FileInputStream` / `FileOutputStream`):**
    *   These are the basic streams for reading from and writing to files on the disk. They provide a direct, unbuffered connection to a file.
*   **Byte Array Streams (`ByteArrayInputStream` / `ByteArrayOutputStream`):**
    *   These streams use an in-memory byte array as their source or destination. They are incredibly useful for operations where you need to read from or write to a temporary buffer in memory without touching the file system. For example, generating a PDF document in memory before sending it over the network.

##### **The Performance Problem: Unbuffered I/O**
When you use a basic `FileInputStream` and call `read()` one byte at a time, each call can potentially trigger a system call to the underlying operating system to read from the disk. System calls are computationally expensive. Reading a 1MB file one byte at a time could result in a million separate system calls, which is extremely slow.

**Analogy:** This is like going to the grocery store to buy ingredients for a big dinner, but you only carry one item back home at a time. You'd make hundreds of trips, and most of your time would be spent traveling, not shopping.

##### **The Solution: Buffered Streams (The Decorators)**

*   **`BufferedInputStream` and `BufferedOutputStream`:** These are decorator classes that add buffering functionality to an underlying stream.
*   **Internal Mechanism:**
    *   A `BufferedInputStream` wraps an `InputStream` and maintains an internal `byte[]` buffer (e.g., 8192 bytes).
    *   When you call `read()`, the `BufferedInputStream` checks if its buffer has data. If so, it returns a byte directly from memory, which is very fast.
    *   If the buffer is empty, it makes a single, large read call on the underlying stream to fill its buffer completely. This one expensive system call now serves thousands of subsequent `read()` requests from memory.
    *   Similarly, `BufferedOutputStream` accumulates bytes in its internal buffer and writes them to the underlying stream in a single large chunk when the buffer is full (or when `flush()` is called).
*   **Performance Benefit:** Buffering dramatically reduces the number of system calls, resulting in a massive performance improvement for most I/O operations.

**Best Practice:** **Always** wrap file streams and other slow streams with buffered streams.

---

#### **2. Example Code Snippet: Copying a Binary File**

This code copies an image file. It shows both the slow, unbuffered way and the fast, buffered way to demonstrate the performance difference.

```java
import java.io.*;

public class FileCopyDemo {

    public static void main(String[] args) throws IOException {
        File sourceFile = new File("source-image.jpg");
        File destUnbuffered = new File("dest-unbuffered.jpg");
        File destBuffered = new File("dest-buffered.jpg");

        // Create a dummy source file for the demo
        try (OutputStream os = new FileOutputStream(sourceFile)) {
            os.write(new byte[5 * 1024 * 1024]); // 5 MB file
        }

        // --- 1. Unbuffered Copy (Slow) ---
        long startTime = System.nanoTime();
        copyFileUnbuffered(sourceFile, destUnbuffered);
        long endTime = System.nanoTime();
        System.out.println("Unbuffered copy time: " + (endTime - startTime) / 1_000_000 + " ms");

        // --- 2. Buffered Copy (Fast) ---
        startTime = System.nanoTime();
        copyFileBuffered(sourceFile, destBuffered);
        endTime = System.nanoTime();
        System.out.println("Buffered copy time:   " + (endTime - startTime) / 1_000_000 + " ms");
    }

    // Slow: Reads one byte at a time, many system calls
    public static void copyFileUnbuffered(File source, File dest) throws IOException {
        try (InputStream in = new FileInputStream(source);
             OutputStream out = new FileOutputStream(dest)) {
            int b;
            while ((b = in.read()) != -1) { // -1 indicates end of stream
                out.write(b);
            }
        }
    }

    // Fast: Reads large chunks into a buffer, few system calls
    public static void copyFileBuffered(File source, File dest) throws IOException {
        // Decorating the file streams with buffered streams
        try (InputStream in = new BufferedInputStream(new FileInputStream(source));
             OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))) {
            byte[] buffer = new byte[8192]; // 8 KB buffer
            int bytesRead;
            while ((bytesRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead);
            }
        }
    }
}
```

---

#### **3. Mini Exercise**

Write a program that takes two file paths as command-line arguments: a source file and a destination file.
1.  Implement the logic to copy the source file to the destination file.
2.  You **must** use `FileInputStream` and `FileOutputStream`.
3.  You **must** wrap them in `BufferedInputStream` and `BufferedOutputStream` to ensure good performance.
4.  Use the `try-with-resources` statement to guarantee that all streams are closed correctly.
5.  Add print statements to confirm when the copy starts and when it finishes.

---

#### **4. Quiz Question**

**Question:** What is the primary purpose of the `BufferedInputStream` decorator?

A) To encrypt the data being read from the underlying stream.
B) To reduce the number of system calls to the underlying data source by reading data in large chunks into an in-memory buffer.
C) To convert the raw byte data from the underlying stream into characters.
D) To ensure that the `read()` method is thread-safe.

*(Scroll down for the answer)*

...

**Answer:** B) To reduce the number of system calls to the underlying data source by reading data in large chunks into an in-memory buffer. This is the definition of buffering and its main performance benefit. It trades a small amount of memory for a significant reduction in expensive I/O operations.

### **Lesson 3: Character Streams and Encodings**

#### **1. Concept Explanation**

While byte streams are essential for raw binary data, they are inconvenient for handling text. A character is not always a single byte. With character encodings like UTF-8, a character can be represented by one to four bytes. If you read a text file one byte at a time, you might read only part of a multi-byte character, leading to corrupted data.

**Character streams** solve this problem. They are designed specifically for text and automatically handle the complex process of converting between bytes and characters using a specified character encoding.

##### **Core Abstract Classes**
*   **`Reader`:** An abstract class for reading character streams. Its `read()` method reads a single 16-bit Unicode character.
*   **`Writer`:** An abstract class for writing character streams. Its `write()` method writes a single character.

##### **The Bridge Streams: `InputStreamReader` and `OutputStreamWriter`**
These two "bridge" classes are the critical link between the byte-oriented world and the character-oriented world.

*   **`InputStreamReader`:** Wraps an `InputStream` (which provides bytes) and decodes those bytes into characters according to a specified `Charset`.
*   **`OutputStreamWriter`:** Wraps an `OutputStream` (which accepts bytes) and encodes characters into bytes before writing them to the underlying stream.

**Analogy:** Think of an `InputStreamReader` as a UN translator. The `InputStream` is a person speaking a raw language (bytes). The `InputStreamReader` (the translator) listens to that raw language and converts it into a universally understood language, Unicode characters, for the rest of your program to consume.

**Diagram of the Bridge:**
```
+--------------+     +-----------------------+     +-------------------+
| Your Code    | <-- | new InputStreamReader | <-- | new FileInputStream|
| (reads chars)|     | (charset: UTF-8)      |     | (reads bytes)     |
+--------------+     +-----------------------+     +-------------------+
                          ^ (decodes)                     ^ (from)
                          |                               |
                     +-------------------------------------------+
                     |        Bytes from file (e.g., UTF-8)      |
                     +-------------------------------------------+
```

##### **`Charset` and Character Encoding**
A `Charset` (character set or encoding) is a rulebook for mapping bytes to characters.
*   **ASCII:** A simple, early encoding. 1 character = 1 byte. Can only represent 128 characters (English alphabet, numbers, symbols).
*   **UTF-8:** The dominant encoding on the web. It's a variable-width encoding. ASCII characters are stored as a single byte, while other characters (like `é`, `ü`, `Ω`, `€`, `你好`) are stored using 2, 3, or 4 bytes. It is backward compatible with ASCII.
*   **UTF-16:** Java's internal representation for characters. Uses 2 bytes for most common characters and 4 bytes for others.

**Best Practice:** **Always** specify the character encoding when working with text. If you don't, the JVM will use the platform's default encoding, which can vary between operating systems (e.g., UTF-8 on macOS/Linux, cp1252 on older Windows in the US/Western Europe). This can lead to your application working on your machine but producing corrupted text on a server with a different default encoding.

##### **Convenience Classes: `FileReader` and `FileWriter`**
*   These are simple subclasses of `InputStreamReader` and `OutputStreamWriter`.
*   **`FileReader`** is equivalent to `new InputStreamReader(new FileInputStream(fileName))`.
*   **`FileWriter`** is equivalent to `new OutputStreamWriter(new FileOutputStream(fileName))`.
*   **Warning:** These classes are convenient but dangerous because they **always use the platform's default encoding**. For robust, cross-platform applications, it is better to be explicit and use `InputStreamReader` and `OutputStreamWriter` with a specified `Charset`.

##### **Buffered Character Streams**
Just like with byte streams, buffering provides a massive performance boost for character streams.
*   **`BufferedReader`:** Wraps a `Reader` to provide buffering. It also adds the very useful `String readLine()` method, which reads a full line of text at a time.
*   **`BufferedWriter`:** Wraps a `Writer` to provide buffering. It adds a `void newLine()` method for writing the platform-specific line separator.

---

#### **2. Example Code Snippet: Reading a Text File Correctly**

This example demonstrates the modern, robust way to read and write a text file using `try-with-resources`, explicit UTF-8 encoding, and buffering.

```java
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;

public class CharacterStreamDemo {

    public static void main(String[] args) {
        String fileName = "sample-text.txt";

        // --- Writing to a file with explicit encoding and buffering ---
        try (Writer writer = new BufferedWriter(
                              new OutputStreamWriter(
                                  new FileOutputStream(fileName), StandardCharsets.UTF_8))) {
            writer.write("Hello, World! This is line 1.\n");
            writer.write("こんにちは, a Japanese character (Konnichiwa).\n");
            writer.write("€ is the Euro symbol.\n");
        } catch (IOException e) {
            System.err.println("Error writing to file: " + e.getMessage());
        }

        // --- Reading from a file with explicit encoding and buffering ---
        System.out.println("Reading from file '" + fileName + "':");
        try (BufferedReader reader = new BufferedReader(
                                        new InputStreamReader(
                                            new FileInputStream(fileName), StandardCharsets.UTF_8))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading from file: " + e.getMessage());
        }

        // --- The Modern NIO.2 way (much simpler) ---
        // The Files utility class handles the streams and buffering for you.
        System.out.println("\nReading with Files.newBufferedReader (NIO.2):");
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(fileName), StandardCharsets.UTF_8)) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading with NIO.2: " + e.getMessage());
        }
    }
}
```

---

#### **3. Mini Exercise**

Write a program that reads a text file line by line and writes a new file where each line is prefixed with a line number.
1.  The program should take two command-line arguments: the input file path and the output file path.
2.  Use a `BufferedReader` for reading and a `BufferedWriter` for writing.
3.  You **must** specify `StandardCharsets.UTF_8` for both reading and writing to ensure correctness.
4.  Use a counter to track the line number.
    *Example Input (`in.txt`):*
    ```
    Hello
    World
    ```
    *Example Output (`out.txt`):*
    ```
    1: Hello
    2: World
    ```

---

#### **4. Quiz Question**

**Question:** What is the primary risk of using `FileReader` and `FileWriter` in a server application that will be deployed on different operating systems?

A) They are much slower than using `FileInputStream` and `FileOutputStream`.
B) They do not support the `AutoCloseable` interface and must be closed manually.
C) They are deprecated and will be removed in future Java versions.
D) They use the platform's default character encoding, which can lead to data corruption if the development and production environments have different defaults.

*(Scroll down for the answer)*

...

**Answer:** D) They use the platform's default character encoding, which can lead to data corruption if the development and production environments have different defaults. This is a common and subtle source of bugs. A file written correctly on a developer's Mac (default UTF-8) might appear as gibberish when read by the same application on a Windows server (default cp1252). Always specifying the charset explicitly is the correct, robust solution.

### **Lesson 4: Advanced I/O Utilities and Serialization**

#### **1. Concept Explanation**

Beyond basic streams, the `java.io` package offers several powerful utility classes for specialized I/O tasks, including interacting with the file system in a more structured way and converting entire object graphs into a byte stream.

##### **`RandomAccessFile` - The Non-Sequential File**
*   **Behavior:** Unlike streams, which read or write data sequentially from beginning to end, `RandomAccessFile` allows you to move a file pointer to any position in a file and read or write data from that specific location.
*   **Analogy:** `InputStream` is like reading a book from page 1 to the end. `RandomAccessFile` is like having a book with a table of contents and page numbers, allowing you to jump directly to any chapter or page.
*   **Mode:** When you create a `RandomAccessFile`, you must specify a mode:
    *   `"r"`: Read-only.
    *   `"rw"`: Read-write.
*   **File Pointer:** It maintains an internal file pointer that indicates the location for the next read or write operation. You can move this pointer with the `seek(long pos)` method.
*   **Use Cases:** Useful for working with files that have a known structure, like database files, binary log files where you need to read the last N bytes, or for editing parts of a large file without rewriting the entire thing.

##### **`PrintStream` and `PrintWriter` - For Formatted Output**
*   **`PrintWriter` (Character-based):** A `Writer` decorator that adds convenient methods for printing formatted representations of various data types (`println()`, `printf()`, `format()`). This is the ideal class for writing human-readable text output. It also has an option for "auto-flushing," which forces a write to the underlying stream every time a newline is printed.
*   **`PrintStream` (Byte-based):** A byte-based equivalent of `PrintWriter`. The most famous instance of this class is **`System.out`**. A key feature (and potential pitfall) is that it **never throws `IOException`**. Instead, it sets an internal error flag that you must manually check with the `checkError()` method. This is convenient for console output but can hide problems when writing to files.
*   **Best Practice:** Use `PrintWriter` for all character-based formatted output. Use `PrintStream` primarily for console output (`System.out`).

##### **Object Serialization**
Serialization is the process of converting a Java object's state into a byte stream. Deserialization is the reverse process: reconstructing the object from that byte stream.

*   **Purpose:**
    1.  **Persistence:** Saving an object's state to a file on disk to be retrieved later.
    2.  **Communication:** Sending an object over a network to another Java application (e.g., in Remote Method Invocation - RMI).
*   **`Serializable` Interface:** To make a class serializable, it must implement the `java.io.Serializable` interface. This is a "marker interface" – it has no methods to implement. It simply signals to the JVM that the object is allowed to be serialized.
*   **`ObjectOutputStream` and `ObjectInputStream`:** These are decorator streams that handle the serialization process.
    *   `new ObjectOutputStream(new FileOutputStream("data.ser"))` wraps a byte stream. Its `writeObject(Object obj)` method performs the serialization.
    *   `new ObjectInputStream(new FileInputStream("data.ser"))` wraps a byte stream. Its `readObject()` method performs the deserialization.

##### **The `transient` Keyword and `serialVersionUID`**
*   **`transient`:** If you have a field in a `Serializable` class that you **do not** want to be saved (e.g., a password, a temporary cache, or a field that can be recalculated), you mark it as `transient`. The serialization process will ignore this field.
*   **`serialVersionUID`:** This is a `private static final long` field that acts as a version number for your class. During deserialization, the JVM checks if the `serialVersionUID` of the class on the classpath matches the one in the serialized byte stream. If they don't match, it throws an `InvalidClassException`. It is a **strong best practice** to explicitly declare this field. If you don't, the compiler will generate one based on the class structure, and seemingly minor changes to the class can cause the generated ID to change, breaking deserialization compatibility.

---

#### **2. Example Code Snippet: Object Serialization**

This example defines a `User` class, marks a field as `transient`, and demonstrates writing and reading the object to a file.

```java
import java.io.*;

// The class must implement Serializable
class User implements Serializable {
    // It's a best practice to explicitly declare this version ID.
    private static final long serialVersionUID = 1L;

    private int id;
    private String username;
    // The 'password' field will NOT be saved during serialization.
    private transient String password;

    public User(int id, String username, String password) {
        this.id = id;
        this.username = username;
        this.password = password;
    }

    @Override
    public String toString() {
        return "User{" + "id=" + id + ", username='" + username + '\'' + ", password='" + password + '\'' + '}';
    }
}

public class SerializationDemo {
    public static void main(String[] args) {
        String filename = "user.ser";
        User userToWrite = new User(101, "alice", "pa$$w0rd");

        // --- 1. Serialize the object to a file ---
        System.out.println("Serializing: " + userToWrite);
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(userToWrite);
            System.out.println("Serialization successful.");
        } catch (IOException e) {
            System.err.println("Error during serialization: " + e.getMessage());
        }

        // --- 2. Deserialize the object from the file ---
        System.out.println("\nDeserializing from " + filename + "...");
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            User userToRead = (User) ois.readObject();
            System.out.println("Deserialized: " + userToRead);
            // Notice that the password field is null because it was transient.
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Error during deserialization: " + e.getMessage());
        }
    }
}
```

---

#### **3. Mini Exercise**

You are building a simple configuration manager that saves its state to a file.
1.  Create a `Configuration` class that implements `Serializable`.
2.  It should contain a `Map<String, String>` to hold configuration key-value pairs.
3.  It should also contain a `transient` `Date` field called `lastModified` that should not be persisted.
4.  Create two methods:
    *   `void save(String filename)`: Serializes the `Configuration` object to the specified file.
    *   `static Configuration load(String filename)`: A static factory method that deserializes and returns a `Configuration` object from a file.
5.  In `main`, create a `Configuration` object, add some settings, save it, and then load it back into a new object to verify that the map was saved but the `lastModified` date was not.

---

#### **4. Quiz Question**

**Question:** What is the purpose of the `transient` keyword in Java?

A) It marks a method as temporary and subject to removal in future versions.
B) It indicates that a field should be excluded from the object serialization process.
C) It declares that a variable is not thread-safe and must be accessed within a synchronized block.
D) It is used to create a file that is deleted automatically when the JVM exits.

*(Scroll down for the answer)*

...

**Answer:** B) It indicates that a field should be excluded from the object serialization process. This is the sole purpose of the `transient` modifier. It signals to the JVM's serialization mechanism to ignore the field when converting an object to a byte stream.

### **Lesson 5: Introduction to NIO (New I/O)**

#### **1. Concept Explanation**

##### **Why Was NIO Created?**
Java's original I/O (`java.io`) model, while simple, has a fundamental limitation: it is **blocking and stream-oriented**.
*   **Blocking:** When a thread makes a `read()` or `write()` call, it is **blocked** until that operation is complete. The thread cannot do any other work. In a high-traffic server handling thousands of clients, dedicating one thread per client is incredibly inefficient, as most threads will just be sitting idle, waiting for I/O.
*   **Stream-Oriented:** Data is processed as a continuous stream of bytes, one at a time. There's no easy way to move back and forth or work with data in chunks.

**NIO (New I/O)**, introduced in Java 1.4 (`java.nio`), was designed to overcome these limitations. It provides a **non-blocking, buffer-oriented** approach to I/O.

##### **NIO vs. Classic I/O: The Core Differences**

| Feature | Classic I/O (`java.io`) | New I/O (NIO) (`java.nio`) |
| :--- | :--- | :--- |
| **Orientation** | **Stream-oriented** (data is a continuous stream) | **Buffer-oriented** (data is read into/from buffers) |
| **Blocking Model** | **Blocking** (thread waits for I/O to complete) | **Non-blocking** (thread can do other work while I/O is in progress) |
| **Direction** | One-way (separate `InputStream` and `OutputStream`) | Two-way (a single `Channel` can be used for both reading and writing) |
| **Key Abstractions**| `InputStream`, `OutputStream`, `Reader`, `Writer` | **`Buffer`**, **`Channel`**, **`Selector`** |
| **Best For** | Simple, sequential I/O (e.g., reading a config file). | High-performance, high-concurrency network applications (e.g., servers, proxies). |

##### **The Three Pillars of NIO**

NIO is built around three core concepts that you must understand.

**1. Channels:**
*   A `Channel` represents a connection to an entity capable of performing I/O operations, such as a file or a network socket. It's like a pipe or conduit for data.
*   **Key Implementations:**
    *   `FileChannel`: For reading from and writing to files.
    *   `SocketChannel`: For TCP network connections.
    *   `ServerSocketChannel`: For listening for incoming TCP connections.
    *   `DatagramChannel`: For UDP network connections.
*   **Key Feature:** Channels are the source and destination for data, but you do not interact with them directly. Instead, you use a `Buffer`.

**2. Buffers:**
*   A `Buffer` is a fixed-size block of memory that acts as a container for data. In NIO, all I/O is done through buffers. Data is first read from a channel **into** a buffer, or written from a buffer **to** a channel.
*   **How it Works:** A buffer is essentially a wrapper around a primitive array (`byte[]`, `char[]`, etc.) that provides a structured way to manage the data. It maintains a set of four internal pointers to track the state of the data:
    *   **`capacity`:** The total size of the buffer. It never changes.
    *   **`limit`:** The index of the first element that should *not* be read or written. It's the "end" of the active data.
    *   **`position`:** The index of the next element to be read or written.
    *   **`mark`:** A remembered position, saved by `mark()` and restored by `reset()`.
*   **The `flip()` Operation:** This is the most crucial buffer operation. After you have finished writing data into a buffer, you must call `flip()` before you can read from it. `flip()` sets the `limit` to the current `position` and resets the `position` to `0`. This effectively prepares the buffer for a "draining" (reading) operation.

**3. Selectors:**
*   A `Selector` is the key to **non-blocking, multiplexed I/O**. It allows a single thread to monitor multiple `Channel`s for I/O events (e.g., "connection ready," "data available for reading").
*   **How it Works:** You "register" your channels with a selector, specifying which events you are interested in (e.g., `SelectionKey.OP_READ`). Then, in a loop, you call the selector's `select()` method. This method blocks until at least one of the registered channels is ready for an I/O operation.
*   **Benefit:** This allows a single thread to efficiently manage thousands of concurrent network connections, which is the foundation of high-performance servers.

**Diagram of NIO Data Flow:**
```
+-----------+       read()       +----------+       write()       +-----------+
| Channel   | <----------------- |  Buffer  | ------------------> | Channel   |
| (e.g., File)|  (Channel writes |          | (Your code writes  | (e.g., Socket)|
|           |   to Buffer)     |          |  from Buffer)      |           |
+-----------+       (drain)      +----------+       (fill)        +-----------+
```

---

#### **2. Example Code Snippet: Reading a File with `FileChannel` and `ByteBuffer`**

This example shows the basic pattern of using a `Channel` to read data into a `Buffer`.

```java
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class NioReadDemo {
    public static void main(String[] args) {
        // Use try-with-resources on the stream and channel
        try (FileInputStream fis = new FileInputStream("sample-text.txt");
             FileChannel channel = fis.getChannel()) {

            // 1. Allocate a buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024); // 1 KB buffer

            System.out.println("Reading from file...");

            // 2. Read data from the channel into the buffer
            while (channel.read(buffer) > 0) {
                // The read() call fills the buffer from the channel.
                // It returns the number of bytes read, or -1 at end-of-stream.

                // 3. Flip the buffer to prepare for reading
                buffer.flip();

                // 4. Read the data from the buffer
                while (buffer.hasRemaining()) {
                    System.out.print((char) buffer.get());
                }

                // 5. Clear the buffer to prepare for the next read
                buffer.clear();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Mini Exercise**

Write a program that uses `FileChannel` and `ByteBuffer` to write the string "Hello, NIO!" to a file named `nio-output.txt`.
1.  Create a `FileOutputStream` and get its `FileChannel`.
2.  Create a `ByteBuffer` and `put` the bytes of your string into it (`myString.getBytes()`).
3.  Remember to `flip()` the buffer after writing to it, to prepare it for being read by the channel.
4.  Use the `channel.write(buffer)` method to write the buffer's contents to the file.
5.  Use `try-with-resources` to ensure the channel and stream are closed.

---

#### **4. Quiz Question**

**Question:** In Java NIO, what is the primary purpose of the `Buffer.flip()` method?

A) To encrypt the contents of the buffer before writing it to a channel.
B) To switch a buffer from write mode to read mode by setting the `limit` to the current `position` and resetting `position` to 0.
C) To clear all the data in the buffer, resetting it to its initial empty state.
D) To create a reversed-order view of the data in the buffer.

*(Scroll down for the answer)*

...

**Answer:** B) To switch a buffer from write mode to read mode by setting the `limit` to the current `position` and resetting `position` to 0. It is the essential step that "seals" the data you've written into the buffer and prepares it to be drained (read).

### **Lesson 6: Working with Channels and Buffers**

#### **1. Concept Explanation**

Mastering NIO requires a solid understanding of the lifecycle and state management of `Buffer` objects, as well as the different ways `Channel`s can interact with them. This lesson dives deeper into these core mechanics.

##### **Buffer State Management**
As we learned, a `Buffer` is governed by four pointers: `mark`, `position`, `limit`, and `capacity`. The relationship is always: **`0 <= mark <= position <= limit <= capacity`**.

Let's trace the state of a buffer through a typical read/write cycle.

**1. Initial State (Allocation):**
When you allocate a buffer, its pointers are set for writing.
`ByteBuffer buffer = ByteBuffer.allocate(8);`
*   `position = 0` (Ready to write at the beginning)
*   `limit = 8` (You can write up to the capacity)
*   `capacity = 8`

**2. Writing to the Buffer:**
You `put` data into the buffer. The `position` advances.
`buffer.put((byte)'H').put((byte)'E').put((byte)'L').put((byte)'L').put((byte)'O');`
*   `position = 5`
*   `limit = 8`
*   `capacity = 8`

**3. Flipping the Buffer (Prepare for Reading):**
You call `buffer.flip()`. This is the crucial step to switch from writing to reading.
*   `limit` is set to the current `position`.
*   `position` is reset to `0`.
    `buffer.flip();`
*   `position = 0` (Ready to read from the beginning)
*   `limit = 5` (You can only read the 5 bytes you wrote)
*   `capacity = 8`

**4. Reading from the Buffer:**
You `get` data from the buffer. The `position` advances again.
`buffer.get(); buffer.get();`
*   `position = 2`
*   `limit = 5`
*   `capacity = 8`

**5. Clearing or Compacting the Buffer (Prepare for Writing Again):**
You have two main options to prepare the buffer for the next write cycle.
*   **`clear()`:** Resets the buffer to its initial state. It does **not** erase the data in the buffer; it simply resets the pointers.
    `buffer.clear();`
    *   `position = 0`
    *   `limit = 8` (Back to capacity)
    *   This is the most common choice when you are done with the buffer's current contents.
*   **`compact()`:** Used when you have only partially read the buffer and want to discard the read data but keep the unread data. It copies all unread bytes (from `position` to `limit`) to the beginning of the buffer and then sets the pointers for writing.
    *   This is useful for processing data in chunks.

##### **Direct vs. Non-Direct Buffers**

When you allocate a `ByteBuffer`, you have two choices:
*   **Non-Direct Buffer (`ByteBuffer.allocate()`):**
    *   This is the standard buffer type. It allocates a `byte[]` array on the **Java heap**.
    *   **Pro:** Managed by the JVM's garbage collector, easy to use.
    *   **Con:** When this buffer is used in an I/O operation, the JVM must first copy its contents to an intermediate native memory buffer before the OS can perform the I/O. This extra copy can introduce a performance overhead.
*   **Direct Buffer (`ByteBuffer.allocateDirect()`):**
    *   This allocates a block of memory **outside the Java heap**, in native memory.
    *   **Pro:** The OS can perform I/O directly on this buffer without any intermediate copying, which can be significantly faster for large, high-volume I/O operations. This is known as **zero-copy** in some contexts.
    *   **Con:** Allocating and deallocating native memory is more expensive than heap memory. These buffers are not garbage collected in the standard way and can lead to memory management issues if not used carefully.
*   **Best Use Case:** Use **direct buffers** for long-lived, large buffers that will be involved in frequent I/O operations (e.g., in a network server). Use **non-direct buffers** for smaller, short-lived, or less frequently used I/O tasks.

##### **Scatter/Gather I/O**
NIO provides a powerful feature where a `Channel` can read data into, or write data from, multiple buffers in a single operation.
*   **Scattering Read (`channel.read(ByteBuffer[] bufs)`):** Reads bytes from a channel into a sequence of buffers. It fills the first buffer, then the second, and so on. This is useful for parsing structured data where a header goes into one buffer and the body into another.
*   **Gathering Write (`channel.write(ByteBuffer[] bufs)`):** Writes bytes to a channel from a sequence of buffers. It drains the first buffer, then the second, and so on. This is useful for assembling a message from separate header, body, and footer buffers and sending it in a single system call.

---

#### **2. Example Code Snippet: Writing a File with `FileChannel`**

This code demonstrates the write cycle: put data, flip, write to channel.

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.charset.StandardCharsets;

public class NioWriteDemo {
    public static void main(String[] args) {
        try (FileOutputStream fos = new FileOutputStream("nio-output.txt");
             FileChannel channel = fos.getChannel()) {

            String text1 = "This is the first line.\n";
            String text2 = "This is the second line.";

            // Allocate a buffer
            ByteBuffer buffer = ByteBuffer.allocate(1024);

            // --- Write first part ---
            buffer.put(text1.getBytes(StandardCharsets.UTF_8));
            buffer.flip(); // Prepare for draining (writing to channel)
            while(buffer.hasRemaining()) {
                channel.write(buffer);
            }

            // --- Write second part ---
            buffer.clear(); // Prepare for writing into the buffer again
            buffer.put(text2.getBytes(StandardCharsets.UTF_8));
            buffer.flip(); // Prepare for draining
            while(buffer.hasRemaining()) {
                channel.write(buffer);
            }

            System.out.println("File written successfully.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Mini Exercise**

You are given a file that contains a fixed-format message:
*   The first 4 bytes are an integer representing the message length.
*   The remaining bytes are the message content (encoded in UTF-8).

Your task is to read this message using a "scattering read."
1.  Create a file with this structure.
2.  Create two `ByteBuffer`s: one with a capacity of 4 (`headerBuffer`) and another with a larger capacity (e.g., 1024, `bodyBuffer`).
3.  Put them into a `ByteBuffer` array: `ByteBuffer[] buffers = { headerBuffer, bodyBuffer };`.
4.  Use `channel.read(buffers)` to read from the file into both buffers in a single operation.
5.  `flip()` both buffers.
6.  Read the integer from the `headerBuffer` to get the message length.
7.  Read the bytes from the `bodyBuffer`, decode them, and print the message.

---

#### **4. Quiz Question**

**Question:** You have a `ByteBuffer` and you just finished writing data into it using the `put()` method. What must you do before you can pass this buffer to a `channel.write()` method?

A) Call `buffer.clear()` to reset the buffer's pointers.
B) Call `buffer.rewind()` to move the position back to 0.
C) Call `buffer.compact()` to shift the data to the beginning.
D) Call `buffer.flip()` to set the limit to the current position and reset the position to 0.

*(Scroll down for the answer)*

...

**Answer:** D) Call `buffer.flip()`. The `channel.write()` method will read (drain) data from the buffer between its `position` and `limit`. After a `put()` operation, the `position` is at the end of the written data. `flip()` correctly sets the `limit` to this position and moves the `position` back to 0, defining the exact block of data that needs to be written.

### **Lesson 7: Selectors and Non-blocking I/O**

#### **1. Concept Explanation**

This lesson covers the most powerful and complex part of NIO: the `Selector`. It is the engine that enables a single thread to manage thousands of concurrent, non-blocking network connections, forming the foundation of high-performance Java servers.

##### **The Problem with Traditional Server Models**
A simple network server design, often called "thread-per-connection," dedicates one thread to each connected client.

```
Client 1 <--> Thread 1 (blocks on read())
Client 2 <--> Thread 2 (blocks on read())
...
Client 5000 <--> Thread 5000 (blocks on read())
```
**Disadvantages:**
1.  **High Resource Usage:** Threads are expensive. Each thread consumes significant memory for its stack. Creating thousands of threads can quickly exhaust system resources.
2.  **Poor Scalability:** Most of the time, these threads are idle, blocked waiting for the client to send data. They are consuming resources but doing no work.
3.  **Context Switching Overhead:** The operating system spends a lot of time switching between these thousands of threads, which is a major performance bottleneck.

##### **The NIO Solution: Non-blocking I/O with a Selector**
NIO's `Selector` provides a mechanism for **I/O multiplexing**. It allows a single thread to monitor multiple `Channel`s and be notified only when one of them is ready for an I/O operation (e.g., has data to read or is ready to accept a write).

**The Workflow:**
1.  **Set Channels to Non-blocking:** All socket channels (`SocketChannel`, `ServerSocketChannel`) that you want to monitor must be configured to be in non-blocking mode: `channel.configureBlocking(false);`.
2.  **Create a Selector:** Create a single `Selector` object: `Selector selector = Selector.open();`.
3.  **Register Channels:** Register each non-blocking channel with the selector. When you register, you specify which "interest operations" you want to be notified about.
    *   `SelectionKey.OP_READ`: Interested in read events.
    *   `SelectionKey.OP_WRITE`: Interested in write events.
    *   `SelectionKey.OP_CONNECT`: Interested in connection completion events.
    *   `SelectionKey.OP_ACCEPT`: Interested in incoming connection events (for `ServerSocketChannel`).
        The registration returns a `SelectionKey` object, which represents the registration of a channel with a selector.
4.  **The Event Loop:** The single management thread enters an infinite loop. Inside the loop:
    *   **Call `selector.select()`:** This is the crucial method. It **blocks** until at least one of the registered channels is ready for one of the operations it's interested in. It returns the number of ready channels.
    *   **Get Ready Keys:** Call `selector.selectedKeys()` to get a `Set` of `SelectionKey` objects for the channels that are ready.
    *   **Process Events:** Iterate over the set of selected keys. For each key, you determine what event it's ready for (`key.isReadable()`, `key.isAcceptable()`, etc.) and perform the corresponding I/O operation (e.g., read data from the channel into a buffer). The I/O calls will not block because the selector has already guaranteed that they are ready.
    *   **Remove the Key:** After processing a key, you **must** remove it from the selected-key set: `iterator.remove()`. The selector only adds keys to the set; it never removes them. If you fail to remove it, the same key will be processed again in the next loop iteration.

**Diagram of the Selector Model:**
```
+---------------------------------+
|          Single Thread          |
|    (Event Loop / Dispatcher)    |
|                                 |
|      while (true) {             |
|        selector.select();  <--+ | Blocks until a channel is ready
|        Set<SelectionKey> keys = | |
|           selector.selectedKeys();|
|        // Iterate and process   |
|      }                          |
+---------------------------------+
        | monitors
+---------------------------------+
|             Selector            |
+---------------------------------+
   | registers | registers | registers
+-----------+ +-----------+ +-----------+
| Channel 1 | | Channel 2 | | Channel...|
| (Client A)| | (Client B)| | (Client N)|
+-----------+ +-----------+ +-----------+
```

---

#### **2. Example Code Snippet: A Simple Non-blocking Echo Server**

This is a simplified but complete example of a server that can handle multiple clients with a single thread.

```java
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;
import java.util.Set;

public class NioEchoServer {
    public static void main(String[] args) throws IOException {
        // 1. Create a Selector
        Selector selector = Selector.open();

        // 2. Create a ServerSocketChannel and configure it
        ServerSocketChannel serverSocket = ServerSocketChannel.open();
        serverSocket.bind(new InetSocketAddress("localhost", 5454));
        serverSocket.configureBlocking(false); // MUST be non-blocking

        // 3. Register the ServerSocketChannel with the Selector for ACCEPT events
        serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        System.out.println("Echo Server started on port 5454...");

        ByteBuffer buffer = ByteBuffer.allocate(256);

        // 4. The Event Loop
        while (true) {
            selector.select(); // Blocks until an event occurs

            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> iter = selectedKeys.iterator();

            while (iter.hasNext()) {
                SelectionKey key = iter.next();

                // Check for an ACCEPT event
                if (key.isAcceptable()) {
                    register(selector, serverSocket);
                }

                // Check for a READ event
                if (key.isReadable()) {
                    answerWithEcho(buffer, key);
                }

                // MUST remove the key after processing
                iter.remove();
            }
        }
    }

    private static void register(Selector selector, ServerSocketChannel serverSocket) throws IOException {
        SocketChannel client = serverSocket.accept(); // Will not block
        client.configureBlocking(false);
        client.register(selector, SelectionKey.OP_READ);
        System.out.println("Accepted new connection from: " + client.getRemoteAddress());
    }

    private static void answerWithEcho(ByteBuffer buffer, SelectionKey key) throws IOException {
        SocketChannel client = (SocketChannel) key.channel();
        int bytesRead = client.read(buffer);

        if (bytesRead == -1) { // Client closed connection
            System.out.println("Connection closed by: " + client.getRemoteAddress());
            client.close();
            return;
        }

        System.out.println("Received " + bytesRead + " bytes from " + client.getRemoteAddress());
        buffer.flip();
        client.write(buffer); // Echo the data back
        buffer.clear();
    }
}
```

---

#### **3. Mini Exercise**

Modify the `answerWithEcho` method in the server example.
1.  Instead of immediately echoing the data back, the server should first convert the incoming text to uppercase.
2.  To do this, you will need to:
    *   Read the bytes from the channel into the buffer.
    *   `flip()` the buffer.
    *   Decode the bytes into a `String` (e.g., using `StandardCharsets.UTF_8.decode(buffer).toString()`).
    *   Convert the string to uppercase.
    *   `clear()` the buffer.
    *   `put` the bytes of the new uppercase string back into the buffer.
    *   `flip()` the buffer again.
    *   Write the buffer's contents back to the client channel.

---

#### **4. Quiz Question**

**Question:** In an NIO `Selector`-based event loop, why is it mandatory to call `iterator.remove()` after processing a `SelectionKey` from the selected-key set?

A) To close the underlying channel associated with the key.
B) To prevent the JVM from running out of memory by clearing old keys.
C) Because the selector only adds keys to the set but does not remove them, failing to do so would cause the same event to be processed repeatedly in a busy loop.
D) To de-register the channel from the selector.

*(Scroll down for the answer)*

...

**Answer:** C) Because the selector only adds keys to the set but does not remove them, failing to do so would cause the same event to be processed repeatedly in a busy loop. The selected-key set is the mechanism by which the `select()` call communicates ready events to your code. Your code is responsible for acknowledging that it has handled the event by removing the key from the set.

### **Lesson 8: Files and Path API (NIO.2)**

#### **1. Concept Explanation**

Introduced in Java 7, NIO.2 (`java.nio.file` package) is a modern, comprehensive, and more robust API for interacting with the file system. It was designed to overcome the limitations of the legacy `java.io.File` class.

##### **`File` vs. `Path`: Why the New API?**

| Feature | `java.io.File` (Legacy) | `java.nio.file.Path` (Modern) |
| :--- | :--- | :--- |
| **Error Handling** | Methods often return `false` or `null` on failure, providing no reason. | Methods throw specific, checked `IOException`s (e.g., `NoSuchFileException`). |
| **Platform Dependence** | Relies on system-dependent path separators (`File.separator`). | An abstraction over the underlying file system, handling OS differences gracefully. |
| **Immutability** | Mutable (e.g., `renameTo()` modifies the object). | **Immutable**. Operations on a `Path` return a new `Path` object. |
| **Functionality** | Limited. Lacks support for symbolic links, file attributes, etc. | Rich and extensive. Provides powerful methods for copying, moving, walking trees, etc. |

**Best Practice:** In all new Java code (version 7+), you should **prefer `Path` and `Files` over the `File` class**.

##### **The `Path` and `Paths` Classes**

*   **`Path` Interface:** A `Path` is an object that represents the path to a file or directory. It is purely an abstract representation and does not require the file or directory to actually exist.
*   **`Paths` Class:** This is a factory class with a single primary method, `get()`, used to create `Path` objects from a `String` or `URI`.
    ```java
    Path p1 = Paths.get("/home/user/file.txt"); // For Linux/macOS
    Path p2 = Paths.get("C:\\Users\\User\\document.docx"); // For Windows
    ```

##### **The `Files` Utility Class**

This is the workhorse of the NIO.2 API. It is a final class consisting of exclusively `static` methods that operate on `Path` objects. It provides a huge range of powerful, one-liner methods for common file operations.

**Key `Files` Methods:**
*   **Existence and Basic Properties:**
    *   `Files.exists(path)`
    *   `Files.notExists(path)`
    *   `Files.isDirectory(path)`
    *   `Files.isRegularFile(path)`
    *   `Files.size(path)`
*   **Creating and Deleting:**
    *   `Files.createFile(path)`
    *   `Files.createDirectory(path)`
    *   `Files.createDirectories(path)` (Creates parent directories if they don't exist)
    *   `Files.delete(path)` (Throws an exception if the file doesn't exist)
    *   `Files.deleteIfExists(path)`
*   **Copying and Moving:**
    *   `Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING)`
    *   `Files.move(source, target, StandardCopyOption.ATOMIC_MOVE)`
*   **Reading and Writing (Simple Cases):**
    *   `byte[] bytes = Files.readAllBytes(path)` (Be careful with large files!)
    *   `List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8)`
    *   `Files.write(path, bytes, StandardOpenOption.CREATE, StandardOpenOption.APPEND)`
    *   **Streams API:** `Stream<String> lineStream = Files.lines(path)` (Returns a lazy `Stream`, excellent for processing large files efficiently).

##### **Directory Traversal: `DirectoryStream` and `FileVisitor`**

*   **`DirectoryStream`:** A modern and efficient way to iterate over the contents of a *single* directory. It is used inside a `try-with-resources` block and is more efficient than the old `file.list()` because it can fetch the contents lazily.
*   **`Files.walk()` and `FileVisitor`:** `Files.walk(startPath)` returns a `Stream<Path>` that allows you to traverse a directory tree **recursively** in a lazy, functional style. For more complex, stateful traversal logic (like deleting an entire directory tree), you use `Files.walkFileTree(startPath, new MyFileVisitor())`. `FileVisitor` is an interface with methods like `preVisitDirectory`, `visitFile`, `postVisitDirectory` that act as callbacks during the traversal.

---

#### **2. Example Code Snippet: Common NIO.2 Operations**

```java
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.List;
import java.util.stream.Stream;

public class Nio2FilesDemo {
    public static void main(String[] args) {
        // 1. Create a Path object
        Path dirPath = Paths.get("temp-data");
        Path filePath = dirPath.resolve("log.txt"); // Join paths

        try {
            // 2. Create directories and file
            if (Files.notExists(dirPath)) {
                Files.createDirectories(dirPath); // Creates 'temp-data'
                System.out.println("Directory created.");
            }
            if (Files.notExists(filePath)) {
                Files.createFile(filePath);
                System.out.println("File created.");
            }

            // 3. Write content to the file (simple way)
            List<String> linesToWrite = List.of("line 1", "line 2", "line 3");
            Files.write(filePath, linesToWrite, StandardCharsets.UTF_8, StandardOpenOption.APPEND);
            System.out.println("\nWrote lines to file.");

            // 4. Read content from the file (simple way)
            System.out.println("\nReading all lines from file:");
            List<String> linesRead = Files.readAllLines(filePath, StandardCharsets.UTF_8);
            linesRead.forEach(System.out::println);

            // 5. Process a large file efficiently with Streams API
            System.out.println("\nProcessing file with Stream API:");
            try (Stream<String> lineStream = Files.lines(filePath)) {
                lineStream.filter(line -> line.contains("2"))
                          .forEach(line -> System.out.println("Found line with '2': " + line));
            }

            // 6. Copy the file
            Path copiedFilePath = dirPath.resolve("log_copy.txt");
            Files.copy(filePath, copiedFilePath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("\nFile copied to: " + copiedFilePath.getFileName());

        } catch (IOException e) {
            System.err.println("An I/O error occurred: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

---

#### **3. Mini Exercise**

Write a program that recursively searches for all files with a `.java` extension within a given directory (e.g., your project's `src` folder).
1.  The program should take the starting directory path as a command-line argument.
2.  Use `Files.walk(startPath)` to get a stream of all paths in the directory tree.
3.  Use the `Stream` API's `filter()` method to find only the paths that represent regular files and whose file names end with `.java`.
4.  Use the `forEach()` method to print the absolute path of each matching file.
5.  Wrap the `Files.walk()` call in a `try-with-resources` block, as the returned `Stream` is `AutoCloseable`.

---

#### **4. Quiz Question**

**Question:** You need to read a 5 GB log file and count how many lines contain the word "ERROR". Which `java.nio.file.Files` method is the most memory-efficient for this task?

A) `Files.readAllBytes(path)`
B) `Files.readAllLines(path)`
C) `Files.newInputStream(path)`
D) `Files.lines(path)`

*(Scroll down for the answer)*

...

**Answer:** D) `Files.lines(path)`. This method is the most memory-efficient because it returns a `Stream<String>` that reads the file **lazily**. It processes the file one line at a time without loading the entire 5 GB file into memory. In contrast, `readAllBytes` and `readAllLines` would both attempt to load the whole file, almost certainly causing an `OutOfMemoryError`. `newInputStream` is a valid way to start, but `Files.lines` is a higher-level abstraction that is perfectly suited for this specific problem.

### **Lesson 9: Topic Summary, Interview Questions, and Final Project**

This concluding lesson summarizes the key differences between Java's I/O models, provides a set of common interview questions to test your knowledge, and offers a final project to apply what you've learned.

---

#### **1. Summary Table: Classic I/O vs. NIO**

| Feature | Classic I/O (`java.io`) | New I/O (NIO) (`java.nio`) |
| :--- | :--- | :--- |
| **Paradigm** | **Stream-oriented:** Data is a continuous, one-way stream. | **Buffer-oriented:** Data is read into/from buffers, giving more control. |
| **Blocking Model** | **Blocking:** A thread is blocked on a read/write call until it completes. | **Non-blocking supported:** A thread can request a read/write and do other work, checking later if the operation is complete. |
| **Directionality** | **One-way:** Separate classes for input (`InputStream`) and output (`OutputStream`). | **Two-way:** A single `Channel` can handle both reading and writing. |
| **Core Abstractions** | `InputStream`, `OutputStream`, `Reader`, `Writer`, `File` | `Channel`, `Buffer`, `Selector`, `Path`, `Files` |
| **Concurrency Model** | 1 Thread per Connection (typically). Poor scalability for many connections. | 1 Thread for Many Connections (via `Selector`). Excellent scalability. |
| **File System API**| `java.io.File`: Limited, poor error handling, platform-dependent. | `java.nio.file.Path`/`Files`: Rich, immutable, better error handling, platform-independent. |
| **Performance** | Good for simple, sequential I/O. Buffering is essential (`Buffered...`). | Superior for high-volume, concurrent network I/O and large file manipulation (e.g., memory-mapped files). |
| **Best Use Case** | Simple file reading/writing, processing sequential data streams. | Building high-performance network servers (HTTP servers, chat servers), handling many connections with few threads. |

---

#### **2. Common Interview Questions**

1.  **"What is the main difference between byte streams and character streams?"**
    *   *Answer:* Byte streams handle raw binary data (8-bit bytes) and are suitable for any file type. Character streams handle text data (16-bit Unicode characters) and automatically manage the translation between bytes and characters using a specified character set. You should always use character streams for text to avoid encoding issues.

2.  **"What is the Decorator pattern in the context of `java.io`, and why is it useful?"**
    *   *Answer:* The Decorator pattern is used to add functionality to a stream by wrapping it in another. For example, a `FileInputStream` provides basic file reading, but you can wrap it in a `BufferedInputStream` to add buffering for performance, which in turn can be wrapped in an `ObjectInputStream` to add object deserialization capabilities. This provides a flexible way to compose functionality.

3.  **"What are the three core components of Java NIO, and what is the role of each?"**
    *   *Answer:* The three core components are **Channels**, **Buffers**, and **Selectors**. A `Channel` is a conduit for data, representing a connection to a file or socket. A `Buffer` is a block of memory that data is read into or written from; all I/O in NIO happens through buffers. A `Selector` is the key to non-blocking I/O, allowing a single thread to monitor multiple channels for I/O events.

4.  **"Explain the purpose of `flip()` in a `ByteBuffer`."**
    *   *Answer:* The `flip()` method switches a buffer from write mode to read mode. After you've written data into a buffer, the `position` is at the end of the data you wrote. `flip()` sets the `limit` to that position and resets the `position` to 0. This prepares the buffer to be drained (read) from the beginning of the data you just wrote.

5.  **"What is a non-blocking server, and how does a `Selector` enable this?"**
    *   *Answer:* A non-blocking server uses a single thread (or a few threads) to handle many concurrent client connections without getting blocked on I/O operations. A `Selector` enables this by allowing that one thread to monitor many channels. The thread calls `selector.select()`, which blocks until *at least one* of the monitored channels is ready for an I/O operation. The thread then services only the ready channels and goes back to waiting, never getting stuck on a client that isn't ready.

6.  **"What advantages does the NIO.2 `Path` API have over the old `java.io.File` class?"**
    *   *Answer:* The `Path` API is superior in several ways: it provides better error handling by throwing specific `IOException`s instead of returning `null` or `false`; it is immutable and thread-safe; it has a richer set of methods for file operations (copy, move, walk trees) via the `Files` class; and it better handles platform-specific details.

---

#### **3. Final Mini-Project: High-Performance File Copy Utility**

This project will challenge you to implement a file copy utility using three different techniques, allowing you to compare their implementation and performance.

**🎯 Goal:** Create a command-line utility that copies a file from a source to a destination using different I/O strategies.

**Project Requirements:**

1.  **Main Class:**
    *   The `main` method should accept three command-line arguments: `[strategy] [source_file] [destination_file]`.
    *   The `strategy` can be one of three values: `io`, `nio`, or `niomap`.
    *   The program should measure and print the time taken for the copy operation.

2.  **Strategy 1: Classic I/O with Buffering (`io`)**
    *   Implement a copy method using `FileInputStream` and `FileOutputStream`.
    *   You **must** wrap these in `BufferedInputStream` and `BufferedOutputStream` for good performance.
    *   Use a byte array buffer (e.g., 8192 bytes) to read from the input and write to the output in a loop.
    *   Use `try-with-resources` to ensure streams are closed.

3.  **Strategy 2: NIO with `FileChannel` and `ByteBuffer` (`nio`)**
    *   Implement a copy method using `FileChannel`.
    *   Get a read channel from a `FileInputStream` and a write channel from a `FileOutputStream`.
    *   Use a `ByteBuffer` to transfer data. In a loop, read from the source channel into the buffer, `flip()` the buffer, and write from the buffer to the destination channel.
    *   Remember to `clear()` or `compact()` the buffer after each write.
    *   Use `try-with-resources`.

4.  **Strategy 3: NIO with `FileChannel.transferTo()` (`niomap` - a misnomer, but for the project)**
    *   This is the most optimized approach.
    *   Implement a copy method using `FileChannel`.
    *   Use the `sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel)` method.
    *   This single method call is highly optimized. On many operating systems, it can perform a **zero-copy** transfer, moving data directly from the disk to the network card or another disk location within kernel space, avoiding the overhead of copying data into the application's user space.
    *   This method should be the fastest for large files.

**How to Run and Test:**
*   Create a large dummy file to test with (e.g., 500 MB or 1 GB).
*   Run your program with each of the three strategies and compare the execution times.

**Example Command Line:**
```bash
java FileCopier io large_video.mp4 large_video_copy.mp4
# Time taken (io): 1234 ms

java FileCopier nio large_video.mp4 large_video_copy.mp4
# Time taken (nio): 876 ms

java FileCopier niomap large_video.mp4 large_video_copy.mp4
# Time taken (niomap): 150 ms
```

This project provides a direct, practical comparison of the main I/O techniques in Java and solidifies the concepts of streams, buffers, channels, and performance optimization.