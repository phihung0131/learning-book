### **Lesson 1: Understanding Abstraction in Java**

#### **1. Concept Explanation**

**Abstraction** is the principle of hiding complex implementation details and showing only the essential features of an object. It focuses on the "what" an object does rather than the "how" it does it. This reduces complexity and isolates the impact of changes.

**Analogy:** Think of a car's dashboard. It provides a simple interface (steering wheel, pedals, speedometer) to control a very complex machine. You don't need to know how the engine, transmission, or combustion process works to drive the car. The complexity is abstracted away.

In Java, abstraction is primarily achieved through two mechanisms: **Abstract Classes** and **Interfaces**.

##### **Abstract Classes**

An abstract class is a blueprint for other classes. It can have a mix of methods with implementations (concrete methods) and methods without implementations (abstract methods).

*   **Keyword:** Declared with the `abstract` keyword.
*   **Instantiation:** It **cannot** be instantiated directly with the `new` keyword.
*   **Content:** Can contain `abstract` methods, concrete methods, constructors, instance variables, `static` methods, and `final` methods.
*   **Purpose:** To provide a common base with shared state (instance variables) and/or shared behavior (concrete methods) for a group of related subclasses. Subclasses that extend an abstract class must provide an implementation for all of its abstract methods.

##### **Interfaces**

An interface is a pure "contract" or a specification of behavior. It defines a set of methods that a class must implement.

*   **Keyword:** Declared with the `interface` keyword.
*   **Instantiation:** It cannot be instantiated directly.
*   **Content (Pre-Java 8):** Could only contain `public abstract` methods and `public static final` constants.
*   **Content (Java 8+):** Can now contain `default` methods (methods with a default implementation) and `static` methods, which allows for more flexibility and backward compatibility.
*   **Purpose:** To define a capability or role that unrelated classes can adopt. A class can `implement` multiple interfaces, allowing it to take on different roles.

##### **When to Use Which: A Critical Decision**

| Feature | Abstract Class | Interface |
| :--- | :--- | :--- |
| **Relationship** | Defines an **"is-a"** relationship. (e.g., a `Dog` is an `Animal`). | Defines a **"can-do"** relationship. (e.g., a `Bird` and a `Plane` can both be `Flyable`). |
| **Multiple Inheritance** | A class can extend **only one** abstract class. | A class can implement **multiple** interfaces. |
| **State (Variables)** | Can have instance variables (non-final, non-static). | Variables are implicitly `public static final` (constants). |
| **Constructors** | Can have constructors (called by subclasses via `super()`). | Cannot have constructors. |
| **Implementation** | Can contain a mix of abstract and concrete methods. | Primarily for defining a contract. Can have `default` implementations since Java 8. |
| **Use Case** | Use when you want to share code and state among closely related classes. | Use when you want to define a contract for behavior that can be implemented by unrelated classes. |

---

#### **2. Example Code Snippet**

This example shows an abstract class `Vehicle` that shares state (`brand`) and behavior (`getBrand()`) and an interface `Alertable` that defines a capability.

```java
// Interface: A "can-do" contract
interface Alertable {
    void triggerAlarm(); // public abstract by default
}

// Abstract Class: An "is-a" relationship blueprint
abstract class Vehicle {
    private String brand; // Shared state

    // Constructor to initialize state
    public Vehicle(String brand) {
        this.brand = brand;
    }

    // Concrete method with shared implementation
    public String getBrand() {
        return brand;
    }

    // Abstract method: Must be implemented by subclasses
    public abstract void startEngine();
}

// Concrete class extending one class and implementing one interface
class Car extends Vehicle implements Alertable {
    public Car(String brand) {
        super(brand); // Call the parent constructor
    }

    @Override
    public void startEngine() {
        System.out.println("The " + getBrand() + " car's engine is starting...");
    }

    @Override
    public void triggerAlarm() {
        System.out.println("The " + getBrand() + " car alarm is blaring: Honk! Honk!");
    }
}

public class AbstractionDemo {
    public static void main(String[] args) {
        // Vehicle myVehicle = new Vehicle("Ford"); // COMPILE ERROR: Cannot instantiate an abstract class.

        Car myCar = new Car("Toyota");
        myCar.startEngine();
        myCar.triggerAlarm();
    }
}
```

---

#### **3. Mini Exercise**

1.  Create an abstract class named `AudioPlayer`.
2.  It should have an instance variable for `volumeLevel` (an `int`) and a concrete method `displayVolume()` that prints the current volume.
3.  Add two abstract methods: `play()` and `stop()`.
4.  Create two concrete subclasses, `MP3Player` and `CDPlayer`, that extend `AudioPlayer`.
5.  Implement the `play()` and `stop()` methods in each subclass with a simple print statement (e.g., "MP3 is playing" or "CD stopped").
6.  In a main method, create instances of both `MP3Player` and `CDPlayer` and test their methods.

---

#### **4. Quiz Question**

**Question:** Which of the following is a primary reason to choose an interface over an abstract class in Java?

A) To provide a base implementation for some methods while leaving others abstract.
B) To allow a class to inherit behavior from multiple sources.
C) To share instance variables across a class hierarchy.
D) Because an interface can have a constructor.

*(Scroll down for the answer)*

...

**Answer:** B) To allow a class to inherit behavior from multiple sources. Java does not support multiple inheritance of classes (a class can only `extend` one parent), but a class can `implement` multiple interfaces, making interfaces the solution for inheriting multiple behavioral contracts.

### **Lesson 2: Encapsulation in Depth**

#### **1. Concept Explanation**

**Encapsulation** is the practice of bundling an object's data (instance variables) and the methods that operate on that data into a single, self-contained unit: a class. It involves restricting direct access to some of an object's components, which is a key part of **data hiding**.

The primary goal of encapsulation is to prevent external code from arbitrarily changing the internal state of an object. Instead, access is provided through a controlled, public interface (methods).

**Analogy:** Consider a bank account. Your account balance is the private data. You cannot reach into the bank's database and change the number directly. Instead, you interact through a well-defined interface: the `deposit()` and `withdraw()` methods. These methods contain logic (e.g., checking for sufficient funds) that protects the integrity of your data. The class is the bank, the data is your balance, and the methods are the tellers or ATM functions.

**Core Benefits:**
*   **Control & Security:** The class maintains full control over its state. You can enforce validation rules (e.g., age cannot be negative).
*   **Flexibility & Maintainability:** You can change the internal implementation of a class (e.g., change a data type from `ArrayList` to `LinkedList`) without breaking any external code that uses it, as long as the public method signatures remain the same.
*   **Data Hiding:** Hides the internal complexity from the outside world, making the class easier to use.

#### **2. The Tools of Encapsulation: Access Modifiers**

Java uses access modifiers to define the visibility level for classes, fields, and methods.

| Modifier | Same Class | Same Package | Subclass (different package) | World (any package) |
| :--- | :--- | :--- | :--- | :--- |
| **`public`** | Yes | Yes | Yes | Yes |
| **`protected`** | Yes | Yes | Yes | No |
| **`default` (package-private)** | Yes | Yes | No | No |
| **`private`** | Yes | No | No | No |

*   **`private`**: The strictest level. The member is only accessible from within the same class. This is the **best practice** for all instance variables.
*   **`default` (no keyword)**: Also known as package-private. The member is accessible to any class within the same package.
*   **`protected`**: Same as `default`, but also accessible to subclasses, even if they are in different packages.
*   **`public`**: The most lenient level. The member is accessible from anywhere. This is typically used for the class's public interface (constructors and methods).

---

#### **3. Controlled Access via Getters and Setters**

The standard mechanism for providing controlled access to private fields is through public methods known as getters and setters (or accessors and mutators).

*   **Getter (Accessor):** A method that retrieves the value of a private field. By convention, it's named `getFieldName()` (or `isFieldName()` for booleans).
*   **Setter (Mutator):** A method that modifies the value of a private field. By convention, it's named `setFieldName()`. This is where you place validation logic.

By exposing only a getter, you create a **read-only** property. By not providing a public setter, you prevent direct modification of a field, forcing changes to happen through other business methods (like `deposit()` in the bank account analogy).

---

#### **4. Example Code Snippet**

This `Person` class properly encapsulates its data. The `age` cannot be set to a negative value.

```java
public class Person {
    // 1. Data is kept private
    private String name;
    private int age;
    private final String socialSecurityNumber; // Read-only after construction

    public Person(String name, int age, String ssn) {
        this.name = name;
        this.socialSecurityNumber = ssn;
        // Use the setter during construction to apply validation
        setAge(age);
    }

    // 2. Public getters provide read access
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public String getSocialSecurityNumber() {
        return socialSecurityNumber;
    }

    // 3. Public setters provide controlled write access
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        }
    }

    public void setAge(int age) {
        // Validation logic protects the object's state
        if (age > 0 && age < 130) {
            this.age = age;
        } else {
            System.out.println("Invalid age provided. Age not set.");
        }
    }
}

class EncapsulationDemo {
    public static void main(String[] args) {
        Person person1 = new Person("Alice", 30, "123-45-678");

        // Direct access is a COMPILE ERROR
        // person1.age = -5;

        // Modify state through the controlled public interface
        System.out.println("Initial age: " + person1.getAge()); // 30
        person1.setAge(-5); // Prints "Invalid age provided."
        System.out.println("Age after invalid attempt: " + person1.getAge()); // Stays 30
        person1.setAge(31);
        System.out.println("Age after valid attempt: " + person1.getAge()); // 31
    }
}
```

---

#### **5. Mini Exercise**

1.  Create a class named `SmartThermostat`.
2.  It should have two `private` instance variables: `temperature` (double) and `isHeating` (boolean).
3.  Create a constructor that initializes `temperature`. The `isHeating` status should depend on the initial temperature (e.g., `isHeating` is true if the temperature is below 20.0).
4.  Provide a public getter `getTemperature()`.
5.  Instead of a generic setter, create a method `setTargetTemperature(double targetTemp)`. This method should:
    *   Set the `temperature` to `targetTemp`.
    *   Update the `isHeating` status based on the new temperature.
    *   Print a message like "Heating is now ON." or "Heating is now OFF."
6.  Provide a read-only getter `isHeating()` for the boolean field.

---

#### **6. Quiz Question**

**Question:** An instance variable is declared as `protected`. Who can access it?

A) Only the class it's declared in.
B) Any class in the same package.
C) Any subclass, regardless of package, and any class within the same package.
D) Any class from any package.

*(Scroll down for the answer)*

...

**Answer:** C) Any subclass, regardless of package, and any class within the same package. This is the definition of `protected` access.

### **Lesson 3: Inheritance and Polymorphism**

#### **1. Concept Explanation**

##### **Inheritance**
Inheritance is a mechanism where a new class (subclass or child class) derives properties (fields) and behaviors (methods) from an existing class (superclass or parent class). It models the **"is-a"** relationship. For example, a `Car` is a `Vehicle`.

*   **Keyword `extends`**: Used to establish the inheritance relationship. `class Car extends Vehicle { ... }`
*   **Code Reusability**: The primary benefit. You can write common code once in a superclass and reuse it across multiple subclasses.
*   **Constructor Chaining & `super`**: A subclass constructor's first job is to call a superclass constructor. If you don't explicitly write `super(...)`, the compiler inserts a call to the no-argument `super()`. If the parent class doesn't have a no-argument constructor, you **must** explicitly call another one using `super(...)` as the very first line. The `super` keyword is also used to access methods of the parent class from the child (`super.parentMethod()`).

##### **The Diamond Problem**
This problem occurs in languages that support multiple inheritance of *state* (classes). If class `D` inherits from both `B` and `C`, and both `B` and `C` inherit from `A`, which version of a method from `A` does `D` inherit if `B` and `C` have both overridden it? Java deliberately avoids this complexity by allowing a class to **extend only one parent class**. Multiple inheritance of *behavior* is achieved by implementing multiple interfaces.

##### **Polymorphism**
Polymorphism, meaning "many forms," is the ability of an object to take on many forms. In Java, the most important type is **Runtime Polymorphism**, which is achieved through method overriding and dynamic binding.

It allows you to write code that works with a superclass type, but at runtime, the correct subclass's implementation of an overridden method is executed.

*   **Dynamic Binding (Late Binding)**: The JVM determines which method implementation to call at runtime, based on the **actual type of the object**, not the type of the reference variable pointing to it. This is the core mechanism of polymorphism.

##### **Casting and `instanceof`**
*   **Upcasting**: Assigning a subclass object to a superclass reference. This is always safe and happens implicitly. `Vehicle v = new Car();`
*   **Downcasting**: Assigning a superclass reference (that points to a subclass object) back to a subclass reference. This is potentially unsafe and must be explicit. It can fail with a `ClassCastException` if the object is not actually an instance of the target subclass.

    ```java
    Vehicle v = new Car(); // Upcasting
    Car c = (Car) v;       // Downcasting (explicit)
    ```
*   **`instanceof` Operator**: A safety check used before downcasting. It returns `true` if an object is an instance of a particular class or interface.

    ```java
    if (v instanceof Car) {
        Car c = (Car) v; // Now this is safe
        c.openTrunk();   // Can call Car-specific methods
    }
    ```

---

#### **2. Example Code Snippet**

This example demonstrates polymorphism. We have a `Shape` array that holds different types of shapes. When we call `draw()` on each element, the JVM uses dynamic binding to execute the correct version of the `draw()` method.

```java
// Superclass
abstract class Shape {
    private String color;

    public Shape(String color) {
        this.color = color;
    }

    public String getColor() {
        return color;
    }

    // Abstract method to be overridden
    public abstract void draw();
}

// Subclass 1
class Circle extends Shape {
    private int radius;

    public Circle(String color, int radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " circle with radius " + radius);
    }
}

// Subclass 2
class Rectangle extends Shape {
    private int width, height;

    public Rectangle(String color, int width, int height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " rectangle of size " + width + "x" + height);
    }

    // A method specific to Rectangle
    public void printDetails() {
        System.out.println("I am a rectangle.");
    }
}

public class PolymorphismDemo {
    public static void main(String[] args) {
        // Upcasting happens here
        Shape[] shapes = new Shape[3];
        shapes[0] = new Circle("Red", 10);
        shapes[1] = new Rectangle("Blue", 20, 30);
        shapes[2] = new Circle("Green", 5);

        // Polymorphism in action
        for (Shape s : shapes) {
            // Dynamic binding: JVM decides which draw() to call at runtime
            s.draw();
        }

        // Downcasting with instanceof check
        for (Shape s : shapes) {
            if (s instanceof Rectangle) {
                Rectangle r = (Rectangle) s; // Safe downcast
                r.printDetails();
            }
        }
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a base class `Weapon` with an `int damage` field and an `attack()` method that prints a generic attack message.
2.  Create two subclasses, `Sword` and `Bow`, that extend `Weapon`.
3.  The `Sword` constructor should set a high damage value. Its `attack()` method should be overridden to print "Swinging the sword!".
4.  The `Bow` constructor should set a lower damage value. Its `attack()` method should be overridden to print "Firing an arrow!".
5.  In `main`, create a `Weapon` array and populate it with a `Sword` and a `Bow`.
6.  Loop through the array and call the `attack()` method on each weapon to demonstrate polymorphism.

---

#### **4. Quiz Question**

**Question:** What is the output of the following code?
```java
class Animal {
    public void greet() { System.out.println("Animal greeting"); }
}
class Dog extends Animal {
    public void greet() { System.out.println("Dog greeting"); }
    public void bark() { System.out.println("Woof!"); }
}

public class Test {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.greet();
    }
}
```

A) `Animal greeting`
B) `Dog greeting`
C) It will cause a compile-time error.
D) It will cause a run-time error.

*(Scroll down for the answer)*

...

**Answer:** B) `Dog greeting`. The reference variable `a` is of type `Animal`, but the object it points to is of type `Dog`. Due to dynamic binding, the JVM executes the overridden `greet()` method from the `Dog` class at runtime.

### **Lesson 4: The `Object` Class and Its Core Methods**

#### **1. Concept Explanation**

In Java, every class is a descendant, direct or indirect, of the `java.lang.Object` class. If a class definition does not use the `extends` keyword, it implicitly extends `Object`. This means every single object in Java inherits the methods of the `Object` class.

Understanding and correctly overriding these methods is crucial for creating well-behaved, predictable objects, especially when they are used in collections like `HashMap` or `HashSet`.

##### **`toString()` Method**
*   **Purpose:** To provide a meaningful, human-readable `String` representation of an object.
*   **Default Behavior:** The default implementation in the `Object` class prints the class name followed by an `@` symbol and the object's hash code in hexadecimal (e.g., `com.example.Car@1a2b3c4d`). This is rarely useful.
*   **Best Practice:** Always override `toString()` in your classes to return a summary of the object's state. It is invaluable for logging and debugging.

##### **`equals()` Method**
*   **Purpose:** To check if two objects are "equal" in terms of their logical content or state.
*   **Default Behavior:** The `==` operator for objects compares memory addresses (reference equality). The default `equals()` method in the `Object` class does the exact same thing: `return (this == obj);`.
*   **The `equals()` Contract:** When you override this method, you **must** adhere to its contract:
    1.  **Reflexive:** `x.equals(x)` must be `true`.
    2.  **Symmetric:** `x.equals(y)` is `true` if and only if `y.equals(x)` is `true`.
    3.  **Transitive:** If `x.equals(y)` is `true` and `y.equals(z)` is `true`, then `x.equals(z)` must be `true`.
    4.  **Consistent:** Multiple calls to `x.equals(y)` must consistently return the same value (unless the object state is modified).
    5.  **Non-null:** `x.equals(null)` must be `false`.

##### **`hashCode()` Method**
*   **Purpose:** To return an integer hash code value for the object. This value is used by hash-based collections like `HashMap`, `HashSet`, and `Hashtable` to efficiently store and retrieve objects.
*   **The `hashCode()` Contract:**
    1.  **Consistency:** If an object's state (the fields used in `equals()`) does not change, its `hashCode()` must consistently return the same integer.
    2.  **The Golden Rule:** **If two objects are equal according to the `equals()` method, then they MUST have the same hash code.**
    3.  **The Reverse is NOT True:** If two objects have the same hash code, they are NOT required to be equal. This is called a "hash collision" and is handled by the data structure.

**Pitfall:** If you override `equals()`, you **MUST** override `hashCode()`. If you don't, two objects that you consider equal might have different hash codes, which will break the functionality of hash-based collections. For example, you might add an object to a `HashSet`, then be unable to find it later.

##### **`clone()` and `finalize()`**
*   **`clone()`:** Creates and returns a copy of an object. The concept of "copy" can be shallow or deep. This method is notoriously difficult to implement correctly and is often avoided in modern Java in favor of copy constructors or factory methods.
*   **`finalize()`:** This method is called by the Garbage Collector on an object when it determines that there are no more references to the object. Its use is **strongly discouraged**. It is not a reliable mechanism for resource cleanup (like closing files or database connections) because there is no guarantee *when* or even *if* it will be called. Use `try-with-resources` or `finally` blocks instead.

---

#### **2. Example Code Snippet**

This `Book` class correctly overrides `equals()` and `hashCode()`. Notice that both methods use the same set of fields (`isbn` and `title`).

```java
import java.util.Objects;

public class Book {
    private final String title;
    private final String isbn;
    private final int year;

    public Book(String title, String isbn, int year) {
        this.title = title;
        this.isbn = isbn;
        this.year = year;
    }

    // A useful toString() implementation
    @Override
    public String toString() {
        return "Book{" +
               "title='" + title + '\'' +
               ", isbn='" + isbn + '\'' +
               ", year=" + year +
               '}';
    }

    // A correct equals() implementation
    @Override
    public boolean equals(Object o) {
        // 1. Self check
        if (this == o) return true;
        // 2. Null check and class check
        if (o == null || getClass() != o.getClass()) return false;
        // 3. Cast the object
        Book book = (Book) o;
        // 4. Compare significant fields
        return Objects.equals(title, book.title) &&
               Objects.equals(isbn, book.isbn);
    }

    // A correct hashCode() implementation
    @Override
    public int hashCode() {
        // Use the same fields as in equals()
        return Objects.hash(title, isbn);
    }
}

class ObjectMethodsDemo {
    public static void main(String[] args) {
        Book book1 = new Book("Effective Java", "978-0134685991", 2018);
        Book book2 = new Book("Effective Java", "978-0134685991", 2018);
        Book book3 = new Book("Clean Code", "978-0132350884", 2008);

        // --- toString() Demo ---
        System.out.println(book1); // Calls the custom toString()

        // --- equals() Demo ---
        System.out.println("book1.equals(book2): " + book1.equals(book2)); // true
        System.out.println("book1.equals(book3): " + book1.equals(book3)); // false

        // --- hashCode() Demo ---
        System.out.println("book1 hashCode: " + book1.hashCode());
        System.out.println("book2 hashCode: " + book2.hashCode());
        System.out.println("book3 hashCode: " + book3.hashCode());
        // book1 and book2 will have the same hash code.
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a `Point` class with two `private int` fields: `x` and `y`.
2.  Provide a constructor to initialize these fields.
3.  Override the `toString()` method to return a string in the format `"(x, y)"`.
4.  Override the `equals()` method. Two `Point` objects should be considered equal if their `x` and `y` values are the same.
5.  Override the `hashCode()` method, ensuring it adheres to the contract with your `equals()` implementation. (Hint: `Objects.hash(x, y)` is the easiest way).
6.  In `main`, create two `Point` objects with the same coordinates and one with different coordinates, then test your `equals` and `hashCode` methods.

---

#### **4. Quiz Question**

**Question:** You have a custom class `Employee` that you want to use as a key in a `HashMap`. You have correctly overridden the `equals()` method. What happens if you do **not** override `hashCode()`?

A) The code will not compile.
B) The code will throw an exception at runtime when you put an `Employee` into the map.
C) You may not be able to retrieve an employee from the map, even if you use a key that is "equal" to one that was inserted.
D) Everything will work correctly, as `HashMap` primarily uses the `equals()` method.

*(Scroll down for the answer)*

...

**Answer:** C) You may not be able to retrieve an employee from the map, even if you use a key that is "equal" to one that was inserted. The `HashMap` first uses `hashCode()` to find the "bucket" where the object should be. If two equal objects have different hash codes (from the default `Object` implementation), the map will look in the wrong bucket and fail to find the object.

### **Lesson 5: Composition vs. Inheritance**

#### **1. Concept Explanation**

This lesson addresses one of the most fundamental design choices in object-oriented programming: how to establish relationships between classes. While Inheritance is a powerful tool for code reuse, it is often overused where a more flexible alternative, Composition, is superior.

##### **Recap: Inheritance ("is-a")**
*   **Relationship:** Models a hierarchical, parent-child relationship. A `Dog` *is-a* specialized type of `Animal`.
*   **Mechanism:** A subclass `extends` a superclass, inheriting its public and protected members.
*   **Coupling:** Creates **tight coupling**. The subclass is intimately linked to the superclass's implementation.

##### **Composition ("has-a")**
*   **Relationship:** Models a whole-part relationship. An object is "composed" of other objects. A `Car` *has-a* `Engine`.
*   **Mechanism:** A class contains an instance variable that is a reference to another object. The containing object (the "whole") is responsible for the lifecycle of the contained object (the "part"). The part often cannot exist without the whole.
*   **Coupling:** Creates **loose coupling**. The "whole" class interacts with the "part" class only through its public interface, treating it as a black box.

##### **Aggregation (a weaker "has-a")**
*   **Relationship:** A variant of composition where the "part" can exist independently of the "whole".
*   **Mechanism:** A class holds a reference to another object, but it is not responsible for its lifecycle. The referenced object is created and managed externally.
*   **Example:** A `Professor` and a `University`. The `University` class has a list of `Professor` objects. The `Professor` can exist without the university, and the university can be dissolved without the professors ceasing to exist.

**UML Diagram Representation:**
*   **Inheritance:** An open, hollow arrowhead pointing from the child to the parent.
*   **Composition:** A filled, black diamond on the "whole" class connected to the "part" class.
*   **Aggregation:** A hollow, white diamond on the "whole" class connected to the "part" class.

---

#### **2. Guiding Principle: "Favor Composition over Inheritance"**

This is a famous design principle for good reason. Inheritance, while powerful, comes with significant drawbacks.

##### **Why Composition is Often Better:**

1.  **Flexibility at Runtime:**
    *   **Inheritance is static and fixed at compile time.** A `HondaCivic` will always be a `Car`. You cannot change this relationship after the code is compiled.
    *   **Composition is dynamic.** You can change the "parts" of an object at runtime. A `Computer` object can have its `GraphicsCard` component swapped from an `NvidiaCard` to an `AMDRadeonCard` by simply changing the object reference. This is a cornerstone of the **Strategy Design Pattern**.

2.  **Avoids Tight Coupling (The Fragile Base Class Problem):**
    *   **Inheritance is fragile.** If you change the implementation of a superclass method, you can unknowingly break all subclasses that inherit it. For example, if a `List` subclass depends on the `add()` method of its parent, and the parent's `addAll()` method is changed to no longer call `add()`, the subclass breaks.
    *   **Composition is robust.** The containing class only knows about the public interface of its components. The internal implementation of a component can be changed freely without any impact, as long as its public contract remains the same.

3.  **Preserves Encapsulation:**
    *   **Inheritance can break encapsulation.** Subclasses often have access to `protected` members of the parent, creating a dependency on the parent's internal implementation details.
    *   **Composition respects encapsulation.** The containing class cannot access the private state of its components. It is a true black-box relationship.

4.  **Simpler, More Testable Design:**
    *   Classes designed for composition are typically smaller, focused on one responsibility, and interact through clear interfaces. This makes them much easier to test in isolation (using mocks or stubs for their components). Testing an inheritance hierarchy often requires testing the entire hierarchy together.

---

#### **3. Example Code Snippet: The Duck Problem**

This classic example shows how an inheritance-based design fails and how composition solves it elegantly.

##### **Problematic Inheritance Approach:**

```java
// Base class with common behavior
abstract class Duck {
    public void swim() { System.out.println("All ducks float!"); }
    public abstract void display();
    // Common but not universal behaviors
    public void quack() { System.out.println("Quack!"); }
    public void fly() { System.out.println("I'm flying!"); }
}

class MallardDuck extends Duck { /* ... displays Mallard ... */ }
class RedheadDuck extends Duck { /* ... displays Redhead ... */ }

// PROBLEM 1: What about a rubber duck? It squeaks, not quacks.
class RubberDuck extends Duck {
    @Override
    public void quack() { System.out.println("Squeak!"); } // Override is required
    @Override
    public void fly() { /* Do nothing, rubber ducks don't fly */ } // Problematic empty override
}
```

##### **Superior Composition Approach:**

```java
// 1. Extract the behaviors into their own interfaces
interface FlyBehavior { void fly(); }
interface QuackBehavior { void quack(); }

// 2. Create concrete implementations of the behaviors
class FlyWithWings implements FlyBehavior {
    public void fly() { System.out.println("I'm flying with wings!"); }
}
class FlyNoWay implements FlyBehavior {
    public void fly() { System.out.println("I can't fly."); }
}
class Quack implements QuackBehavior {
    public void quack() { System.out.println("Quack!"); }
}
class Squeak implements QuackBehavior {
    public void quack() { System.out.println("Squeak!"); }
}

// 3. The Duck class is now COMPOSED of behaviors
abstract class DuckV2 {
    // Composition: Each duck HAS-A fly and quack behavior
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    public void performFly() {
        flyBehavior.fly(); // Delegate the action to the behavior object
    }
    public void performQuack() {
        quackBehavior.quack(); // Delegate
    }
    public void swim() { System.out.println("All ducks float!"); }
    public abstract void display();
}

// 4. Create concrete ducks by plugging in the desired behaviors
class MallardDuckV2 extends DuckV2 {
    public MallardDuckV2() {
        flyBehavior = new FlyWithWings(); // Set the specific behaviors
        quackBehavior = new Quack();
    }
    public void display() { System.out.println("Looks like a Mallard"); }
}

class RubberDuckV2 extends DuckV2 {
    public RubberDuckV2() {
        flyBehavior = new FlyNoWay();
        quackBehavior = new Squeak();
    }
    public void display() { System.out.println("Looks like a Rubber Duck"); }
}
```

---

#### **4. Mini Exercise**

Design a `Character` class for a simple game.
1.  Instead of using inheritance (`Knight extends Character`, `Wizard extends Character`), use composition.
2.  Create an interface `WeaponBehavior` with a method `useWeapon()`.
3.  Create concrete implementations like `SwordBehavior`, `BowAndArrowBehavior`, and `StaffBehavior`.
4.  The `Character` class should have a field for `WeaponBehavior`.
5.  The `Character` class should have a method `attack()` that delegates to the `useWeapon()` method of its `weaponBehavior` object.
6.  The `Character` class should also have a `setWeapon(WeaponBehavior newWeapon)` method to allow changing weapons at runtime.
7.  In `main`, create a character, have it attack with a sword, then change its weapon to a bow and have it attack again.

---

#### **5. Quiz Question**

**Question:** Which statement most accurately describes a key advantage of composition over inheritance?

A) Composition allows for stronger type checking at compile time.
B) Composition allows a class to inherit from multiple other classes, avoiding the diamond problem.
C) Composition allows for greater flexibility by enabling an object's behavior to be changed at runtime.
D) Inheritance is better for code reuse because it provides more direct access to the parent's code.

*(Scroll down for the answer)*

...

**Answer:** C) Composition allows for greater flexibility by enabling an object's behavior to be changed at runtime. This dynamic nature is a primary reason why it is often preferred for building flexible and maintainable systems.

### **Lesson 6: Association, Aggregation, and Composition**

#### **1. Concept Explanation**

In the previous lesson, we contrasted Inheritance ("is-a") with Composition ("has-a"). Now, we will break down the "has-a" relationship into its three formal types: Association, Aggregation, and Composition. These terms describe the different ways objects can be linked and are crucial for accurate object-oriented design and modeling (especially in UML).

##### **Association ("uses-a")**

Association is the most general relationship between two objects. It signifies that two classes have a structural link, meaning one object "uses" or interacts with another. They are peers, and neither object owns the other.

*   **Lifecycle:** The lifecycles of the associated objects are **independent**. One can be created, exist, and be destroyed without affecting the other.
*   **Analogy:** A `Doctor` and a `Patient`. A doctor has many patients, and a patient can see many doctors. If a specific doctor retires, the patients continue to exist. If a patient moves away, the doctor continues to exist.
*   **Multiplicity:** Can be one-to-one, one-to-many, many-to-one, or many-to-many.
*   **Implementation:** Usually implemented by passing an object as a method parameter or holding a reference to it as an instance variable, where the referenced object's lifecycle is not managed by the containing class.

##### **Aggregation (a stronger "has-a")**

Aggregation is a specialized form of Association. It represents a "whole-part" relationship where the "part" can exist independently of the "whole".

*   **Lifecycle:** The lifecycle of the "part" object is **independent** of the "whole" object's lifecycle.
*   **Analogy:** A `Department` and its `Professors`. The department "has" professors. However, if the department is closed, the professors (the "parts") don't cease to exist; they can join another department or university.
*   **Ownership:** It's a weak ownership. The "whole" has references to its "parts," but doesn't manage their creation or destruction.
*   **UML Symbol:** A hollow (white) diamond on the "whole" class.

##### **Composition (the strongest "part-of")**

Composition is a stricter form of Aggregation. It represents a "whole-part" relationship where the "part" **cannot** exist independently of the "whole".

*   **Lifecycle:** The lifecycle of the "part" object is **dependent** on the "whole" object's lifecycle. If the "whole" is destroyed, the "parts" are destroyed with it.
*   **Analogy:** A `House` and its `Rooms`. The rooms are an integral part of the house. You cannot have a room without a house. If you demolish the house, the rooms are destroyed too.
*   **Ownership:** It's a strong ownership. The "whole" is responsible for creating and destroying its "parts".
*   **UML Symbol:** A filled (black) diamond on the "whole" class.

##### **Summary Comparison**

| Relationship | Type | Lifecycle | Ownership | Example |
| :--- | :--- | :--- | :--- | :--- |
| **Association** | uses-a | Independent | None | `Student` and `Course` |
| **Aggregation** | has-a | Independent | Weak | `Team` and `Player` |
| **Composition** | part-of | Dependent | Strong | `Order` and `OrderItem` |

---

#### **2. Example Code Snippet**

```java
// --- Association Example ---
// A Student can exist without a Course, and vice versa.
class Student {
    private String name;
    // ...
}
class Course {
    private String title;
    // The Course uses Student objects, but does not own them.
    private List<Student> students;
    // ...
}

// --- Aggregation Example ---
class Professor {
    private String name;
    public Professor(String name) { this.name = name; }
}

class Department {
    private String name;
    // Aggregation: Department has a list of Professors.
    // The Professor objects are created externally and can exist without the department.
    private List<Professor> professors;

    public Department(String name, List<Professor> professors) {
        this.name = name;
        this.professors = professors;
    }
}

// --- Composition Example ---
class Engine {
    private String type;
    // The Engine is created for a specific car and 'dies' with it.
    public Engine(String type) { this.type = type; }
    public void start() { System.out.println("Engine started."); }
}

class Car {
    private String model;
    // Composition: The Car owns its Engine. The Engine is created within the Car.
    private final Engine engine;

    public Car(String model) {
        this.model = model;
        // The lifecycle of the Engine is tied to the Car's lifecycle.
        this.engine = new Engine("V8");
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving.");
    }
}

public class RelationshipsDemo {
    public static void main(String[] args) {
        // Aggregation demo
        Professor p1 = new Professor("Dr. Smith");
        Professor p2 = new Professor("Dr. Jones");
        List<Professor> csProfessors = new ArrayList<>();
        csProfessors.add(p1);
        csProfessors.add(p2);
        Department csDept = new Department("Computer Science", csProfessors);
        // If csDept is set to null, p1 and p2 still exist.

        // Composition demo
        Car myCar = new Car("Mustang");
        myCar.drive();
        // When myCar goes out of scope and is garbage collected, its Engine object
        // also becomes eligible for garbage collection as nothing else can reference it.
    }
}
```

---

#### **3. Mini Exercise**

Model a `Playlist` for a music streaming application.
1.  Create a `Song` class with a `title` and `artist`.
2.  Create a `Playlist` class with a `name`.
3.  Decide the relationship between `Playlist` and `Song`. Is it Association, Aggregation, or Composition? Justify your choice. (Hint: Can a `Song` exist outside of a `Playlist`? Can it belong to multiple playlists?)
4.  Implement the classes. The `Playlist` class should have a `List<Song>` and methods to `addSong()` and `playPlaylist()`. The `addSong()` method should take a `Song` object as a parameter.
5.  In `main`, create several `Song` objects, create a `Playlist`, and add the songs to it.

---

#### **4. Quiz Question**

**Question:** In an e-commerce application, an `Order` object contains several `OrderItem` objects (each representing a product, quantity, and price). An `OrderItem` cannot be created without an associated `Order`. What is the relationship between `Order` and `OrderItem`?

A) Association
B) Aggregation
C) Composition
D) Inheritance

*(Scroll down for the answer)*

...

**Answer:** C) Composition. The `OrderItem` is an integral "part-of" the `Order`. Its lifecycle is entirely dependent on the `Order`'s lifecycle. If the `Order` is deleted, all its `OrderItem`s are deleted as well.

### **Lesson 7: SOLID Principles - The Single Responsibility Principle (SRP)**

#### **1. Concept Explanation**

This lesson begins our journey into the **SOLID** principles, a set of five fundamental design principles that are the bedrock of writing maintainable, scalable, and robust object-oriented software.

The first principle is the **Single Responsibility Principle (SRP)**.

**The Principle:** *A class should have only one reason to change.*

This is one of the simplest principles to understand but can be challenging to apply correctly. It does **not** mean a class should only have one method. It means that a class should have only one primary job or responsibility. All the methods and properties within that class should be highly cohesive, meaning they are all closely related to that single purpose.

**Analogy:** Think of a chef in a kitchen. A chef's single responsibility is to cook food. They shouldn't also be responsible for taking orders from customers (a waiter's job) or washing the dishes (a dishwasher's job). If the restaurant decides to change how orders are taken (e.g., moving to tablets), the chef's work should not be affected. By separating responsibilities, the system becomes easier to manage and change.

**Core Benefits of SRP:**
*   **Reduced Complexity:** Classes are smaller, more focused, and easier to understand.
*   **Improved Maintainability:** A change related to one responsibility will not impact another. If you need to change how data is saved to a database, you won't risk breaking the business logic that calculates values.
*   **Higher Cohesion:** The elements of the class are all working together towards a common goal.
*   **Enhanced Testability:** It is much easier to write focused unit tests for a class that does only one thing.

**Common Violation (Anti-Pattern): The God Object**
A "God Object" is a class that knows too much and does too much. It often handles business logic, data persistence, user input validation, and formatting all in one place. These classes are a maintenance nightmare because a change in any one of these areas requires modifying this massive, complex class.

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating SRP**
The `Employee` class below has three distinct responsibilities: business logic (calculating pay), data persistence (saving to DB), and presentation (generating a report). It has three different reasons to change.

```java
// VIOLATES SRP
public class Employee {
    private String name;
    private double salary;
    private int hoursWorked;

    public Employee(String name, double salary, int hoursWorked) {
        this.name = name;
        this.salary = salary;
        this.hoursWorked = hoursWorked;
    }

    // Responsibility 1: Business Logic
    public double calculatePay() {
        return (salary / 2080) * hoursWorked; // 2080 is avg work hours in a year
    }

    // Responsibility 2: Data Persistence
    public void saveToDatabase() {
        // ... code to connect to a SQL database and save the employee data ...
        System.out.println("Saving " + this.name + " to the database.");
    }

    // Responsibility 3: Presentation
    public String generateReport() {
        // ... code to format the employee data into an HTML report ...
        return "<html><body><h1>Employee Report for " + this.name + "</h1></body></html>";
    }
}
```

##### **Good Example: Adhering to SRP**
We refactor the single class into three separate classes, each with a single, clear responsibility.

```java
// Class 1: A simple data object (POJO) with no other responsibilities.
// Its only reason to change is if the structure of Employee data changes.
public class EmployeeData {
    private String name;
    private double salary;
    // Getters and Setters...
}

// Class 2: Handles only the business logic of pay calculation.
// Its only reason to change is if the pay calculation rules change.
public class PayCalculator {
    public double calculatePay(EmployeeData employee) {
        // ... calculation logic ...
        return employee.getSalary() / 2080;
    }
}

// Class 3: Handles only the persistence of employee data.
// Its only reason to change is if the database schema or technology changes.
public class EmployeeRepository {
    public void save(EmployeeData employee) {
        // ... code to connect to a database and save the employee ...
        System.out.println("Saving " + employee.getName() + " to the database.");
    }
}
```
Now, if the database changes from SQL to a NoSQL database, only the `EmployeeRepository` class needs to be modified. The `PayCalculator` remains completely untouched.

---

#### **3. Mini Exercise**

You are given a single `Book` class that is responsible for storing book details, printing them to the console, and saving them to a file. This violates SRP.

```java
public class Book {
    private String title;
    private String author;
    private String text;

    // constructor and getters...

    // Responsibility 1: Managing book data (this is okay)

    // Responsibility 2: Presentation
    public void printToConsole() {
        System.out.println("Title: " + title);
        System.out.println("Author: " + author);
        System.out.println("Content: " + text);
    }

    // Responsibility 3: Persistence
    public void saveToFile(String filename) {
        // ... logic to write the book's text to a file ...
    }
}
```

Your task is to refactor this code. Create two new classes, `BookPrinter` and `BookPersistence`, and move the `printToConsole` and `saveToFile` methods into them, respectively. The new classes will take a `Book` object as a parameter to perform their actions.

---

#### **4. Quiz Question**

**Question:** Which of the following scenarios describes the most significant benefit of applying the Single Responsibility Principle?

A) The application will run faster because the classes are smaller.
B) The total number of lines of code in the project will be reduced.
C) Changing the format of a report will not require recompiling the class that handles database transactions.
D) The application will use less memory at runtime.

*(Scroll down for the answer)*

...

**Answer:** C) Changing the format of a report will not require recompiling the class that handles database transactions. This directly addresses the core idea of SRP: isolating change. By separating the responsibilities of reporting and persistence, the two are decoupled and can evolve independently.

### **Lesson 8: SOLID Principles - The Open/Closed Principle (OCP)**

#### **1. Concept Explanation**

The second SOLID principle is the **Open/Closed Principle (OCP)**.

**The Principle:** *Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.*

This means that you should be able to add new functionality to a system **without changing existing, working code**. Changing code is risky; it can introduce bugs into features that were previously stable. Adding new code is safer.

OCP is a direct application of abstraction. We achieve it by coding to interfaces or abstract classes rather than concrete implementations. By depending on abstractions, we can introduce new implementations of those abstractions (the "extension" part) without ever touching the code that uses them (the "closed" part).

**Analogy:** Think of a smartphone and its app store. The phone's core operating system is "closed for modification." You don't need to rewrite Android or iOS to add a new feature. However, it is "open for extension" through the app store. Developers can create entirely new applications that add functionality to the phone without ever touching the original OS code.

**Core Benefits of OCP:**
*   **Maintainability:** Reduces the risk of introducing bugs into existing, stable code.
*   **Flexibility & Scalability:** New features can be added by simply creating new classes and plugging them into the system.
*   **Loose Coupling:** Promotes designs where components are not tightly dependent on each other's specific implementations.

**Common Violation:** Using a series of `if/else if` or `switch` statements based on an object's type or a property. Every time you need to support a new type, you have to go back and modify this block of code, which violates the "closed for modification" rule.

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating OCP**
Imagine we have a system that calculates the area of different shapes. This implementation is not closed for modification. If we want to add a new shape, like a `Triangle`, we **must** modify the `AreaCalculator` class.

```java
// VIOLATES OCP
class Rectangle {
    public double width;
    public double height;
}

class Circle {
    public double radius;
}

// This class must be modified every time a new shape is added.
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            return rect.width * rect.height;
        }
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            return circle.radius * circle.radius * Math.PI;
        }
        // What if we add a Triangle? We have to add another 'if' block here.
        return 0;
    }
}
```

##### **Good Example: Adhering to OCP**
We refactor the design to depend on an abstraction (`Shape` interface). The `AreaCalculator` is now "closed" because it doesn't need to change. The system is "open" because we can add new shapes by simply creating new classes that implement the `Shape` interface.

```java
// 1. Define an abstraction (the contract)
interface Shape {
    double calculateArea();
}

// 2. Create concrete implementations
class RectangleV2 implements Shape {
    public double width;
    public double height;
    @Override
    public double calculateArea() {
        return width * height;
    }
}

class CircleV2 implements Shape {
    public double radius;
    @Override
    public double calculateArea() {
        return radius * radius * Math.PI;
    }
}

// NEW SHAPE: We can add this without touching any existing code.
class Triangle implements Shape {
    public double base;
    public double height;
    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// 3. The high-level module depends only on the abstraction.
// This class is now CLOSED for modification but OPEN for extension.
class AreaCalculatorV2 {
    public double calculateArea(Shape shape) {
        // No more if/else! It just calls the method on the abstraction.
        return shape.calculateArea();
    }
}
```

---

#### **3. Mini Exercise**

You have a `NotificationService` that sends different types of notifications. The current implementation violates OCP.

```java
public class NotificationService {
    public void sendNotification(String type, String message) {
        if (type.equals("email")) {
            System.out.println("Sending Email: " + message);
        } else if (type.equals("sms")) {
            System.out.println("Sending SMS: " + message);
        }
    }
}
```

Your task is to refactor this code to follow the Open/Closed Principle.
1.  Create a `NotificationProvider` interface with a `send(String message)` method.
2.  Create two concrete classes, `EmailProvider` and `SmsProvider`, that implement this interface.
3.  Modify the `NotificationService` so that its `sendNotification` method takes a `NotificationProvider` object as a parameter and calls its `send` method.
4.  Show how you could easily add a `PushNotificationProvider` without changing the `NotificationService` class.

---

#### **4. Quiz Question**

**Question:** A system processes payments. The main `PaymentProcessor` class has a method `processPayment(PaymentDetails details)` that contains a large `switch` statement based on `details.getPaymentType()` (e.g., "CREDIT_CARD", "PAYPAL", "BITCOIN"). Which SOLID principle is this design most clearly violating?

A) Single Responsibility Principle
B) Open/Closed Principle
C) Liskov Substitution Principle
D) Interface Segregation Principle

*(Scroll down for the answer)*

...

**Answer:** B) Open/Closed Principle. Every time a new payment method (like "APPLE_PAY") is introduced, the developer must modify the existing `PaymentProcessor` class by adding a new `case` to the `switch` statement. This violates the "closed for modification" rule.

### **Lesson 9: SOLID Principles - The Liskov Substitution Principle (LSP)**

#### **1. Concept Explanation**

The third SOLID principle is the **Liskov Substitution Principle (LSP)**, named after computer scientist Barbara Liskov.

**The Principle:** *Subtypes must be substitutable for their base types.*

This means that if you have a piece of code that works with a base class (or interface), it should also be able to work with any of its subclasses without knowing it. The subclass should not do anything that the client code wouldn't expect from the base class. In essence, a subclass should extend the functionality of the parent class, not narrow it or change its fundamental behavior.

**Analogy:** A classic example is the "Square is a Rectangle" problem. Mathematically, a square *is a* rectangle. So, it's tempting to model this with inheritance: `class Square extends Rectangle`.

A `Rectangle` has `setWidth(int width)` and `setHeight(int height)` methods. A user of a `Rectangle` object expects to be able to set the width and height independently.

`Rectangle r = new Rectangle();`
`r.setWidth(5);`
`r.setHeight(10);`
`assert r.getArea() == 50; // This is a reasonable expectation.`

Now, if we substitute a `Square` object for the `Rectangle`, this expectation is broken. To maintain the "squareness," the `Square` class must force width and height to be the same.

`Rectangle r = new Square(); // Substitution`
`r.setWidth(5);`
`r.setHeight(10); // This must also change the width to 10 to keep it a square!`
`assert r.getArea() == 50; // FAILS! The area is now 100.`

The `Square` object is not a valid substitute for a `Rectangle` because it changes the behavior (the contract) of the base class. This is a violation of LSP.

**Rules for Compliance (Behavioral Subtyping):**
A subtype must adhere to the contract of its supertype. This includes:
*   **Preconditions cannot be strengthened:** A subclass method should not require more from its inputs than the superclass method.
*   **Postconditions cannot be weakened:** A subclass method must guarantee at least as much in its output as the superclass method.
*   **Invariants must be preserved:** Any conditions that are always true for the superclass must also remain true for the subclass.
*   **Exceptions:** A subclass method should not throw new types of exceptions that are not part of the superclass method's signature (unless they are subtypes of the declared exceptions).

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating LSP**
Let's model a bird hierarchy. The base class `Bird` has a `fly()` method. This works for most birds, but not for flightless birds like penguins.

```java
// VIOLATES LSP
class Bird {
    public void fly() {
        System.out.println("This bird is flying.");
    }
}

class Sparrow extends Bird {
    // Sparrow can fly, so it's a good substitute.
}

class Penguin extends Bird {
    @Override
    public void fly() {
        // A penguin cannot fly. What do we do?
        // Option 1: Do nothing (violates expectation).
        // Option 2: Throw an exception (violates expectation).
        throw new UnsupportedOperationException("Penguins can't fly!");
    }
}

class BirdSanctuary {
    // This method expects any Bird to be able to fly.
    public void makeBirdsFly(List<Bird> birds) {
        for (Bird bird : birds) {
            try {
                bird.fly(); // This will crash when it gets to the Penguin.
            } catch (UnsupportedOperationException e) {
                System.out.println("Oops, found a bird that can't fly.");
            }
        }
    }
}
```
The `BirdSanctuary` client code is forced to handle a special case for `Penguin`, which means `Penguin` is not a substitutable subtype of `Bird`.

##### **Good Example: Adhering to LSP**
We solve this by creating a more accurate abstraction. Instead of assuming all birds can fly, we separate the flying behavior into its own interface or a separate subclass.

```java
// Base class for all birds, without the fly() method.
class BirdV2 {
    public void eat() {
        System.out.println("This bird is eating.");
    }
}

// An interface for only the birds that can fly.
interface FlyingBird {
    void fly();
}

// Sparrow now implements the flying behavior.
class SparrowV2 extends BirdV2 implements FlyingBird {
    @Override
    public void fly() {
        System.out.println("Sparrow is flying high.");
    }
}

// Penguin does not implement the flying behavior.
class PenguinV2 extends BirdV2 {
    public void swim() {
        System.out.println("Penguin is swimming.");
    }
}

class BirdSanctuaryV2 {
    // This method now only accepts birds that are GUARANTEED to be able to fly.
    // It no longer needs error handling. The contract is clear.
    public void makeBirdsFly(List<FlyingBird> flyingBirds) {
        for (FlyingBird bird : flyingBirds) {
            bird.fly();
        }
    }
}
```
This new design is robust and adheres to LSP. Client code that needs flying behavior will ask for a `FlyingBird`, and code that works with any bird will ask for a `BirdV2`. There are no more broken expectations.

---

#### **3. Mini Exercise**

You are designing a system to manage user accounts. You have a `PremiumUser` class that extends a `User` class.

The `User` class has a method `accessFreeContent()`.
The `PremiumUser` class also has a method `accessPremiumContent()`.

Now, consider a method in the `User` class called `submitReview()`. The rule is that any user can submit a review.

A new requirement comes in: "Free users can submit reviews, but they are held for moderation. Premium user reviews are posted instantly." A developer implements this by overriding `submitReview()` in the `PremiumUser` class.

However, a different developer implements `submitReview()` in the `User` class to throw an `AccountNotActiveException` if the user's account is suspended.

Does the `PremiumUser`'s implementation of `submitReview()` potentially violate LSP with respect to the exception handling? Explain why or why not. What is a better way to design this?

---

#### **4. Quiz Question**

**Question:** Which of the following is the most direct violation of the Liskov Substitution Principle?

A) A subclass adds a new public method that was not in the superclass.
B) A subclass method overrides a superclass method but accepts a more generic parameter type.
C) A subclass method overrides a superclass method and throws a new, checked `Exception` that the superclass method did not declare.
D) A subclass method overrides a superclass method and has a more restrictive access modifier (e.g., overriding a `public` method with a `protected` one).

*(Scroll down for the answer)*

...

**Answer:** C) A subclass method overrides a superclass method and throws a new, checked `Exception` that the superclass method did not declare. Client code written to handle the superclass would not be prepared to catch this new exception, breaking the "substitutability" of the subclass. Option D is a violation of Java's override rules and would not compile in the first place. Option A is perfectly fine (extension). Option B is related to method signatures and would be considered an overload, not an override.

### **Lesson 10: SOLID Principles - The Interface Segregation Principle (ISP)**

#### **1. Concept Explanation**

The fourth SOLID principle is the **Interface Segregation Principle (ISP)**.

**The Principle:** *Clients should not be forced to depend on interfaces they do not use.*

This principle addresses the problem of "fat" or "polluted" interfaces. A fat interface is a single, large interface that contains many methods serving different purposes. If a class needs to perform just one of those purposes, it is forced to implement the entire interface, often leaving many methods empty or throwing exceptions.

ISP advises that it is better to break down large interfaces into smaller, more specific ones, each tailored to a particular client or role. These are often called "role interfaces."

**Analogy:** Imagine a restaurant menu that is a single, 50-page book containing breakfast, lunch, dinner, drinks, and desserts. If you only want to order a coffee, you are still handed this massive, cumbersome book. It would be much better to have separate, smaller menus: a drink menu, a dessert menu, etc. You are given only what you need.

**Core Benefits of ISP:**
*   **High Cohesion & Low Coupling:** Interfaces are more focused and cohesive. Classes are only coupled to the methods they actually care about.
*   **Improved Readability and Maintainability:** Smaller interfaces are easier to understand. Changes to one role interface don't affect clients that don't use it.
*   **Avoids "Empty" Implementations:** Classes are no longer forced to implement methods that are irrelevant to them, leading to cleaner code.

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating ISP**
Here we have a single, fat interface for a `Machine`. A modern multi-function printer can do everything, but a simple old printer cannot scan or fax.

```java
// VIOLATES ISP: A "fat" interface
interface Machine {
    void print(Document d);
    void scan(Document d);
    void fax(Document d);
}

// This class is fine, as it can perform all functions.
class MultiFunctionPrinter implements Machine {
    public void print(Document d) { /* ... */ }
    public void scan(Document d) { /* ... */ }
    public void fax(Document d) { /* ... */ }
}

// This class is forced to implement methods it cannot support.
class OldFashionedPrinter implements Machine {
    public void print(Document d) {
        // This is the only method that makes sense.
        System.out.println("Printing document...");
    }

    public void scan(Document d) {
        // Problem: This printer can't scan.
        throw new UnsupportedOperationException("Scan not supported.");
    }

    public void fax(Document d) {
        // Problem: This printer can't fax.
        throw new UnsupportedOperationException("Fax not supported.");
    }
}
```

##### **Good Example: Adhering to ISP**
We segregate the fat `Machine` interface into smaller, role-specific interfaces.

```java
// 1. Segregate the interface into smaller, cohesive roles.
interface Printer {
    void print(Document d);
}

interface Scanner {
    void scan(Document d);
}

interface Fax {
    void fax(Document d);
}

// 2. Classes now implement only the interfaces they need.

// A MultiFunctionDevice can be composed of multiple roles.
class ModernPrinter implements Printer, Scanner {
    public void print(Document d) { /* ... */ }
    public void scan(Document d) { /* ... */ }
}

// An OldFashionedPrinter only needs to be a Printer.
// It is no longer forced to know about scanning or faxing.
class SimplePrinter implements Printer {
    public void print(Document d) {
        System.out.println("Printing document...");
    }
}

// 3. Client code can now depend on the specific abstraction it needs.
class PrintManager {
    private final Printer printer;

    public PrintManager(Printer printer) {
        this.printer = printer;
    }

    public void executePrintJob(Document d) {
        printer.print(d); // This manager only cares about printing.
    }
}
```

---

#### **3. Mini Exercise**

You are designing an interface for a data access object (DAO) that will interact with a database. A developer created the following fat interface:

```java
interface DataAccess {
    void create(Object entity);
    Object read(int id);
    void update(Object entity);
    void delete(int id);
    List<Object> searchByQuery(String query);
}
```
This violates ISP because some clients might only need to read data (e.g., a reporting service), while others might be write-only (e.g., a logging service).

Your task is to refactor this design.
1.  Break the `DataAccess` interface into smaller, more logical role interfaces. A common pattern for this is CRUD (Create, Read, Update, Delete).
2.  Create a class `ReadOnlyRepository` that only needs to implement the reading/searching functionality.
3.  Create a class `FullAccessRepository` that implements all the functionalities.

---

#### **4. Quiz Question**

**Question:** Your team has an interface called `UserActions` with methods `viewProfile()`, `editProfile()`, `changePassword()`, and `deleteAccount()`. You need to implement a `GuestUser` class that should only be able to view profiles. Which is the best approach according to ISP?

A) Implement the `UserActions` interface in `GuestUser` and have the `editProfile`, `changePassword`, and `deleteAccount` methods throw an `AccessDeniedException`.
B) Create a new interface `ProfileViewer` with only the `viewProfile()` method, and have `GuestUser` implement that.
C) Make the `UserActions` interface an abstract class so `GuestUser` can inherit only the methods it needs.
D) Do not use an interface and just implement the `viewProfile()` method directly in the `GuestUser` class.

*(Scroll down for the answer)*

...

**Answer:** B) Create a new interface `ProfileViewer` with only the `viewProfile()` method, and have `GuestUser` implement that. This is the textbook application of ISP. It segregates the fat `UserActions` interface into a smaller, role-specific interface that the client (`GuestUser`) actually needs, without forcing it to depend on methods it doesn't use.

### **Lesson 11: SOLID Principles - The Dependency Inversion Principle (DIP)**

#### **1. Concept Explanation**

This is the final principle in the SOLID acronym: the **Dependency Inversion Principle (DIP)**. It is arguably the most impactful for creating decoupled, flexible, and testable systems.

**The Principle (in two parts):**
1.  *High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces).*
2.  *Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.*

Let's break this down:
*   **High-level Modules:** These are the parts of your application that contain the core business logic and policy. They represent the "what" your application does (e.g., a `ReportGenerator` service).
*   **Low-level Modules:** These are the parts that handle the implementation details and infrastructure. They represent the "how" things get done (e.g., a `DatabaseReader` or a `FileSystemWriter`).

A traditional, tightly-coupled design has the high-level module directly creating and calling the low-level module.
`ReportGenerator` → `DatabaseReader`

This creates a rigid system. If you want to change the data source from a database to a web API, you must modify the `ReportGenerator`. This violates the Open/Closed Principle.

DIP "inverts" this dependency. Instead of the high-level module depending on the low-level one, **both** depend on an abstraction (an interface) that is typically defined by the high-level module.

`ReportGenerator` → `IDataSource` ← `DatabaseReader`

The arrow from `DatabaseReader` to `IDataSource` signifies that the concrete implementation now "depends" on (implements) the abstraction defined by the high-level module. The dependency has been inverted.

**Analogy:** A wall outlet and a lamp. The lamp (high-level module) does not depend on the specific power plant (low-level module) generating the electricity. Instead, both the lamp and the power plant depend on a shared abstraction: the standard wall socket specification (voltage, plug shape). The lamp can be plugged into any outlet that conforms to this standard, and any power source can provide electricity to it. The dependency is on the abstract contract, not the concrete implementation.

**DIP and Dependency Injection (DI):**
DIP is the **principle**. Dependency Injection is a common **design pattern** used to implement it. DI is the process of providing a class with its dependencies from an external source, rather than having the class create them itself. This is often done via constructor injection, setter injection, or through a DI framework like Spring.

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating DIP**
The high-level `PasswordManager` is directly coupled to the low-level `FileSystemRepository`. It's not reusable with a different storage mechanism and is hard to test without a real file system.

```java
// VIOLATES DIP

// Low-level module
class FileSystemRepository {
    public void save(String password) {
        // ... logic to write the password to a file ...
        System.out.println("Saved to file: " + password);
    }
}

// High-level module
class PasswordManager {
    // Direct dependency on a concrete low-level module
    private final FileSystemRepository repository;

    public PasswordManager() {
        this.repository = new FileSystemRepository(); // TIGHT COUPLING
    }

    public void savePassword(String password) {
        repository.save(password);
    }
}
```

##### **Good Example: Adhering to DIP**
We introduce an interface (`PasswordRepository`) that the `PasswordManager` depends on. The concrete storage mechanism is "injected" from the outside.

```java
// 1. Define the abstraction (the contract). This is owned by the high-level layer.
interface PasswordRepository {
    void save(String password);
}

// 2. The low-level module now depends on the abstraction.
class FileSystemRepositoryImpl implements PasswordRepository {
    @Override
    public void save(String password) {
        System.out.println("Saved to file: " + password);
    }
}

// We can easily add another implementation.
class DatabaseRepositoryImpl implements PasswordRepository {
    @Override
    public void save(String password) {
        System.out.println("Saved to database: " + password);
    }
}

// 3. The high-level module depends only on the abstraction.
class PasswordManagerV2 {
    // Dependency is on the interface, not the concrete class.
    private final PasswordRepository repository;

    // The dependency is "injected" via the constructor.
    public PasswordManagerV2(PasswordRepository repository) {
        this.repository = repository;
    }

    public void savePassword(String password) {
        repository.save(password);
    }
}

// Main application wires everything together (The "Assembler" or "DI Container" role)
class Application {
    public static void main(String[] args) {
        // We can choose the implementation at runtime.
        PasswordRepository repo = new DatabaseRepositoryImpl();
        PasswordManagerV2 manager = new PasswordManagerV2(repo);
        manager.savePassword("mySecret123");
    }
}
```

---

#### **3. Mini Exercise**

You have a `ContentCopier` class that reads from the keyboard and writes to a printer. This is a classic example of tight coupling.

```java
// High-level policy: Copy content
public class ContentCopier {
    public void copy() {
        KeyboardReader reader = new KeyboardReader();
        PrinterWriter writer = new PrinterWriter();
        String input = reader.read();
        writer.write(input);
    }
}
```

Your task is to refactor this `ContentCopier` to follow DIP.
1.  Define two abstractions (interfaces): `IReader` and `IWriter`.
2.  Modify the `ContentCopier` so that it depends on these interfaces, receiving them in its constructor.
3.  Create concrete implementations `KeyboardReader` and `PrinterWriter` that implement these new interfaces.
4.  Show how this refactoring makes it trivial to create a `ContentCopier` that copies from a `FileReader` to a `FileWriter` without changing the `ContentCopier` class itself.

---

#### **4. Quiz Question**

**Question:** Which of the following statements best describes the relationship between Dependency Inversion (DIP) and Dependency Injection (DI)?

A) They are two completely unrelated concepts.
B) They are the same thing; the names are interchangeable.
C) DIP is a design principle, while DI is a design pattern used to achieve that principle.
D) DI is a design principle, and DIP is the pattern used to implement it.

*(Scroll down for the answer)*

...

**Answer:** C) DIP is a design principle, while DI is a design pattern used to achieve that principle. The principle (DIP) states *what* you should do (depend on abstractions), and the pattern (DI) provides a mechanism for *how* you can do it (by having dependencies provided from an external source).

### **Lesson 12: Design Principles - DRY, KISS, and YAGNI**

#### **1. Concept Explanation**

This lesson covers a trio of pragmatic design principles that act as guiding philosophies for everyday coding. While SOLID principles focus on the structure of object-oriented systems, these principles guide the mindset and approach to writing individual lines and blocks of code.

##### **Don't Repeat Yourself (DRY)**

*   **The Principle:** *Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.*
*   **In Practice:** This is commonly interpreted as "don't copy and paste code." If you find yourself writing the same block of logic in multiple places, you are violating DRY. The problem with duplicated code is that if a bug is found or a requirement changes, you have to remember to fix it in *every single place*. Forgetting even one leads to an inconsistent and buggy system.
*   **The Solution:** Abstraction. Centralize the duplicated logic into a single place, such as a new method, a helper class, or a base class, and have all other locations call this single source of truth.
*   **Pitfall (Accidental Duplication):** Be cautious of abstracting code that *looks* similar now but represents different business concepts. Forcing them into a single abstraction can create a worse problem if they later need to evolve independently.

##### **Keep It Simple, Stupid (KISS)**

*   **The Principle:** *Most systems work best if they are kept simple rather than made complicated; therefore, simplicity should be a key goal in design, and unnecessary complexity should be avoided.*
*   **In Practice:** Always choose the simplest solution that effectively solves the problem. Avoid over-engineering. Don't use a complex design pattern if a simple conditional statement will do. Don't write clever, obscure code that is hard for others (or your future self) to understand.
*   **Analogy:** If you need to hammer a nail, use a hammer. Don't build a complex, laser-guided, automated nailing machine. The simplest tool is often the best.
*   **The Goal:** Code that is easy to read, understand, and maintain. Simplicity reduces the cognitive load on developers and makes the system less prone to bugs.

##### **You Ain't Gonna Need It (YAGNI)**

*   **The Principle:** *Always implement things when you actually need them, never when you just foresee that you need them.*
*   **In Practice:** This principle fights against the developer's temptation to add functionality based on speculation about the future. Building features that are not required by the current set of user stories or tasks adds unnecessary complexity and costs development time that could be spent on real requirements.
*   **Analogy:** Packing for a trip. YAGNI is like packing only what you know you will need for your destination. The opposite is packing a winter coat, a swimsuit, and hiking gear "just in case," making your suitcase heavy and cumbersome for a simple business trip to the city.
*   **The Goal:** To save time and effort, and to keep the codebase lean and focused on delivering actual business value. It reinforces the KISS principle by preventing speculative complexity.

---

#### **2. Example Code Snippet**

##### **Before: Violating DRY, KISS, and YAGNI**
This code validates and processes two different types of orders. The validation logic is duplicated (violates DRY). The code is also slightly more complex than needed and includes a speculative logging feature (violating KISS and YAGNI).

```java
// VIOLATES PRINCIPLES
public class OrderProcessor {

    // Method for regular customer orders
    public void processCustomerOrder(List<Product> products) {
        // --- DUPLICATED LOGIC START ---
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return;
            }
        }
        // --- DUPLICATED LOGIC END ---

        // Speculative feature: maybe we'll need XML logging later? (YAGNI)
        logToXmlFile(products);

        System.out.println("Processing customer order...");
        // ... processing logic ...
    }

    // Method for internal business orders
    public void processBusinessOrder(List<Product> products) {
        // --- DUPLICATED LOGIC START ---
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return;
            }
        }
        // --- DUPLICATED LOGIC END ---

        System.out.println("Processing business order...");
        // ... processing logic ...
    }

    private void logToXmlFile(List<Product> products) {
        // This feature isn't required yet.
        System.out.println("Speculative logging to XML...");
    }
}
```

##### **After: Adhering to Principles**
The code is refactored to be simpler and more maintainable.

```java
// ADHERES TO PRINCIPLES
public class OrderProcessorV2 {

    // Private helper method to centralize validation (DRY)
    private boolean isOrderValid(List<Product> products) {
        if (products == null || products.isEmpty()) {
            System.out.println("Order is empty.");
            return false;
        }
        for (Product p : products) {
            if (p.getPrice() < 0) {
                System.out.println("Invalid price detected.");
                return false;
            }
        }
        return true;
    }

    // Simplified public methods (KISS)
    public void processCustomerOrder(List<Product> products) {
        if (!isOrderValid(products)) {
            return;
        }
        System.out.println("Processing customer order...");
        // ... processing logic ...
    }

    public void processBusinessOrder(List<Product> products) {
        if (!isOrderValid(products)) {
            return;
        }
        System.out.println("Processing business order...");
        // ... processing logic ...
    }

    // The speculative logToXmlFile method has been removed entirely (YAGNI).
}
```

---

#### **3. Mini Exercise**

You have a class with two methods: one to export user data to a CSV file and another to export article data to a CSV file.

```java
public class DataExporter {
    public void exportUsersToCsv(List<User> users) {
        // Step 1: Open a file stream
        System.out.println("Opening file 'users.csv'...");
        // Step 2: Write header row
        System.out.println("Writing header: ID,Name,Email");
        // Step 3: Loop through users and format each as a CSV row
        for (User user : users) {
            System.out.println(user.getId() + "," + user.getName() + "," + user.getEmail());
        }
        // Step 4: Close the file stream
        System.out.println("Closing file.");
    }

    public void exportArticlesToCsv(List<Article> articles) {
        // Step 1: Open a file stream
        System.out.println("Opening file 'articles.csv'...");
        // Step 2: Write header row
        System.out.println("Writing header: ID,Title,Author");
        // Step 3: Loop through articles and format each as a CSV row
        for (Article article : articles) {
            System.out.println(article.getId() + "," + article.getTitle() + "," + article.getAuthor());
        }
        // Step 4: Close the file stream
        System.out.println("Closing file.");
    }
}
```

This code violates DRY. The logic for opening/closing the file and looping is duplicated. Your task is to refactor this.
1.  Create an interface `CsvExportable` with two methods: `getCsvHeader()` and `toCsvRow()`.
2.  Make the `User` and `Article` classes implement this new interface.
3.  Create a single, generic method `exportToCsv(List<? extends CsvExportable> items, String filename)` that contains the shared logic and uses the interface methods to get the specific data.

---

#### **4. Quiz Question**

**Question:** A developer is building a user profile page. They decide to add a complex, real-time avatar customization feature using WebGL, even though the project requirements only specify a simple image upload. The developer argues, "The client will probably ask for this in the future." Which principle is the developer most clearly violating?

A) DRY (Don't Repeat Yourself)
B) KISS (Keep It Simple, Stupid)
C) YAGNI (You Ain't Gonna Need It)
D) Both B and C

*(Scroll down for the answer)*

...

**Answer:** D) Both B and C. It is a primary violation of YAGNI because the feature is purely speculative and not currently needed. It is also a violation of KISS because they are choosing a highly complex solution (WebGL editor) over the simple required one (image upload), adding unnecessary complexity to the system.

### **Lesson 13: Cohesion and Coupling**

#### **1. Concept Explanation**

Cohesion and Coupling are two of the most fundamental concepts in software design, predating even object-oriented programming. They are metrics used to evaluate how well-designed a module (a class, a package, a microservice) is. The universal goal is to achieve **High Cohesion** and **Low Coupling**.

##### **Cohesion (The measure of "relatedness" *inside* a module)**

Cohesion measures how closely related and focused the responsibilities of a single module are.

*   **High Cohesion (Good):** A module with high cohesion has a clear, singular purpose. All of its elements (methods, properties) work together to achieve that one goal. This is a direct consequence of following the **Single Responsibility Principle**.
    *   **Analogy:** A well-organized toolbox where the top drawer contains only screwdrivers, the middle drawer contains only wrenches, and the bottom drawer contains only hammers. Each drawer is highly cohesive.
    *   **Benefits:** Easier to understand, maintain, and reuse.

*   **Low Cohesion (Bad):** A module with low cohesion does many unrelated things. Its responsibilities are scattered and unfocused. This is a characteristic of a "God Object."
    *   **Analogy:** A junk drawer where you find screwdrivers, batteries, old keys, rubber bands, and ketchup packets all mixed together. The drawer has very low cohesion.
    *   **Problems:** Hard to understand, difficult to maintain (a change in one responsibility might break another), and impossible to reuse.

##### **Coupling (The measure of "dependence" *between* modules)**

Coupling measures the degree to which one module depends on another.

*   **Low Coupling (Good / Loose Coupling):** Modules are largely independent. A change in one module has little or no impact on the others. They communicate through stable, well-defined interfaces (abstractions). This is a direct consequence of following the **Dependency Inversion Principle** and the **Open/Closed Principle**.
    *   **Analogy:** A USB port. Your computer (module A) is not tightly coupled to your keyboard (module B). You can swap out any keyboard for another as long as it uses the standard USB interface. The computer doesn't need to know the internal details of how the keyboard is made.
    *   **Benefits:** Promotes flexibility, scalability, and easier testing (modules can be tested in isolation).

*   **High Coupling (Bad / Tight Coupling):** Modules are highly dependent on each other's internal implementation details. A change in one module often requires a cascade of changes in other modules.
    *   **Analogy:** Soldering a specific keyboard's wires directly onto a computer's motherboard. They are now tightly coupled. If the keyboard breaks, you have to perform major surgery on the motherboard to fix or replace it.
    *   **Problems:** Creates a "house of cards" system where changes are risky and difficult. Reduces reusability and makes parallel development harder.

##### **The Trade-off and Relationship**

The goal is always **HIGH COHESION** and **LOW COUPLING**.
*   Following SRP leads to **high cohesion**.
*   Following DIP and OCP leads to **low coupling**.

These two concepts work together. By breaking a system into small, highly cohesive modules (each with a single responsibility), you make it easier to manage the dependencies between them, which naturally leads to lower coupling.

---

#### **2. Example Code Snippet**

##### **Bad Example: Low Cohesion and High Coupling**

```java
// LOW COHESION: This class does everything - business logic, data access, formatting.
// HIGH COUPLING: The ReportGenerator is tightly coupled to the MySqlConnection.
class ReportGenerator {
    private MySqlConnection dbConnection; // Direct dependency on a concrete class

    public ReportGenerator() {
        // The high-level module creates the low-level one.
        this.dbConnection = new MySqlConnection("connection_string");
    }

    // A mix of unrelated responsibilities...
    public List<User> fetchUsersFromDatabase() {
        // ... logic to query users ...
        return dbConnection.query("SELECT * FROM users");
    }

    public String formatReportAsHtml(List<User> users) {
        // ... logic to create an HTML table ...
        return "<html>...</html>";
    }

    public void emailReport(String htmlReport) {
        // ... logic to connect to an SMTP server and send email ...
    }
}
```

##### **Good Example: High Cohesion and Low Coupling**

```java
// --- HIGH COHESION: Each class has a single, well-defined responsibility. ---

// 1. User data object (POJO)
class User { /* ... */ }

// 2. Abstraction for data access
interface UserRepository {
    List<User> findAll();
}

// 3. Low-level data access implementation
class MySqlUserRepository implements UserRepository {
    @Override
    public List<User> findAll() { /* ... query logic ... */ return null; }
}

// 4. Report formatting
class HtmlFormatter {
    public String format(List<User> users) { /* ... formatting logic ... */ return ""; }
}

// 5. Emailing
class EmailService {
    public void send(String content) { /* ... email logic ... */ }
}

// --- LOW COUPLING: The main class depends on abstractions, not concretions. ---
class ReportService {
    private final UserRepository repository; // Depends on interface
    private final HtmlFormatter formatter;     // Depends on concrete class (can be abstracted too!)
    private final EmailService emailer;       // Depends on concrete class

    // Dependencies are injected (DIP)
    public ReportService(UserRepository repository, HtmlFormatter formatter, EmailService emailer) {
        this.repository = repository;
        this.formatter = formatter;
        this.emailer = emailer;
    }

    public void generateAndSendReport() {
        List<User> users = repository.findAll();
        String htmlReport = formatter.format(users);
        emailer.send(htmlReport);
    }
}
```

---

#### **3. Mini Exercise**

Analyze the following `OrderManager` class.
1.  Identify its different responsibilities. Is it highly cohesive?
2.  Identify its direct dependencies. Is it loosely or tightly coupled?
3.  Refactor the class into smaller, more cohesive classes that are loosely coupled. Define interfaces for the dependencies and use constructor injection.

```java
public class OrderManager {
    public void processOrder(Order order) {
        // Responsibility 1: Validate the order
        if (order.getItems().isEmpty()) {
            System.out.println("Order is invalid.");
            return;
        }

        // Responsibility 2: Process payment with a specific service
        StripePaymentGateway gateway = new StripePaymentGateway();
        gateway.charge(order.getTotal());

        // Responsibility 3: Update inventory in a specific database
        MySqlDatabase db = new MySqlDatabase();
        for (Item item : order.getItems()) {
            db.execute("UPDATE inventory SET stock = stock - 1 WHERE id = " + item.getId());
        }

        // Responsibility 4: Send a confirmation email
        System.out.println("Sending email to " + order.getCustomerEmail());
    }
}
```

---

#### **4. Quiz Question**

**Question:** If modifying a class `A` frequently forces you to make changes to another class `B`, what does this imply about the relationship between `A` and `B`?

A) They have low cohesion.
B) They have high coupling.
C) They have high cohesion.
D) They have low coupling.

*(Scroll down for the answer)*

...

**Answer:** B) They have high coupling. Tight coupling means that changes in one module ripple through and require changes in other dependent modules. This is the classic symptom of a highly coupled design.

### **Lesson 14: Encapsulation vs. Data Hiding & The Law of Demeter**

#### **1. Concept Explanation**

This lesson clarifies two closely related concepts that govern how objects should protect their state and interact with each other to maintain low coupling.

##### **Encapsulation vs. Data Hiding**

These terms are often used interchangeably, but they have distinct meanings.

*   **Encapsulation** is the **mechanism** of bundling data (fields) and the methods that operate on that data into a single unit (a class). It's a structural concept. You can have a fully encapsulated class with all its fields and methods being `public`.

*   **Data Hiding** is the **principle** of concealing the internal state and implementation details of an object from the outside world. The goal is to prevent direct, uncontrolled access to an object's data. This is achieved by applying access modifiers (like `private`) to the fields and exposing the state only through public methods (getters/setters).

**The Relationship:** Encapsulation *enables* Data Hiding. You first bundle everything together (encapsulation), and then you apply access control to hide the parts you don't want exposed (data hiding). A well-designed class uses encapsulation to achieve data hiding.

```java
// This class is ENCAPSULATED. Data and methods are bundled.
// However, it does NOT practice DATA HIDING because the field is public.
public class PoorlyDesignedClock {
    public int hour; // Direct access is allowed
    public void tick() { /* ... */ }
}

// This class is both ENCAPSULATED and practices DATA HIDING.
public class WellDesignedClock {
    private int hour; // Access is restricted
    public int getHour() { return hour; } // Controlled access
    public void tick() { /* ... */ }
}
```

##### **The Law of Demeter (LoD) or The Principle of Least Knowledge**

This principle provides a specific guideline for building loosely coupled systems. It is often summarized as: **"Only talk to your immediate friends."**

An object's method should only call methods belonging to:
1.  The object itself (`this`).
2.  Objects passed in as parameters to the method.
3.  Any object it creates or instantiates directly.
4.  The object's direct component objects (its instance variables).

It should **not** call methods on an object that was returned from another method call. This is because doing so creates a dependency not just on the object you are talking to, but also on the internal structure of that object.

**The "Train Wreck" Anti-Pattern:**
Code that violates the Law of Demeter often looks like a "train wreck" because of the multiple chained method calls:
`String managerName = employee.getDepartment().getManager().getName();`

This line of code couples the current class to `Employee`, `Department`, and `Manager`. If the `Department` class is ever changed to no longer have a `getManager()` method, this code breaks, even though it was only trying to talk to an `Employee`.

---

#### **2. Example Code Snippet**

##### **Bad Example: Violating the Law of Demeter**
A `Paperboy` needs to collect payment from a `Customer`. The `Paperboy` reaches through the `Customer` to get their wallet and take the money directly.

```java
// VIOLATES LoD
class Money { /* ... amount ... */ }

class Wallet {
    private Money money;
    public Money getMoney() { return money; }
    public void debit(float amount) { /* ... deduct money ... */ }
}

class Customer {
    private Wallet wallet;
    // Exposing the internal component (the wallet)
    public Wallet getWallet() { return wallet; }
}

class Paperboy {
    public void collectPayment(Customer customer, float paymentAmount) {
        // This is a "train wreck" and a violation of LoD.
        // The Paperboy needs to know that a Customer has a Wallet.
        Wallet wallet = customer.getWallet();
        wallet.debit(paymentAmount);
        System.out.println("Payment collected successfully.");
    }
}
```

##### **Good Example: Adhering to the Law of Demeter**
The `Paperboy` simply tells the `Customer` what it wants (the payment). The `Customer` is responsible for handling the internal logic of how that payment is made.

```java
// ADHERES TO LoD
class MoneyV2 { /* ... */ }

class WalletV2 {
    private MoneyV2 money;
    public void debit(float amount) { /* ... */ }
}

class CustomerV2 {
    private WalletV2 wallet;

    // The internal structure is hidden.
    // The customer provides a high-level service method.
    public void makePayment(float amount) {
        // The Customer delegates the call to its immediate friend (its wallet).
        wallet.debit(amount);
    }
}

class PaperboyV2 {
    public void collectPayment(CustomerV2 customer, float paymentAmount) {
        // Talk only to your immediate friend (the customer).
        customer.makePayment(paymentAmount);
        System.out.println("Payment collected successfully.");
    }
}
```
Now the `PaperboyV2` class is no longer coupled to the `WalletV2` class. The `CustomerV2`'s internal structure can be changed (e.g., they could pay from a bank account instead of a wallet) without ever affecting the `PaperboyV2` class.

---

#### **3. Mini Exercise**

You have a `Car` that needs to check the pressure of its tires. The following code violates the Law of Demeter.

```java
class Tire {
    private double pressure;
    public double getPressure() { return pressure; }
}

class Wheel {
    private Tire tire;
    public Tire getTire() { return tire; }
}

class Car {
    private List<Wheel> wheels;

    public boolean checkTirePressure() {
        for (Wheel wheel : wheels) {
            // Violation: Reaching through Wheel to get to Tire
            if (wheel.getTire().getPressure() < 30) {
                System.out.println("Low pressure in a tire!");
                return false;
            }
        }
        return true;
    }
}
```

Your task is to refactor this code to adhere to the Law of Demeter.
1.  Add a method to the `Wheel` class that hides the `Tire`. For example, an `isPressureLow()` method.
2.  Modify the `Car`'s `checkTirePressure()` method to call this new method on its `Wheel` objects, so it no longer needs to know about the `Tire` class.

---

#### **4. Quiz Question**

**Question:** Which of the following statements best describes the primary goal of the Law of Demeter?

A) To ensure every class has only one responsibility.
B) To reduce coupling by limiting the structural information a method has about other objects.
C) To ensure that subclasses can always be substituted for their parent classes.
D) To prevent the creation of large, complex interfaces.

*(Scroll down for the answer)*

...

**Answer:** B) To reduce coupling by limiting the structural information a method has about other objects. By preventing you from "reaching through" objects, LoD forces you to depend on what an object can *do* (its public methods) rather than what it *has* (its internal structure), which is a core tenet of loose coupling.

### **Lesson 15: Immutable Classes**

#### **1. Concept Explanation**

An **immutable object** is an object whose internal state cannot be changed after it has been created. Any operation that appears to modify an immutable object actually returns a new object with the modified state, leaving the original object untouched.

The `String` class is the most famous example of an immutable class in Java. When you call `myString.toUpperCase()`, you are not changing `myString`; you are creating and returning a new string that is the uppercase version.

Designing your own classes to be immutable provides significant advantages, especially in concurrent and multi-threaded applications.

**Core Benefits of Immutability:**
1.  **Thread Safety:** Immutable objects are inherently thread-safe. Since their state never changes, they can be freely shared between multiple threads without any need for synchronization (`synchronized` blocks or locks). This eliminates a huge category of complex concurrency bugs.
2.  **Predictability and Simplicity:** The state of an immutable object is fixed and known at the time of creation. You can pass it to other methods or store it in collections with the absolute guarantee that its state will not be changed unexpectedly by some other part of the code. This makes the program much easier to reason about.
3.  **Usable as `Map` Keys and in `Set`s:** Hash-based collections like `HashMap` and `HashSet` rely on the `hashCode()` of their elements remaining constant. If you use a mutable object as a key in a `HashMap` and then change its state, its hash code might change, and you could "lose" the object in the map. Immutable objects are perfect for this role.
4.  **Caching:** Because their state is constant, their results can be easily cached. For example, the `hashCode()` of a `String` is calculated once and then cached because the string can never change.

---

#### **2. How to Create an Immutable Class**

To make a class immutable, you must follow a strict set of rules:

1.  **Declare the class as `final`:** This prevents other classes from extending it and overriding methods to change its behavior and break its immutability.
2.  **Make all fields `private` and `final`:** `private` enforces data hiding. `final` ensures that the fields can only be assigned once, inside the constructor.
3.  **Do not provide any "setter" methods:** There should be no methods that modify the instance variables.
4.  **Initialize all fields in the constructor:** All state must be set at the time of creation.
5.  **Perform defensive copies for mutable object fields:** This is the most critical and often-missed step.
    *   **In the constructor:** If a constructor parameter is a mutable object (like a `Date` or a `List`), you must create a new copy of it for your internal field. Do not just assign the reference, or the external code could still modify the object.
    *   **In any "getter" methods:** If you have a getter that returns a mutable object field, you must return a new copy of it. Do not return a reference to your internal state, or the external code could modify it.

---

#### **3. Example Code Snippet**

This example shows a properly designed immutable `User` class that contains a mutable `Date` object.

```java
import java.util.Date;
import java.util.List;
import java.util.ArrayList;

// Rule 1: Class is declared as final
public final class ImmutableUser {

    // Rule 2: Fields are private and final
    private final String username;
    private final Date registrationDate;
    private final List<String> roles;

    // Rule 4: All fields are initialized in the constructor
    public ImmutableUser(String username, Date registrationDate, List<String> roles) {
        this.username = username;

        // Rule 5 (Constructor): Perform a defensive copy of the mutable Date object.
        this.registrationDate = new Date(registrationDate.getTime());

        // Rule 5 (Constructor): Perform a defensive copy of the mutable List object.
        this.roles = new ArrayList<>(roles);
    }

    // Rule 3: No setter methods. Only getters are provided.
    public String getUsername() {
        return username;
    }

    public List<String> getRoles() {
        // Rule 5 (Getter): Return a copy, not the original reference.
        return new ArrayList<>(roles);
    }

    public Date getRegistrationDate() {
        // Rule 5 (Getter): Return a copy, not the original reference.
        return new Date(registrationDate.getTime());
    }
}

class ImmutabilityDemo {
    public static void main(String[] args) {
        // Create a mutable date to test our immutable class
        Date myDate = new Date();
        List<String> myRoles = new ArrayList<>();
        myRoles.add("ADMIN");

        ImmutableUser user = new ImmutableUser("alice", myDate, myRoles);
        System.out.println("User's initial registration date: " + user.getRegistrationDate());
        System.out.println("User's initial roles: " + user.getRoles());

        // --- Let's try to modify the state from outside ---

        // Attempt 1: Modify the original myDate object
        myDate.setTime(0); // Set to the epoch
        System.out.println("User's date after modifying original: " + user.getRegistrationDate());

        // Attempt 2: Modify the list returned by the getter
        List<String> rolesFromGetter = user.getRoles();
        rolesFromGetter.add("SUPER_USER");
        System.out.println("User's roles after modifying getter list: " + user.getRoles());

        // The state of the 'user' object remains unchanged, proving its immutability.
    }
}
```
**Output of the demo:**
The output will show that the user's registration date and roles list do **not** change, even though we tried to modify them. This is because of the defensive copies.

---

#### **4. Mini Exercise**

Create an immutable class named `CurrencyPair`.
1.  It should have two `private final String` fields: `baseCurrency` and `quoteCurrency`.
2.  Declare the class `final`.
3.  Provide a constructor to initialize the fields.
4.  Provide getters for both fields. (Since `String` is already immutable, you don't need to make defensive copies of it).
5.  Override the `equals()`, `hashCode()`, and `toString()` methods for good practice.
6.  In `main`, create an instance of `CurrencyPair` and demonstrate that it cannot be changed after creation.

---

#### **5. Quiz Question**

**Question:** You are creating an immutable class `Product` which has a field `private final List<String> tags;`. Which of the following getter implementations correctly preserves the immutability of the `Product` class?

A)
```java
public List<String> getTags() {
    return this.tags;
}
```

B)
```java
public List<String> getTags() {
    return Collections.unmodifiableList(this.tags);
}
```

C)
```java
public void getTags(List<String> destinationList) {
    destinationList.addAll(this.tags);
}
```

D)
```java
public String[] getTags() {
    return this.tags.toArray(new String[0]);
}
```

*(Scroll down for the answer)*

...

**Answer:** B), and arguably D) as well, are correct ways to preserve immutability.
*   **B) `Collections.unmodifiableList(this.tags)`** is the most common and idiomatic way. It returns a wrapper around the original list that throws an `UnsupportedOperationException` if any modification (like `add` or `remove`) is attempted.
*   **D) `this.tags.toArray(new String[0])`** is also correct because it creates a new array containing the list's elements. The caller can modify this new array, but it will have no effect on the `Product`'s internal list. This is a form of defensive copying.
*   A) is incorrect because it returns a direct reference to the internal list, allowing it to be modified.
*   C) is an unconventional getter design and doesn't return the value directly.
### **Lesson 16: Applying OOP - Common Anti-Patterns and Refactoring**

#### **1. Concept Explanation**

Now that we have covered the core principles of good OOP design, it's equally important to learn how to recognize and fix bad design. **Anti-patterns** are common, recurring solutions to problems that are ultimately ineffective and create more issues than they solve. This lesson covers a few classic anti-patterns and the refactoring strategies to correct them.

##### **Anti-Pattern: The God Object (or "Blob")**
*   **Description:** A single, massive class that does, or knows, way too much. It violates the **Single Responsibility Principle** and often has very **low cohesion**. This object becomes the central hub for a large part of the application's logic, and everyone on the team has to edit and merge changes in this one file, leading to frequent conflicts.
*   **Symptoms:** A class with a huge number of methods and instance variables that handle unrelated tasks (e.g., business logic, data persistence, UI rendering, etc.).
*   **Refactoring Strategy:** **Decomposition**. Ruthlessly apply the Single Responsibility Principle. Identify the different responsibilities within the God Object and extract them into new, smaller, highly-cohesive classes. Use dependency injection to provide these new helper classes to the original class, which now acts as a coordinator.

##### **Anti-Pattern: Feature Envy**
*   **Description:** A method that seems more interested in the data of another class than its own. It makes multiple getter calls to another object to retrieve its data and then performs some logic on that data. This is a sign of poor responsibility allocation and leads to **high coupling**.
*   **Symptoms:** A method in class `A` that is almost entirely composed of calls like `b.getX()`, `b.getY()`, `b.getZ()`. The logic belongs inside class `B`.
*   **Refactoring Strategy:** **Move Method**. Move the entire method (or the relevant part of its logic) to the class that owns the data it is "envious" of. This increases the cohesion of the data-owning class and reduces the coupling between the two. It aligns with the "Tell, Don't Ask" principle—you should tell an object to do something with its own data, not ask for its data and then operate on it yourself.

##### **Anti-Pattern: Anemic Domain Model**
*   **Description:** A design where objects are just simple data containers with getters and setters, and all the business logic is located in separate "manager" or "service" classes. These data-only classes are called "anemic." This is often a sign of procedural programming disguised in object-oriented syntax. It violates the core OOP idea of bundling data and the behavior that operates on that data.
*   **Symptoms:** A package full of POJOs (Plain Old Java Objects) with only fields, constructors, getters, and setters. A corresponding set of "Service" classes that take these POJOs as parameters and perform all the work.
*   **Refactoring Strategy:** **Add Behavior**. Move the business logic from the service classes into the domain objects themselves. For example, instead of an `OrderService.calculateTotal(Order order)` method, create an `order.calculateTotal()` method. This makes the domain objects rich with behavior, increasing cohesion and better encapsulating the business rules.

---

#### **2. Example Code Snippet**

##### **Before: A Mix of Anti-Patterns**

```java
// Anti-Pattern: Anemic Domain Model. The Order class is just a data bag.
class Order {
    private List<OrderItem> items;
    private double taxRate;
    // Getters and setters for items and taxRate...
}

// Anti-Pattern: Feature Envy. This method is "envious" of the Order's data.
// It also hints at a God Object if this class managed payments, shipping, etc.
class OrderProcessor {
    public double calculateOrderTotal(Order order) {
        // 1. Ask the Order for its data
        List<OrderItem> items = order.getItems();
        double subtotal = 0;
        for (OrderItem item : items) {
            // 2. Ask the OrderItem for its data
            subtotal += item.getPrice() * item.getQuantity();
        }
        // 3. Ask the Order for more data
        double tax = subtotal * order.getTaxRate();
        return subtotal + tax;
    }
}
```

##### **After: Refactoring to a Rich Domain Model**

```java
// No longer anemic. This class now owns its own business logic.
class RichOrder {
    private List<OrderItem> items;
    private double taxRate;

    // constructor...

    // Refactoring: The logic from the service has been moved here.
    public double calculateTotal() {
        // The method now operates on its own data directly.
        double subtotal = items.stream()
                               .mapToDouble(item -> item.calculateSubtotal()) // Delegate to OrderItem
                               .sum();
        double tax = subtotal * this.taxRate;
        return subtotal + tax;
    }
}

class OrderItem {
    private double price;
    private int quantity;

    // Behavior is now part of the class that owns the data.
    public double calculateSubtotal() {
        return this.price * this.quantity;
    }
}

// The OrderProcessor is now much simpler, or may not even be needed.
// It acts as a high-level coordinator.
class OrderService {
    public void process(RichOrder order) {
        // Tell, Don't Ask.
        double total = order.calculateTotal();
        // ... now proceed with payment, shipping, etc. ...
    }
}
```
This refactored design has higher cohesion (logic is with the data it operates on) and lower coupling (the `OrderService` no longer needs to know the internal details of how an `Order`'s total is calculated).

---

#### **3. Mini Exercise**

You have a `Report` class and a `ReportGenerator` class. The `ReportGenerator` exhibits "Feature Envy."

```java
class Report {
    private String title;
    private String content;
    private String author;

    public Report(String title, String content, String author) {
        this.title = title;
        this.content = content;
        this.author = author;
    }
    // Getters for all fields...
}

class ReportGenerator {
    // This method is envious of the Report's data.
    public String toHtml(Report report) {
        String html = "<html><head><title>" + report.getTitle() + "</title></head><body>";
        html += "<h1>" + report.getTitle() + "</h1>";
        html += "<h2>By: " + report.getAuthor() + "</h2>";
        html += "<p>" + report.getContent() + "</p>";
        html += "</body></html>";
        return html;
    }
}
```

Your task is to refactor this code.
1.  Apply the **Move Method** refactoring.
2.  Move the `toHtml` logic into the `Report` class itself, so it becomes a rich domain object.
3.  The `ReportGenerator` class may now be redundant or could be simplified to just call the new method on the `Report` object.

---

#### **4. Quiz Question**

**Question:** You are refactoring a large `UserService` class. You notice a private method called `isValidEmail(String email)` that uses a regular expression to validate an email format. This method is a perfect candidate to be extracted into its own class. What primary benefit does this achieve?

A) It makes the `UserService` class immutable.
B) It increases the cohesion of the new `EmailValidator` class and the `UserService` class.
C) It demonstrates the Law of Demeter.
D) It converts an anemic domain model into a rich one.

*(Scroll down for the answer)*

...

**Answer:** B) It increases the cohesion of the new `EmailValidator` class and the `UserService` class. The responsibility of email validation is extracted into a new, highly cohesive `EmailValidator` class whose only job is validation. This also makes the `UserService` more cohesive by removing a tangential responsibility, allowing it to focus on higher-level user management tasks.

### **Lesson 17: Topic Summary, Interview Questions, and Final Project**

This is the final lesson for our topic on OOP & Design Principles. We will consolidate all the concepts into a summary, review common interview questions that test this knowledge, and apply everything in a final mini-project.

---

#### **1. Summary Table of Key Takeaways**

| Concept | Key Takeaway |
| :--- | :--- |
| **Abstraction** | Hide complex implementation details. Achieved via **abstract classes** ("is-a", shares code/state) and **interfaces** ("can-do", defines a contract). |
| **Encapsulation** | Bundle data and methods into a class. Enforces **data hiding** through `private` access modifiers and controlled access via public methods (getters/setters). |
| **Inheritance** | An "is-a" relationship (`extends`). Promotes code reuse but creates **tight coupling**. A subclass inherits from exactly one parent class. |
| **Polymorphism** | "Many forms." An object can be treated as an instance of its parent type. **Runtime polymorphism** (method overriding) is achieved via dynamic binding. |
| **Composition** | A "has-a" or "part-of" relationship. The preferred alternative to inheritance for reuse and flexibility. Creates **loose coupling**. |
| **`Object` Class** | The root of all Java classes. Override `equals()` (for value equality) and `hashCode()` (for hash-based collections) together. Override `toString()` for meaningful logging. |
| **SOLID Principles** | **S**ingle Responsibility, **O**pen/Closed, **L**iskov Substitution, **I**nterface Segregation, **D**ependency Inversion. A set of rules for creating flexible, maintainable, and understandable software. |
| **DRY, KISS, YAGNI** | **D**on't **R**epeat **Y**ourself (abstract duplicated code). **K**eep **I**t **S**imple, **S**tupid (avoid over-engineering). **Y**ou **A**in't **G**onna **N**eed **I**t (don't implement speculative features). |
| **Cohesion & Coupling** | The goal is **High Cohesion** (a class does one thing well) and **Low Coupling** (classes are independent of each other). SRP promotes cohesion; DIP/OCP promote loose coupling. |
| **Law of Demeter** | "Only talk to your immediate friends." Avoid method chains (`a.getB().getC().doSomething()`) to reduce coupling to the internal structure of other objects. |
| **Immutability** | An object's state cannot be changed after creation. Provides inherent thread safety and predictability. Requires a `final` class, `private final` fields, no setters, and defensive copying of mutable components. |

---

#### **2. Common Interview Questions**

1.  **"Explain the difference between an abstract class and an interface. When would you use one over the other?"**
    *   *Answer:* An interface defines a pure contract of behavior (a "can-do" relationship) and a class can implement many of them. An abstract class provides a partial blueprint (an "is-a" relationship), can have state (instance variables) and concrete methods, but a class can only extend one. Choose an abstract class when you need to share code or state among closely related subclasses. Choose an interface when you need to define a capability that can be adopted by unrelated classes.

2.  **"What is the contract between `equals()` and `hashCode()`? What happens if you violate it?"**
    *   *Answer:* The contract is: if two objects are equal according to `equals()`, they MUST have the same hash code. If you violate this (e.g., by overriding `equals()` but not `hashCode()`), hash-based collections like `HashMap` and `HashSet` will not work correctly. You might put an object in a set, but when you check if it `contains()` an equal object, it will return `false` because the different hash codes cause the set to look in the wrong bucket.

3.  **"Why is 'favor composition over inheritance' a common design principle?"**
    *   *Answer:* Inheritance creates tight coupling; a change in the superclass can easily break subclasses. It's also static, fixed at compile time. Composition is more flexible, allowing you to change behavior at runtime by swapping out components. It creates loose coupling because the container class only interacts with the component's public interface, respecting encapsulation and making the system easier to test and maintain.

4.  **"How do the SOLID principles, particularly DIP, lead to more testable code?"**
    *   *Answer:* The Dependency Inversion Principle (DIP) makes us depend on abstractions (interfaces) instead of concrete implementations. By using Dependency Injection, we can provide "mock" or "stub" implementations of these interfaces during testing. This allows us to test a component (like a service) in complete isolation, without needing a real database or network connection, making our unit tests fast, reliable, and focused.

5.  **"You have a method in class A that calls `b.getC().doSomething()`. Which design principle does this likely violate and how would you fix it?"**
    *   *Answer:* This violates the Law of Demeter. It couples class A not just to class B, but also to the internal structure of B (the fact that it has a C). To fix it, you would introduce a new method in class B, for example `doTheThing()`, which hides the internal delegation. The call in A would then become `b.doTheThing()`, and class A no longer needs to know about class C. This reduces coupling and makes the system more resilient to change.

---

#### **3. Final Mini-Project: A Flexible Logging System**

This project will apply many of the principles we've learned to build a logging system that is decoupled and easily extensible.

**🎯 Goal:** Design a logging system where the application's core logic can log messages without being tied to a specific destination (e.g., console, file, or network).

**Project Requirements:**

1.  **Interfaces (Abstraction, DIP, ISP):**
    *   Create a `LogOutput` interface with a single method: `void write(String formattedMessage)`. This is a fine-grained interface (ISP).
    *   Create a `MessageFormatter` interface with a single method: `String format(String message)`.

2.  **Concrete Implementations (SRP):**
    *   Create `ConsoleOutput`, which implements `LogOutput` and writes the message to `System.out.println()`.
    *   Create `FileOutput`, which implements `LogOutput` and writes the message to a file.
    *   Create `TimestampFormatter`, which implements `MessageFormatter` and prepends a timestamp to the message.
    *   Create `SimpleFormatter`, which implements `MessageFormatter` and returns the message as-is.

3.  **The Logger Service (Composition, Low Coupling):**
    *   Create a `Logger` class. This is the main class the application will use.
    *   It should be **composed** of a `LogOutput` and a `MessageFormatter`. It should *not* inherit from them.
    *   The dependencies (`LogOutput` and `MessageFormatter`) should be injected via the constructor (DIP).
    *   It will have one public method, `log(String message)`, which uses its formatter to format the message and then its output to write the formatted message.

4.  **Main Application (Demonstrating OCP):**
    *   In your `main` method, demonstrate the flexibility of the design.
    *   First, create a `Logger` configured to log to the console with a timestamp. Log a few messages.
    *   Then, create a second `Logger` instance configured to log to a file with the simple formatter, **without changing any existing classes**. Log a few more messages. This demonstrates that your system is open for extension (new output/formatter types) but closed for modification.

**Example `main` Method Structure:**

```java
public static void main(String[] args) {
    // Configuration 1: Log with timestamps to the console
    LogOutput console = new ConsoleOutput();
    MessageFormatter timestampFormatter = new TimestampFormatter();
    Logger consoleLogger = new Logger(console, timestampFormatter);

    consoleLogger.log("Application has started.");
    consoleLogger.log("Processing user request.");

    System.out.println("------------------------------------");

    // Configuration 2: Log plain messages to a file
    LogOutput file = new FileOutput("app.log");
    MessageFormatter simpleFormatter = new SimpleFormatter();
    Logger fileLogger = new Logger(file, simpleFormatter);

    fileLogger.log("An error occurred in module X.");
    fileLogger.log("Shutting down services.");
}
```

Completing this project will give you a practical, hands-on understanding of how these critical OOP and design principles come together to create software that is clean, maintainable, and built to last.