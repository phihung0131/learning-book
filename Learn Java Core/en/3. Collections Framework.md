### **Lesson 1: Overview of the Java Collections Framework**

#### **1. Concept Explanation**

##### **What is the Java Collections Framework (JCF)?**
The Java Collections Framework is a unified architecture for representing and manipulating collections of objects. It is a set of interfaces and classes designed to provide high-performance, reusable data structures. Before the JCF, Java developers had to rely on arrays, `Vector`, and `Hashtable`, which were not part of a cohesive framework. The JCF introduced a standardized way to handle groups of objects.

**Core Goals of the JCF:**
*   **Reduce programming effort:** Provides standard, reusable data structures so you don't have to write them from scratch.
*   **Increase performance:** Provides high-performance implementations of common data structures.
*   **Promote interoperability:** Establishes a common language for passing collections between different parts of an API.
*   **Foster software reuse:** Encourages the creation of algorithms that can operate on any collection that implements a specific interface.

##### **Arrays vs. Collections**
| Feature | Arrays | Collections |
| :--- | :--- | :--- |
| **Size** | Fixed size, declared at initialization. Cannot grow or shrink. | Dynamic size. Can grow and shrink at runtime. |
| **Data Type** | Can hold both primitives and objects. | Can only hold objects (primitives are auto-boxed). |
| **Performance** | Generally faster for element access with a known index (`arr[i]`). | Performance varies by implementation (`ArrayList` is fast for indexed access, `LinkedList` is not). |
| **Functionality**| Limited built-in methods. | Rich set of methods for searching, sorting, insertion, deletion, etc. |
| **Hierarchy** | Not part of the JCF. `Object` is the direct superclass. | Part of a well-defined interface hierarchy (`List`, `Set`, `Queue`, etc.). |

##### **The Core Hierarchies**
The JCF is built around two main interface hierarchies: `java.util.Collection` and `java.util.Map`. It's crucial to understand that **`Map` does not extend `Collection`**. A `Collection` represents a group of individual elements, whereas a `Map` represents a group of key-value pairs.

**1. The `Collection` Hierarchy:**
This is the root interface for data structures that store single elements.

```
                  +---------------+
                  |   Iterable    |  <- The ultimate root, provides iterators
                  +---------------+
                         ^
                         | (extends)
                  +---------------+
                  |  Collection   |  <- add(), remove(), contains(), size()
                  +---------------+
                         ^
                         |
           +-------------+-------------+
           |             |             |
     +-----------+ +-----------+ +-----------+
     |   List    | |    Set    | |   Queue   |  <- Core sub-interfaces
     +-----------+ +-----------+ +-----------+
```

*   **`Iterable<E>`:** The super-interface for the entire `Collection` hierarchy. Its single abstract method, `iterator()`, provides an `Iterator` which allows you to loop through the elements. Any class that implements `Iterable` can be used in an enhanced `for-each` loop.
*   **`Collection<E>`:** The foundation. Defines the core methods for all collections, such as `add(E e)`, `remove(Object o)`, `contains(Object o)`, `size()`, `isEmpty()`, and `clear()`.
*   **`List<E>`:** An **ordered** collection (a sequence) that allows **duplicate** elements. You can access elements by their integer index.
*   **`Set<E>`:** A collection that contains **no duplicate** elements. It models the mathematical set abstraction.
*   **`Queue<E>`:** A collection used to hold elements prior to processing. Besides basic `Collection` operations, queues provide additional insertion, extraction, and inspection operations, typically in a **FIFO (First-In, First-Out)** manner.

**2. The `Map` Hierarchy:**
This interface is for data structures that map keys to values. Keys must be unique.

```
                  +-----------+
                  |    Map    |  <- put(K,V), get(K), remove(K), keySet()
                  +-----------+
```
*   **`Map<K, V>`:** An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. It provides three "collection views," which allow a map's contents to be viewed as a `Set` of keys, `Collection` of values, or `Set` of key-value mappings.

---

#### **2. Example Code Snippet**

This example demonstrates the basic usage of the three main collection types and a map, highlighting their key characteristics.

```java
import java.util.*;

public class FrameworkOverview {
    public static void main(String[] args) {
        // 1. List: Ordered, allows duplicates
        List<String> userList = new ArrayList<>();
        userList.add("Alice");
        userList.add("Bob");
        userList.add("Alice"); // Duplicate is allowed
        System.out.println("List of users: " + userList);
        System.out.println("Second user: " + userList.get(1)); // Access by index

        // 2. Set: Unordered, unique elements
        Set<String> uniqueUsers = new HashSet<>();
        uniqueUsers.add("Alice");
        uniqueUsers.add("Bob");
        uniqueUsers.add("Alice"); // Duplicate is ignored
        System.out.println("Set of unique users: " + uniqueUsers);

        // 3. Map: Key-value pairs, unique keys
        Map<String, Integer> userScores = new HashMap<>();
        userScores.put("Alice", 100);
        userScores.put("Bob", 95);
        userScores.put("Alice", 105); // Replaces the previous value for "Alice"
        System.out.println("Map of user scores: " + userScores);
        System.out.println("Alice's score: " + userScores.get("Alice")); // Access by key

        // Using Iterable with a for-each loop
        System.out.print("Iterating through the list: ");
        for (String user : userList) {
            System.out.print(user + " ");
        }
        System.out.println();
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a `List` of integers and add the numbers `10, 20, 30, 20, 10`. Print the list.
2.  Create a `Set` of integers and add the same numbers (`10, 20, 30, 20, 10`) to it. Print the set.
3.  Observe and explain the difference in the output between the `List` and the `Set`.

---

#### **4. Quiz Question**

**Question:** Which of the following statements is true about the Java Collections Framework?

A) The `Map` interface extends the `Collection` interface.
B) A `List` cannot contain duplicate elements.
C) The `Iterable` interface is the root of the `Map` hierarchy.
D) The `Set` interface guarantees that it contains no duplicate elements.

*(Scroll down for the answer)*

...

**Answer:** D) The `Set` interface guarantees that it contains no duplicate elements. This is the defining characteristic of a `Set`.

### **Lesson 2: The `List` Interface - `ArrayList` vs. `LinkedList`**

#### **1. Concept Explanation**

The `List` interface represents an ordered sequence of elements. Unlike `Set`, a `List` allows duplicate elements. The two most important features of a `List` are:
1.  **Positional Access:** Elements can be accessed, inserted, or removed based on their integer index (position).
2.  **Ordered:** It maintains the insertion order of elements.

The two primary general-purpose `List` implementations are `ArrayList` and `LinkedList`. Choosing between them is a critical performance decision based on your use case.

##### **`ArrayList` - The Resizable Array**

*   **Internal Structure:** An `ArrayList` is backed by a **dynamic array** (an array that can grow in size). It directly stores elements in a contiguous block of memory. It also maintains a `size` field to track how many elements are actually in the list.
    ```
    // ArrayList Internals
    Object[] elementData; // The backing array
    int size;             // The number of elements currently in the list
    ```
*   **Resizing:** When you add an element and the internal array is full, the `ArrayList` creates a **new, larger array** (typically 1.5 times the old size), copies all the elements from the old array to the new one, and then adds the new element. This resizing operation is an O(n) process, which can be slow if it happens frequently. You can pre-allocate capacity in the constructor (`new ArrayList<>(initialCapacity)`) to avoid this.

*   **Time Complexity:**
    *   **`get(int index)`:** O(1) - Extremely fast. Since it's an array, it can calculate the memory offset and jump directly to the element.
    *   **`add(E element)` (at the end):** Amortized O(1). It's O(1) on average, but becomes O(n) when a resize is needed.
    *   **`add(int index, E element)` (in the middle):** O(n). All elements from the index onwards must be shifted to the right to make space.
    *   **`remove(int index)` (from the middle):** O(n). All elements after the index must be shifted to the left to fill the gap.

*   **Best Use Case:** Excellent for situations where you have a high volume of **read operations** (random access by index) and fewer insertions/deletions in the middle of the list. It's the most commonly used `List` implementation.

##### **`LinkedList` - The Chain of Nodes**

*   **Internal Structure:** A `LinkedList` is a **doubly-linked list**. It does not store elements in contiguous memory. Instead, each element is wrapped in a `Node` object. Each `Node` contains three pieces of information: the element itself, a pointer to the previous `Node`, and a pointer to the next `Node`.
    ```
    // LinkedList Node Internals
    class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;
    }
    // The LinkedList holds pointers to the first and last nodes.
    Node<E> first;
    Node<E> last;
    ```
*   **Time Complexity:**
    *   **`get(int index)`:** O(n). To find the element at a specific index, it must traverse the list from the beginning (or end, whichever is closer) until it reaches the desired node.
    *   **`add(E element)` (at the end/beginning):** O(1). It just needs to update the pointers of the last/first node.
    *   **`add(int index, E element)` (in the middle):** O(n). This is deceptive. It first takes O(n) to traverse to the insertion point, but the actual insertion is a fast O(1) operation of rewiring the pointers. The overall complexity is dominated by the traversal.
    *   **`remove(int index)` (from the middle):** O(n). Similar to adding, it takes O(n) to find the node, but the removal itself is a quick O(1) pointer update.

*   **Best Use Case:** Ideal for situations with a high volume of **insertions and deletions** at the beginning, middle, or end of the list. It behaves as a `Queue` or `Deque` (Double-Ended Queue) very efficiently. Use it when you rarely need to access elements by index.

##### **`Vector` and `Stack`**
*   **`Vector`:** An older, legacy class from Java 1.0. It's essentially a synchronized version of `ArrayList`. All of its public methods are `synchronized`, which makes it thread-safe but introduces a significant performance overhead. In modern Java, it's almost always better to use an `ArrayList` and manage synchronization externally if needed, or use `CopyOnWriteArrayList` for concurrent read-heavy scenarios.
*   **`Stack`:** A legacy LIFO (Last-In, First-Out) data structure that `extends Vector`. This is a poor design choice, as a `Stack` should not expose all the methods of a `List` (like `get(index)`). The modern, preferred alternative is to use an interface, `Deque`, with its implementation `ArrayDeque`.

---

#### **2. Example Code Snippet**

This code demonstrates the performance difference between `ArrayList` and `LinkedList` for adding elements at the beginning.

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class ListPerformanceDemo {
    public static void main(String[] args) {
        int numElements = 100_000;

        // --- ArrayList: Adding at the beginning ---
        List<Integer> arrayList = new ArrayList<>();
        long startTime = System.nanoTime();
        for (int i = 0; i < numElements; i++) {
            arrayList.add(0, i); // Adding at index 0 requires shifting all other elements
        }
        long endTime = System.nanoTime();
        System.out.println("ArrayList add at beginning time: " + (endTime - startTime) / 1_000_000 + " ms");

        // --- LinkedList: Adding at the beginning ---
        List<Integer> linkedList = new LinkedList<>();
        startTime = System.nanoTime();
        for (int i = 0; i < numElements; i++) {
            linkedList.add(0, i); // Adding at index 0 is an O(1) pointer update
        }
        endTime = System.nanoTime();
        System.out.println("LinkedList add at beginning time: " + (endTime - startTime) / 1_000_000 + " ms");

        // NOTE: The difference in time will be dramatic.
    }
}
```

---

#### **3. Mini Exercise**

1.  Create an `ArrayList` of strings and a `LinkedList` of strings.
2.  Populate both with 5 million string elements (e.g., `"Element " + i`).
3.  Measure the time it takes to get the element at the middle index (index 2,500,000) from the `ArrayList`.
4.  Measure the time it takes to get the same element from the `LinkedList`.
5.  Print the times and observe the performance difference for random access.

---

#### **4. Quiz Question**

**Question:** You are building an application that manages a playlist of songs. The primary operations are adding songs to the end of the playlist and frequently shuffling the entire playlist (which involves many random insertions and deletions). Which `List` implementation would be the worst choice for this use case?

A) `ArrayList`
B) `LinkedList`
C) `Vector`
D) It doesn't matter, they have the same performance.

*(Scroll down for the answer)*

...

**Answer:** A) `ArrayList`. While adding to the end is efficient, a shuffle operation involves numerous insertions and deletions throughout the list. For an `ArrayList`, each of these operations is O(n) because it requires shifting large portions of the underlying array. A `LinkedList` would handle these insertions and deletions much more efficiently (though the traversal to find the position is still a factor). `Vector` is also a bad choice due to synchronization overhead, but `ArrayList`'s fundamental structure makes it the worst for this specific "shuffle" requirement.

### **Lesson 3: The `Set` Interface - `HashSet`, `LinkedHashSet`, and `TreeSet`**

#### **1. Concept Explanation**

The `Set` interface models the mathematical set abstraction. Its defining characteristic is that it **cannot contain duplicate elements**. Any attempt to add an element that is already present in the set will be ignored (the `add` method will return `false`).

The power of `Set` implementations comes from their ability to perform membership tests (`contains()`) very quickly. The three primary implementations each offer a different trade-off between performance and ordering.

##### **`HashSet` - For Unordered, Fast Access**

*   **Internal Structure:** A `HashSet` is backed by a `HashMap` instance. The elements you add to the `HashSet` are used as the **keys** in the internal `HashMap`. The value associated with each key is a constant dummy object called `PRESENT`.
    ```java
    // When you do: myHashSet.add("apple");
    // Internally, it becomes: myHashMap.put("apple", PRESENT);
    ```
*   **How it Works (Hashing):** When you add an element, `HashSet` calculates the element's `hashCode()`. This hash code is used to determine which "bucket" (or index) in the `HashMap`'s internal array the element should be stored in. The `equals()` method is then used to check if the element already exists among the other elements in the same bucket (in case of a hash collision).
*   **The `equals()` and `hashCode()` Contract:** For `HashSet` to work correctly, any object you store in it **must** properly implement `equals()` and `hashCode()` according to their contract. If two objects are equal, their hash codes MUST be the same.
*   **Ordering:** It makes **no guarantees** about the iteration order of the elements. The order can, and likely will, change over time as more elements are added and the backing map is resized.
*   **Performance:** Offers **O(1)** average time complexity for `add()`, `remove()`, and `contains()` operations, assuming a good hash function. This makes it extremely fast.
*   **Nulls:** Allows one `null` element.

##### **`LinkedHashSet` - For Insertion-Ordered Access**

*   **Internal Structure:** A `LinkedHashSet` is a subclass of `HashSet`. It is also backed by a `HashMap`-like structure (`LinkedHashMap`, to be precise). In addition to the standard hashing mechanism, it maintains a **doubly-linked list** running through all its entries.
*   **How it Works:** This linked list is used to maintain the order in which elements were inserted into the set. When you iterate over a `LinkedHashSet`, you get the elements back in the exact order you added them.
*   **Ordering:** Guarantees **insertion order**.
*   **Performance:** Offers the same **O(1)** average time complexity as `HashSet` for `add()`, `remove()`, and `contains()`. The overhead of maintaining the linked list is minimal.
*   **Best Use Case:** Use it when you need the uniqueness and fast access of a `HashSet`, but also need to maintain the order of insertion. It is excellent for creating predictable and testable code where iteration order matters.

##### **`TreeSet` - For Sorted Order**

*   **Internal Structure:** A `TreeSet` is backed by a `TreeMap`, which is a **Red-Black Tree**, a type of self-balancing binary search tree.
*   **How it Works:** Instead of using hashing, `TreeSet` uses the element's **natural ordering** or a `Comparator` provided at construction time to arrange elements in a sorted order. When you add an element, the `TreeSet` traverses the tree to find the correct position for the new element while keeping the tree balanced.
*   **Ordering:** Guarantees that the elements will be in **sorted order** (ascending, by default).
*   **Ordering Mechanism:**
    1.  **`Comparable`:** If you add objects to a `TreeSet`, their class must implement the `Comparable` interface and its `compareTo()` method. This defines the "natural order" of the objects (e.g., for `String`, it's alphabetical; for `Integer`, it's numerical).
    2.  **`Comparator`:** Alternatively, you can pass a `Comparator` object to the `TreeSet`'s constructor. This `Comparator` will be used to compare and order the elements, overriding their natural order.
*   **Performance:** Offers **O(log n)** time complexity for `add()`, `remove()`, and `contains()`. This is slower than `HashSet`'s O(1) but is still very efficient, and the cost provides the benefit of a constantly sorted collection.
*   **Nulls:** Does not allow `null` elements (it would cause a `NullPointerException` when trying to compare it).

---

#### **2. Example Code Snippet**

This example demonstrates the different ordering behaviors of the three `Set` implementations.

```java
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;

public class SetImplementationsDemo {
    public static void main(String[] args) {
        // --- HashSet: No guaranteed order ---
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Banana");
        hashSet.add("Apple");
        hashSet.add("Cherry");
        hashSet.add("Date");
        // Output order is not guaranteed, depends on hash codes.
        System.out.println("HashSet (unordered): " + hashSet);

        // --- LinkedHashSet: Insertion order ---
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Banana");
        linkedHashSet.add("Apple");
        linkedHashSet.add("Cherry");
        linkedHashSet.add("Date");
        // Output will be exactly: Banana, Apple, Cherry, Date
        System.out.println("LinkedHashSet (insertion-ordered): " + linkedHashSet);

        // --- TreeSet: Sorted order ---
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("Banana");
        treeSet.add("Apple");
        treeSet.add("Cherry");
        treeSet.add("Date");
        // Output will be sorted alphabetically: Apple, Banana, Cherry, Date
        System.out.println("TreeSet (sorted): " + treeSet);
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a custom `Book` class with `title` (String) and `publicationYear` (int) fields.
2.  Properly implement the `equals()` and `hashCode()` methods based on the `title` field.
3.  Create a `HashSet<Book>` and add several `Book` objects to it, including a duplicate title. Observe that the duplicate is rejected.
4.  Now, make the `Book` class implement the `Comparable<Book>` interface. The `compareTo()` method should sort books by their `publicationYear`.
5.  Create a `TreeSet<Book>` and add the same book objects to it.
6.  Print the `TreeSet` and observe that the books are now sorted by year.

---

#### **4. Quiz Question**

**Question:** You need to store a collection of unique user IDs (`UUID` objects) that are frequently added and checked for existence. The order of the user IDs does not matter at all. Which `Set` implementation would provide the best performance for this task?

A) `TreeSet`, because it keeps the IDs sorted for fast lookups.
B) `LinkedHashSet`, because it maintains insertion order which is good for caching.
C) `HashSet`, because it provides O(1) average time complexity for `add` and `contains`.
D) `Vector`, because it is thread-safe.

*(Scroll down for the answer)*

...

**Answer:** C) `HashSet`. The requirements are fast `add` and fast `contains` checks (`uniqueness`) and the order does not matter. This is the exact use case where `HashSet` excels, providing the best possible average time complexity of O(1). `TreeSet` would be slower (O(log n)), and `LinkedHashSet` adds a slight overhead for ordering that is not needed here.

### **Lesson 4: The `Map` Interface and `HashMap` Internals**

#### **1. Concept Explanation**

The `Map` interface represents a collection of **key-value pairs**. It is one of the most useful data structures in programming. The core principle is that each key must be unique, and it maps to exactly one value.

**Key `Map` Methods:**
*   `V put(K key, V value)`: Associates the specified value with the specified key.
*   `V get(Object key)`: Returns the value to which the specified key is mapped, or `null` if this map contains no mapping for the key.
*   `V remove(Object key)`: Removes the mapping for a key if it is present.
*   `boolean containsKey(Object key)`: Returns `true` if this map contains a mapping for the specified key.
*   `Set<K> keySet()`: Returns a `Set` view of the keys contained in this map.
*   `Collection<V> values()`: Returns a `Collection` view of the values.
*   `Set<Map.Entry<K, V>> entrySet()`: Returns a `Set` view of the key-value mappings.

##### **`HashMap` - The Most Common `Map`**

`HashMap` is the workhorse of the `Map` implementations. It provides O(1) average time complexity for `get()` and `put()` operations. It does **not** guarantee any order for its elements. It allows one `null` key and multiple `null` values.

##### **`HashMap` Internals: The Core Mechanism**

Understanding how a `HashMap` works internally is a frequent and critical interview topic. It is a masterful combination of an array and linked lists (and in Java 8+, trees).

1.  **The Array of "Buckets":**
    A `HashMap` contains an internal array called `table`. Each element of this array is a "bucket."
    ```java
    // Simplified internal structure
    transient Node<K,V>[] table;
    ```
    A bucket can either be `null` or point to the first `Node` of a data structure (a linked list or a tree).

2.  **The `Node` (or `Entry`):**
    Each key-value pair is stored in a `Node` object. A `Node` holds:
    *   The hash code of the key.
    *   The key object itself.
    *   The value object.
    *   A pointer to the next `Node` in the same bucket.

3.  **The `put(key, value)` Operation - Step-by-Step:**
    When you call `map.put("john", 123);`:
    *   **Step 1: Calculate Hash Code:** The `hashCode()` method of the key (`"john"`) is called.
    *   **Step 2: Calculate Array Index:** This hash code is then passed through an internal hashing function to calculate an index in the `table` array. This ensures the index is always within the array's bounds. The formula is typically `index = hashCode & (n - 1)`, where `n` is the array length. This is a fast way to do a modulo operation if `n` is a power of two.
    *   **Step 3: Handle Collision:**
        *   **Case A: The bucket is empty (`table[index] == null`).** A new `Node` is created with the key-value pair and placed at this index. This is the ideal, O(1) scenario.
        *   **Case B: The bucket is not empty (Collision!).** This means another key has already mapped to this same index.
            *   The `HashMap` iterates through the linked list at that bucket.
            *   For each `Node` in the list, it checks if the new key is `equals()` to the existing key.
            *   If a match is found, the value of that `Node` is simply updated with the new value, and the old value is returned.
            *   If no match is found after traversing the entire list, the new `Node` is added to the end of the list.

4.  **The `get(key)` Operation:**
    *   It follows the same logic: calculate the key's `hashCode()`, find the bucket index, and if the bucket is not empty, traverse the linked list, using the `equals()` method to find the exact key.

**Diagram of `HashMap` Internals:**
```
  table (Array of Nodes)
  Index
    0    -> null
    1    -> (hash1, "key1", val1, next) -> (hashA, "keyA", valA, next) -> null
    2    -> null
    3    -> (hash3, "key3", val3, next) -> null
    ...
   n-1   -> (hashZ, "keyZ", valZ, next) -> null
```

##### **Resizing and Load Factor**
*   **Capacity:** The length of the internal `table` array. Always a power of two.
*   **Load Factor:** A measure of how full the hash table is allowed to get before its capacity is automatically increased. The default is **0.75**.
*   **Resizing:** When `(size / capacity) > loadFactor`, the `HashMap` is **resized**. A new array with double the capacity is created, and all existing entries are **re-hashed** to find their new bucket locations in the bigger array. This is an expensive O(n) operation.

##### **Java 8+ Improvement: Tree Bins**
*   **The Problem:** In the worst-case scenario, if all keys have the same hash code, they all map to the same bucket, and the linked list becomes very long. All operations degrade to O(n).
*   **The Solution:** In Java 8, if the number of nodes in a single bucket reaches a certain threshold (by default, `TREEIFY_THRESHOLD = 8`), the linked list for that bucket is converted into a **self-balancing Red-Black Tree**.
*   **The Benefit:** This improves the worst-case time complexity for `get()` and `put()` from O(n) to **O(log n)**, a significant improvement.

---

#### **2. Example Code Snippet**

This example demonstrates the core functionality and how overriding `equals` and `hashCode` is critical.

```java
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

// A custom key class
class Employee {
    private final int id;
    private final String department;

    public Employee(int id, String department) {
        this.id = id;
        this.department = department;
    }

    // CRITICAL: Must override both for HashMap to work correctly
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id && Objects.equals(department, employee.department);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, department);
    }
}

public class HashMapDemo {
    public static void main(String[] args) {
        Map<Employee, String> employeeNames = new HashMap<>();

        Employee e1 = new Employee(101, "Engineering");
        Employee e2 = new Employee(102, "HR");
        Employee e3 = new Employee(101, "Engineering"); // Logically the same as e1

        employeeNames.put(e1, "Alice");
        employeeNames.put(e2, "Bob");

        // --- Demonstrating get() ---
        System.out.println("Name for e1: " + employeeNames.get(e1)); // Alice
        // We use an "equal" object e3 to retrieve the value. This only works
        // because we correctly implemented equals() and hashCode().
        System.out.println("Name for e3: " + employeeNames.get(e3)); // Alice

        // --- Demonstrating put() with an equal key ---
        System.out.println("Map size before put(e3): " + employeeNames.size()); // 2
        employeeNames.put(e3, "Alicia"); // This will UPDATE the value for the existing key
        System.out.println("Map size after put(e3): " + employeeNames.size()); // Still 2
        System.out.println("New name for e1: " + employeeNames.get(e1)); // Alicia
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a simple `Word` class that has one `private String value` field.
2.  **Do not** override `equals()` or `hashCode()` at first.
3.  Create a `HashMap<Word, Integer>` to count word frequencies.
4.  Put a new `Word("hello")` with a count of 1 into the map.
5.  Try to retrieve the count using another `new Word("hello")`. Observe that it fails (returns `null`).
6.  Now, correctly implement `equals()` and `hashCode()` in your `Word` class.
7.  Run the test again and observe that it now works correctly.

---

#### **4. Quiz Question**

**Question:** In a `HashMap`, what is the primary purpose of the key's `equals()` method?

A) To calculate the initial index in the internal array.
B) To rebalance the internal tree structure when a bucket grows too large.
C) To handle hash collisions by comparing keys within the same bucket to find an exact match.
D) To determine the initial capacity of the `HashMap` table.

*(Scroll down for the answer)*

...

**Answer:** C) To handle hash collisions by comparing keys within the same bucket to find an exact match. The `hashCode()` method gets you to the right bucket, but if multiple keys land in that same bucket (a collision), the `equals()` method is the final authority used to distinguish between them.

### **Lesson 5: `Map` Varieties - `LinkedHashMap`, `TreeMap`, and `Hashtable`**

#### **1. Concept Explanation**

While `HashMap` is the general-purpose choice, the Java Collections Framework provides several other `Map` implementations, each offering unique features related to ordering, sorting, and thread safety.

##### **`LinkedHashMap` - For Insertion Order**

*   **Relationship to `HashMap`:** `LinkedHashMap` is a direct subclass of `HashMap`. It inherits all the hashing mechanics and performance characteristics of a `HashMap`.
*   **Unique Feature:** It maintains a **doubly-linked list** running through all its entries. This list preserves the order in which keys were inserted into the map.
*   **Internal Structure:** Each `Entry` in a `LinkedHashMap` contains additional pointers, `before` and `after`, which link it to the previously inserted and next inserted entries, respectively.
    ```
    // In addition to the standard Node fields, a LinkedHashMap.Entry has:
    Entry<K,V> before, after;
    ```
*   **Ordering:** When you iterate over a `LinkedHashMap` (e.g., its `keySet()` or `entrySet()`), the elements are returned in the **insertion order**.
*   **Access Order:** `LinkedHashMap` has a special constructor: `new LinkedHashMap(initialCapacity, loadFactor, accessOrder)`. If `accessOrder` is set to `true`, the linked list will be reordered every time an entry is *accessed* (with `get()`). The most recently accessed entry moves to the end of the list. This feature is extremely useful for implementing **LRU (Least Recently Used) caches**.
*   **Performance:** `put()` and `get()` operations are still **O(1)** on average. The overhead for maintaining the linked list is very small.
*   **Best Use Case:** When you need the fast lookups of a `HashMap` but also require the iteration order to be predictable and stable (either insertion or access order).

##### **`TreeMap` - For Sorted Order**

*   **Internal Structure:** A `TreeMap` is a **Red-Black Tree**, a type of self-balancing binary search tree. It does not use hashing at all.
*   **Ordering:** It stores its entries sorted according to the **natural ordering** of its keys, or by a `Comparator` provided at map creation time. This means that iterating over a `TreeMap` will always yield the keys in a sorted sequence.
*   **Key Requirements:**
    1.  The keys must implement the `Comparable` interface.
    2.  OR, you must supply a `Comparator` to the `TreeMap`'s constructor.
*   **Performance:** `put()`, `get()`, and `containsKey()` operations have a time complexity of **O(log n)**. This is because each operation may require traversing the tree from the root to a leaf node. While slower than `HashMap`'s O(1), it's very efficient and guarantees a sorted view of the data at all times.
*   **Additional Methods:** Because it's sorted, `TreeMap` implements the `NavigableMap` interface, which provides useful methods like `firstKey()`, `lastKey()`, `headMap(toKey)`, and `tailMap(fromKey)` for getting ranges of the map.
*   **Nulls:** Does not allow a `null` key (it cannot be compared), but it does allow `null` values.

##### **`Hashtable` - The Legacy Synchronized `Map`**

*   **History:** `Hashtable` is a legacy class from Java 1.0, before the Collections Framework existed. It was later retrofitted to implement the `Map` interface.
*   **Key Difference (Synchronization):** It is **synchronized**. Every public method in `Hashtable` is marked as `synchronized`, meaning only one thread can access the map at a time. This provides thread safety but at a very high performance cost due to lock contention.
*   **Key Difference (Nulls):** It does **not** allow `null` keys or `null` values. Attempting to insert either will result in a `NullPointerException`.
*   **Modern Alternative:** `Hashtable` is generally considered obsolete. For thread-safe map operations, the modern, high-performance alternative is **`ConcurrentHashMap`**, which offers far better scalability by using more sophisticated locking mechanisms. If you just need to make a `HashMap` thread-safe for simple use cases, you can use the wrapper `Collections.synchronizedMap(new HashMap<>())`.

##### **Summary Table**

| Feature | `HashMap` | `LinkedHashMap` | `TreeMap` | `Hashtable` |
| :--- | :--- | :--- | :--- | :--- |
| **Ordering** | None | Insertion or Access Order | Sorted Order | None |
| **Internal Structure** | Hash Table (Array + List/Tree) | Hash Table + Linked List | Red-Black Tree | Hash Table |
| **Performance** | O(1) average | O(1) average | O(log n) | O(1) average (poor concurrent) |
| **Null Keys** | One allowed | One allowed | Not allowed | Not allowed |
| **Null Values** | Allowed | Allowed | Allowed | Not allowed |
| **Thread Safety** | Not thread-safe | Not thread-safe | Not thread-safe | Synchronized (Thread-safe) |
| **Best For** | General purpose, max speed | Predictable iteration, LRU caches | Sorted data, range queries | Legacy code (avoid in new code) |

---

#### **2. Example Code Snippet: LRU Cache with `LinkedHashMap`**

This is a classic use case for `LinkedHashMap` that demonstrates the power of `accessOrder`.

```java
import java.util.LinkedHashMap;
import java.util.Map;

// An LRU Cache evicts the least recently used item when it reaches its capacity.
public class LruCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LruCache(int capacity) {
        // The key constructor arguments:
        // initialCapacity, loadFactor, accessOrder = true
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    // This method is called by put and putAll. We override it to implement the eviction policy.
    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        // Return true to remove the eldest entry if the size exceeds capacity.
        return size() > capacity;
    }

    public static void main(String[] args) {
        LruCache<Integer, String> cache = new LruCache<>(3);

        cache.put(1, "A");
        cache.put(2, "B");
        cache.put(3, "C");
        System.out.println("Initial cache: " + cache); // {1=A, 2=B, 3=C}

        // Accessing key 1 makes it the most recently used.
        cache.get(1);
        System.out.println("After accessing 1: " + cache); // {2=B, 3=C, 1=A}

        // Adding a new entry (4) should evict the least recently used (key 2).
        cache.put(4, "D");
        System.out.println("After adding 4: " + cache); // {3=C, 1=A, 4=D}
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a `TreeMap` that maps `Integer` employee IDs to `String` employee names.
2.  Add several employees out of order (e.g., ID 50, then 10, then 30).
3.  Iterate through the `entrySet()` of the map and print each key-value pair. Observe that they are printed in sorted order of the keys.
4.  Use the `tailMap(30)` method to get a view of the map containing only employees with an ID of 30 or greater, and print it.

---

#### **4. Quiz Question**

**Question:** You are building a system that needs to display a list of countries and their capitals. The requirement is that the countries must always be displayed in alphabetical order. Which `Map` implementation is the most appropriate choice?

A) `HashMap`, because it is the fastest.
B) `LinkedHashMap`, because it preserves the order in which you added the countries.
C) `Hashtable`, because country data is critical and needs to be thread-safe.
D) `TreeMap`, because it automatically sorts the entries based on the natural order of its keys.

*(Scroll down for the answer)*

...

**Answer:** D) `TreeMap`. The key requirement is that the output must be sorted alphabetically. A `TreeMap` is the only standard map implementation that provides this guarantee automatically. The keys (`String` country names) have a natural alphabetical order, which the `TreeMap` will use to maintain its sorted structure.

### **Lesson 6: The `Queue` and `Deque` Interfaces**

#### **1. Concept Explanation**

##### **The `Queue` Interface**
A `Queue` is a collection designed for holding elements prior to processing. The fundamental concept is that it orders elements in a specific manner, typically **FIFO (First-In, First-Out)**. This is like a line at a ticket counter: the first person to get in line is the first person to be served.

**Core `Queue` Operations:**
The `Queue` interface provides two sets of methods for its main operations, one that throws an exception if the operation fails, and another that returns a special value (`null` or `false`).

| Operation | Throws Exception | Returns Special Value |
| :--- | :--- | :--- |
| **Insert** (at the tail) | `add(e)` | `offer(e)` |
| **Remove** (from the head) | `remove()` | `poll()` |
| **Examine** (the head) | `element()` | `peek()` |

*   **`offer(e)` vs. `add(e)`:** In bounded (fixed-capacity) queues, `offer` is preferred. It will simply return `false` if the queue is full, whereas `add` will throw an `IllegalStateException`.
*   **`poll()` vs. `remove()`:** `poll` is generally safer. It returns `null` if the queue is empty, while `remove` throws a `NoSuchElementException`.
*   **`peek()` vs. `element()`:** `peek` is also safer, returning `null` for an empty queue, while `element` throws `NoSuchElementException`.

**Common Implementations:**
*   **`LinkedList`:** We've already seen that `LinkedList` is a `List`, but it also implements the `Queue` interface. Its O(1) performance for adding to the tail and removing from the head makes it an excellent `Queue` implementation.
*   **`PriorityQueue`:** A specialized queue that does not order elements in FIFO order. Instead, it orders them based on priority.

##### **`PriorityQueue` - The Priority-Based Queue**

*   **Internal Structure:** A `PriorityQueue` is implemented as a **binary heap**, a specific type of binary tree that satisfies the heap property: every node is smaller than (or equal to, for min-heap) its children. Java's `PriorityQueue` is a **min-heap**, meaning the element with the *lowest* value has the highest priority and will be at the head of the queue.
*   **Ordering:** When you call `poll()`, you are guaranteed to get the smallest element in the queue according to its natural order (`Comparable`) or a `Comparator` provided at construction. The iteration order (`for-each` loop) is **not guaranteed** to be sorted.
*   **Performance:** `offer(e)` (add) and `poll()` (remove) operations are **O(log n)**. `peek()` is **O(1)**.
*   **Best Use Case:** Any scenario where you need to consistently process the "most important" item first, such as in task schedulers (processing the highest-priority task), pathfinding algorithms (like Dijkstra's, exploring the shortest path first), or event simulation.

##### **The `Deque` Interface**

A `Deque` (pronounced "deck") is a **"double-ended queue."** It extends the `Queue` interface but supports element insertion and removal at **both ends**. It can be used as both a FIFO queue and a LIFO stack.

*   **As a Queue (FIFO):** Use `addLast()` (or `offerLast()`) for insertion and `removeFirst()` (or `pollFirst()`) for removal.
*   **As a Stack (LIFO):** Use `addFirst()` (or `push()`) for insertion and `removeFirst()` (or `pop()`) for removal.

**Core `Deque` Methods:**

| End | Insert | Remove | Examine |
| :--- | :--- | :--- | :--- |
| **First (Head)** | `addFirst(e)`, `offerFirst(e)` | `removeFirst()`, `pollFirst()` | `getFirst()`, `peekFirst()` |
| **Last (Tail)** | `addLast(e)`, `offerLast(e)` | `removeLast()`, `pollLast()` | `getLast()`, `peekLast()` |

##### **`ArrayDeque` - The Go-To `Deque` and `Stack` Implementation**

*   **Internal Structure:** An `ArrayDeque` is backed by a **resizable circular array**. This clever structure allows it to provide O(1) average time complexity for adding and removing elements from both the head and the tail.
*   **Performance:** Amortized **O(1)** for all `add...` and `remove...` operations. It is more efficient than `LinkedList` for `Deque` operations because it doesn't have the overhead of node object creation.
*   **Best Practice:** `ArrayDeque` is the **preferred implementation for a `Stack`**. The legacy `Stack` class should be avoided. It is also the best choice for a general-purpose `Queue` if you don't need priority ordering.

---

#### **2. Example Code Snippet**

This example demonstrates the FIFO behavior of a queue, the LIFO behavior of a stack (using `ArrayDeque`), and the priority-based behavior of a `PriorityQueue`.

```java
import java.util.*;

public class QueueDequeDemo {
    public static void main(String[] args) {
        // --- 1. Queue (FIFO) using ArrayDeque ---
        System.out.println("--- Queue (FIFO) Demo ---");
        Queue<String> customerLine = new ArrayDeque<>();
        customerLine.offer("Alice");
        customerLine.offer("Bob");
        customerLine.offer("Charlie");
        System.out.println("Serving: " + customerLine.poll()); // Serves Alice
        System.out.println("Next in line: " + customerLine.peek()); // Bob
        System.out.println("Serving: " + customerLine.poll()); // Serves Bob
        System.out.println();

        // --- 2. Stack (LIFO) using ArrayDeque ---
        System.out.println("--- Stack (LIFO) Demo ---");
        Deque<String> browserHistory = new ArrayDeque<>();
        browserHistory.push("google.com"); // push() is addFirst()
        browserHistory.push("stackoverflow.com");
        browserHistory.push("github.com");
        System.out.println("Current page: " + browserHistory.peek()); // github.com
        System.out.println("Pressing back button: " + browserHistory.pop()); // pop() is removeFirst()
        System.out.println("Current page: " + browserHistory.peek()); // stackoverflow.com
        System.out.println();

        // --- 3. PriorityQueue Demo ---
        System.out.println("--- PriorityQueue Demo ---");
        // By default, it's a min-heap (lowest number = highest priority)
        Queue<Integer> taskPriorities = new PriorityQueue<>();
        taskPriorities.offer(5); // Low priority
        taskPriorities.offer(1); // High priority
        taskPriorities.offer(3); // Medium priority
        System.out.println("Processing highest priority task: " + taskPriorities.poll()); // Processes 1
        System.out.println("Processing next task: " + taskPriorities.poll()); // Processes 3
    }
}
```

---

#### **3. Mini Exercise**

You are tasked with reversing a string using a stack.
1.  Create an `ArrayDeque` to use as a stack.
2.  Iterate through the characters of a given string (e.g., "hello") and `push` each character onto the stack.
3.  Create a `StringBuilder`.
4.  While the stack is not empty, `pop` each character from the stack and append it to the `StringBuilder`.
5.  Print the `StringBuilder`'s content. The output should be the reversed string ("olleh").

---

#### **4. Quiz Question**

**Question:** You need a data structure to implement a LIFO stack. Which of the following is the modern, recommended choice in Java for its superior performance and design?

A) `java.util.Stack`
B) `java.util.Vector`
C) `java.util.LinkedList`
D) `java.util.ArrayDeque`

*(Scroll down for the answer)*

...

**Answer:** D) `java.util.ArrayDeque`. It is specifically designed for efficient stack (and queue) operations with its O(1) amortized complexity for push and pop. The legacy `Stack` class extends `Vector` and has performance issues due to synchronization. While `LinkedList` can be used as a stack, `ArrayDeque` is generally more efficient due to less memory overhead.

### **Lesson 7: Advanced Concepts - `Comparable` vs. `Comparator`**

#### **1. Concept Explanation**

In Java, ordering and sorting are fundamental operations, especially for collections like `TreeSet`, `TreeMap`, and when using `Collections.sort()` or `List.sort()`. The framework provides two primary interfaces to define sorting logic: `Comparable` and `Comparator`. Understanding the difference is crucial for controlling the order of your custom objects.

##### **`Comparable<T>` - For Natural Ordering**
*   **Interface:** `java.lang.Comparable<T>`
*   **Method:** It has a single method: `int compareTo(T other)`
*   **Purpose:** `Comparable` is used to define the **single, natural ordering** for a class. You implement this interface *directly in the class* whose objects you want to sort. This is the object's own, intrinsic sense of order.
*   **Analogy:** Think of `Comparable` as a person's height. Height is an intrinsic property. You can naturally order a group of people by their height without any external tool. `String`s are naturally ordered alphabetically. `Integer`s are naturally ordered numerically.
*   **`compareTo()` Contract:**
    *   Returns a **negative integer** if `this` object is *less than* the `other` object.
    *   Returns **zero** if `this` object is *equal to* the `other` object.
    *   Returns a **positive integer** if `this` object is *greater than* the `other` object.
*   **Usage:** Used by `TreeSet`, `TreeMap`, and sorting methods by default if no `Comparator` is specified.

##### **`Comparator<T>` - For Custom or External Ordering**
*   **Interface:** `java.util.Comparator<T>`
*   **Method:** It has a single abstract method: `int compare(T o1, T o2)` (and several default methods in Java 8+).
*   **Purpose:** `Comparator` is used to define **external, custom, or multiple different sorting strategies** for a class. You create a *separate class* that implements the `Comparator` interface. You do not modify the class of the objects you want to sort.
*   **Analogy:** Think of `Comparator` as a specific lens through which to view and order people. You could have a `Comparator` that orders people by age, another that orders them by last name, and a third that orders them by country of origin. The sorting logic is external to the `Person` object itself.
*   **`compare()` Contract:**
    *   Returns a **negative integer** if `o1` is *less than* `o2`.
    *   Returns **zero** if `o1` is *equal to* `o2`.
    *   Returns a **positive integer** if `o1` is *greater than* `o2`.
*   **Usage:** You pass an instance of your `Comparator` to the constructor of a `TreeSet`/`TreeMap` or to a `sort()` method.

##### **When to Use Which? A Clear Distinction**
*   Use **`Comparable`** when the sorting order is obvious, natural, and there is only one logical way to sort the objects (e.g., sorting `User` objects by their unique ID). Implement it directly in the `User` class.
*   Use **`Comparator`** when:
    *   You want to sort objects of a class that you cannot modify (e.g., a class from a third-party library).
    *   You need multiple different ways to sort the same type of object (e.g., sort `Employee`s by name, then by salary, then by hire date).
    *   You want to use a concise lambda expression for a one-off sorting task.

**Best Practice:** When implementing `compareTo`, it is a good practice to ensure that `x.compareTo(y) == 0` is consistent with `x.equals(y)`. While not strictly required, failing to do so can lead to surprising behavior in `Set`s and `Map`s. For example, a `TreeSet` uses `compareTo` to determine uniqueness, so if `compareTo` returns 0 for two unequal objects, the `TreeSet` will consider them duplicates and discard one.

---

#### **2. Example Code Snippet**

This example shows a `Movie` class that has a natural ordering by year (`Comparable`) and also provides several custom `Comparator`s for other sorting needs.

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

// The Movie class has a "natural order" by year (implements Comparable)
class Movie implements Comparable<Movie> {
    private final String title;
    private final int year;
    private final double rating;

    public Movie(String title, int year, double rating) {
        this.title = title;
        this.year = year;
        this.rating = rating;
    }

    public String getTitle() { return title; }
    public int getYear() { return year; }
    public double getRating() { return rating; }

    // Natural sorting order: by year, ascending
    @Override
    public int compareTo(Movie other) {
        return Integer.compare(this.year, other.year);
    }

    @Override
    public String toString() {
        return "Movie{" + "title='" + title + '\'' + ", year=" + year + ", rating=" + rating + '}';
    }
}

// A custom Comparator to sort by rating
class RatingComparator implements Comparator<Movie> {
    @Override
    public int compare(Movie m1, Movie m2) {
        return Double.compare(m2.getRating(), m1.getRating()); // Descending order
    }
}

public class SortingDemo {
    public static void main(String[] args) {
        List<Movie> movies = new ArrayList<>();
        movies.add(new Movie("The Godfather", 1972, 9.2));
        movies.add(new Movie("Parasite", 2019, 8.6));
        movies.add(new Movie("Inception", 2010, 8.8));

        // 1. Sort using the natural order (Comparable: by year)
        Collections.sort(movies);
        System.out.println("Sorted by year (natural order):");
        movies.forEach(System.out::println);

        // 2. Sort using a custom Comparator class (by rating)
        movies.sort(new RatingComparator()); // List.sort() is preferred since Java 8
        System.out.println("\nSorted by rating (Comparator):");
        movies.forEach(System.out::println);

        // 3. Sort using a lambda expression Comparator (by title) - Java 8+
        movies.sort((m1, m2) -> m1.getTitle().compareTo(m2.getTitle()));
        System.out.println("\nSorted by title (Lambda Comparator):");
        movies.forEach(System.out::println);
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a `Player` class with `name` (String) and `score` (int) fields.
2.  Implement `Comparable<Player>` to define the natural order as sorting by name alphabetically.
3.  Create a separate `PlayerScoreComparator` class that implements `Comparator<Player>` to sort players by their score in descending order (highest score first).
4.  In `main`, create a `List<Player>`, add a few players, and demonstrate that you can sort the list both by name (using the natural order) and by score (by passing an instance of your comparator).

---

#### **4. Quiz Question**

**Question:** You need to sort a `List<String>` by the length of the strings, from shortest to longest. Which is the most concise and modern way to achieve this?

A) Create a new `StringLength` class that extends `String` and implements `Comparable`.
B) Create a separate class `StringLengthComparator` that implements `Comparator<String>`.
C) Use `Collections.sort(list, (s1, s2) -> Integer.compare(s1.length(), s2.length()));`
D) It's not possible, as `String`'s natural order is alphabetical.

*(Scroll down for the answer)*

...

**Answer:** C) `Use Collections.sort(list, (s1, s2) -> Integer.compare(s1.length(), s2.length()));`. This uses a lambda expression to create an anonymous `Comparator` on the fly. It is the most concise and idiomatic way to perform a custom sort in modern Java. While B is also a correct way to do it, it is more verbose.

### **Lesson 8: Advanced Concepts - Fail-Fast vs. Fail-Safe Iterators**

#### **1. Concept Explanation**

When you iterate over a collection while it is being modified by another thread (or even the same thread), you can run into serious issues like inconsistent data or unpredictable behavior. Java's iterators have two main strategies for dealing with this problem: **Fail-Fast** and **Fail-Safe**.

##### **Fail-Fast Iterators**

*   **Behavior:** A fail-fast iterator throws a **`ConcurrentModificationException`** if the collection is structurally modified (i.e., elements are added or removed) at any time after the iterator is created, in any way except through the iterator's own `remove()` method.
*   **Mechanism:** Most standard collections in `java.util` (like `ArrayList`, `HashMap`, `HashSet`) use a simple mechanism to achieve this. The collection maintains an internal counter called `modCount` (modification count).
    1.  When an iterator is created, it records the current value of `modCount`.
    2.  On each operation (`next()`, `hasNext()`), the iterator checks if the collection's `modCount` is still the same as the value it recorded.
    3.  If the `modCount` has changed, the iterator knows another part of the code has modified the collection, and it immediately throws `ConcurrentModificationException`.
*   **"Best Effort" System:** It's important to know that this is **not a guaranteed mechanism**. It is a "best effort" check. The exception is thrown on a best-effort basis and should be used only to detect bugs during development, not for controlling application logic. There are scenarios where a modification can happen without the iterator noticing immediately.
*   **Which Collections?** `ArrayList`, `LinkedList`, `HashSet`, `HashMap`, and most other collections in the `java.util` package.

##### **Fail-Safe Iterators (or Weakly Consistent Iterators)**

*   **Behavior:** A fail-safe iterator does **not** throw `ConcurrentModificationException`. Instead, it works on a **clone or a snapshot** of the underlying collection.
*   **Mechanism:** When the iterator is created, it makes a copy of the collection's data structure. The iterator then traverses this copy.
    1.  Any modifications made to the original collection after the iterator is created are **not reflected** in the iterator's view. You will iterate over the state of the collection as it existed at the moment the iterator was created.
    2.  This approach consumes more memory because a copy of the collection is made.
*   **Consistency:** They are called "weakly consistent" because they guarantee they won't throw an exception, but they don't reflect the most up-to-date state of the collection.
*   **Which Collections?** Collections from the `java.util.concurrent` package, such as **`CopyOnWriteArrayList`**, **`CopyOnWriteArraySet`**, and the `keySet()` iterator of **`ConcurrentHashMap`**.

##### **Summary Comparison**

| Feature | Fail-Fast Iterator | Fail-Safe Iterator |
| :--- | :--- | :--- |
| **Exception** | Throws `ConcurrentModificationException` on concurrent modification. | Does not throw `ConcurrentModificationException`. |
| **Data View** | Operates directly on the collection. | Operates on a clone/snapshot of the collection. |
| **Consistency** | The view is up-to-date until an exception is thrown. | The view is a snapshot; it may not reflect recent changes. |
| **Memory Usage** | Low. No extra memory for the collection data. | High. Requires extra memory for the copy. |
| **Performance** | Faster, as it doesn't involve copying. | Slower to create due to the overhead of cloning. |
| **Found In** | `java.util` package (e.g., `ArrayList`, `HashMap`). | `java.util.concurrent` package (e.g., `CopyOnWriteArrayList`). |

---

#### **2. Example Code Snippet**

This example demonstrates the behavior of both types of iterators.

```java
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class IteratorDemo {
    public static void main(String[] args) {
        // --- 1. Fail-Fast Iterator Example ---
        System.out.println("--- Fail-Fast Demo (ArrayList) ---");
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("B");
        list.add("C");

        Iterator<String> failFastIterator = list.iterator();
        try {
            while (failFastIterator.hasNext()) {
                String element = failFastIterator.next();
                System.out.println(element);
                // This modification will cause the exception on the *next* call to hasNext() or next()
                if (element.equals("B")) {
                    list.remove("C"); // Structural modification
                }
            }
        } catch (java.util.ConcurrentModificationException e) {
            System.out.println("ERROR: ConcurrentModificationException was thrown!");
        }

        System.out.println("\n--- 2. Fail-Safe Iterator Example ---");
        List<String> concurrentList = new CopyOnWriteArrayList<>();
        concurrentList.add("X");
        concurrentList.add("Y");
        concurrentList.add("Z");

        Iterator<String> failSafeIterator = concurrentList.iterator();
        // The iterator is working on a snapshot taken when it was created: [X, Y, Z]
        while (failSafeIterator.hasNext()) {
            String element = failSafeIterator.next();
            System.out.println("Iterating over: " + element);
            // This modification affects the original list, but NOT the iterator's snapshot
            if (element.equals("Y")) {
                concurrentList.add("W");
            }
        }
        System.out.println("No exception was thrown.");
        System.out.println("Final state of the list: " + concurrentList); // [X, Y, Z, W]
    }
}
```

---

#### **3. Mini Exercise**

1.  Create a `HashMap<Integer, String>`.
2.  Add a few key-value pairs to it.
3.  Create an iterator for its `keySet()`.
4.  Start a `for-each` loop over the `keySet()` (which implicitly uses an iterator).
5.  Inside the loop, when a specific key is encountered, try to remove another key directly from the map using `map.remove()`.
6.  Wrap your loop in a `try-catch` block and verify that a `ConcurrentModificationException` is thrown, proving that `HashMap`'s iterators are fail-fast.

---

#### **4. Quiz Question**

**Question:** You are building a multi-threaded application where one thread frequently iterates over a list of listeners to send them notifications, while other threads can add or remove listeners from that same list at any time. Your primary requirement is to avoid `ConcurrentModificationException` at all costs, and you can tolerate the fact that a newly added listener might not receive a notification immediately. Which collection is the best fit for this scenario?

A) `ArrayList` wrapped with `Collections.synchronizedList()`
B) `LinkedList`
C) `Vector`
D) `CopyOnWriteArrayList`

*(Scroll down for the answer)*

...

**Answer:** D) `CopyOnWriteArrayList`. This is the exact use case for `CopyOnWriteArrayList`. Its fail-safe iterator guarantees that no `ConcurrentModificationException` will be thrown during iteration. The "copy-on-write" behavior ensures that writes (adding/removing listeners) do not interfere with the threads that are currently reading (iterating) the list. While A and C provide thread safety, their iterators are still fail-fast and would throw the exception in this scenario.

### **Lesson 9: Concurrent Collections**

#### **1. Concept Explanation**

The standard collection classes from `java.util` (like `ArrayList` and `HashMap`) are **not thread-safe**. If multiple threads access and modify such a collection concurrently, the collection's internal state can be corrupted, leading to data loss, incorrect results, or `ConcurrentModificationException`.

Java provides two primary strategies for handling collections in a multi-threaded environment: **synchronized wrappers** and the specialized collections in the **`java.util.concurrent` package**.

##### **Synchronized Wrappers (`Collections.synchronized...`)**

This is the older approach. The `Collections` utility class provides wrapper methods that can take any standard collection and return a thread-safe version of it.

*   **Methods:** `Collections.synchronizedList()`, `Collections.synchronizedSet()`, `Collections.synchronizedMap()`.
*   **Mechanism:** These wrappers achieve thread safety by decorating every single method of the collection with a `synchronized` block, locking on a single mutex (the collection object itself).
*   **The Problem (Poor Scalability):** This creates a major performance bottleneck. Only one thread can access the collection at any given time, for *any* operation (read or write). If you have many threads trying to read from the collection, they will all be blocked waiting for the single lock, even though read operations don't interfere with each other. This is called **low concurrency**.
*   **Compound Actions:** Furthermore, synchronization on individual methods is not enough to protect compound actions. Iterating over a synchronized collection is not safe unless you manually synchronize the entire iteration block.

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
// ... add elements ...

// THREAD-UNSAFE iteration
for (String item : list) {
    // Another thread could modify the list here, causing an exception
}

// THREAD-SAFE iteration (but blocks all other threads)
synchronized (list) {
    for (String item : list) {
        // ... safe operations ...
    }
}
```

##### **Concurrent Collections (`java.util.concurrent`)**

The `java.util.concurrent` package, introduced in Java 5, provides a set of high-performance collection classes designed specifically for concurrent access. They are the preferred choice in modern multi-threaded programming.

These collections use more sophisticated and granular locking mechanisms instead of a single exclusive lock, which allows for much higher concurrency and scalability.

##### **`ConcurrentHashMap` - The Scalable `Map`**

*   **Mechanism:** Instead of a single lock for the entire map, `ConcurrentHashMap` uses a technique called **lock striping** or **segmented locking**. The internal table is divided into segments (or, in modern implementations, the lock is placed on the first node of each bucket). A thread only needs to lock the specific segment/bucket it is writing to, allowing other threads to access other parts of the map concurrently.
*   **Read Operations:** Read operations (`get()`) are generally **non-blocking** and do not require locks at all, providing extremely high performance for read-heavy applications.
*   **Iterators:** The iterators are **weakly consistent** (fail-safe). They reflect the state of the map at some point since the iterator's creation and will not throw `ConcurrentModificationException`.
*   **Performance:** Offers vastly superior performance and scalability compared to `Hashtable` or a `synchronizedMap`. It is the default choice for a thread-safe map.

##### **`CopyOnWriteArrayList` - For Read-Heavy Scenarios**

*   **Mechanism:** As the name suggests, it implements a **"copy-on-write"** strategy.
    *   **Read Operations:** Reads are very fast as they operate on the existing, immutable backing array and require **no locks**.
    *   **Write Operations (`add`, `remove`):** Any modification is expensive. A **new copy** of the entire underlying array is created, the modification is made to the copy, and then the internal reference is atomically swapped to point to the new array.
*   **Iterators:** The iterators are **fail-safe snapshots**. They iterate over the array that existed at the moment the iterator was created.
*   **Best Use Case:** When you have a collection that is iterated over far more often than it is modified. A classic example is a list of listeners in an event-driven system.

##### **Concurrent Queues (`BlockingQueue`)**

The `java.util.concurrent` package also provides powerful `Queue` implementations that are central to many producer-consumer patterns.
*   **`BlockingQueue<E>` Interface:** An extension of `Queue` that provides blocking operations.
    *   `put(e)`: Waits until space becomes available in the queue to insert an element.
    *   `take()`: Waits until an element becomes available in the queue to retrieve it.
*   **Common Implementations:**
    *   **`LinkedBlockingQueue`:** An optionally bounded queue based on a linked list. Can have very high throughput.
    *   **`ArrayBlockingQueue`:** A fixed-size queue backed by an array. It's fair, meaning it grants access to threads in the order they were waiting.

---

#### **2. Example Code Snippet: `ConcurrentHashMap` vs. `synchronizedMap`**

This example simulates concurrent writes to both types of maps to highlight the performance difference (though the actual difference is most dramatic with many cores).

```java
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ConcurrentCollectionsDemo {

    public static void performWrites(Map<Integer, Integer> map) throws InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(10);
        long startTime = System.nanoTime();

        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                for (int j = 0; j < 100_000; j++) {
                    int key = (int) (Math.random() * 10000);
                    map.put(key, j);
                }
            });
        }
        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);

        long endTime = System.nanoTime();
        System.out.println("Time taken: " + (endTime - startTime) / 1_000_000 + " ms. Map size: " + map.size());
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println("--- Testing synchronizedMap ---");
        Map<Integer, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
        performWrites(syncMap);

        System.out.println("\n--- Testing ConcurrentHashMap ---");
        Map<Integer, Integer> concurrentMap = new ConcurrentHashMap<>();
        performWrites(concurrentMap);
    }
}
```

---

#### **3. Mini Exercise**

You need to implement a simple producer-consumer system.
1.  Create a `BlockingQueue<Integer>` with a fixed capacity of 10 (use `ArrayBlockingQueue`).
2.  Create a "producer" `Runnable` that generates 100 random integers and `put`s them onto the queue. It should print each number it produces. Add a small `Thread.sleep()` to simulate work.
3.  Create a "consumer" `Runnable` that loops 100 times, `take`s an integer from the queue, and prints it.
4.  Create two threads, one for the producer and one for the consumer, and start them. Observe how the `put` and `take` methods automatically block, coordinating the work between the two threads.

---

#### **4. Quiz Question**

**Question:** Which of the following is the most significant disadvantage of using `Collections.synchronizedList()` compared to `CopyOnWriteArrayList`?

A) `synchronizedList` does not allow null elements.
B) `synchronizedList` has a fail-safe iterator, which is less desirable.
C) `synchronizedList` uses a single lock for all operations, leading to poor concurrency and scalability, especially for reads.
D) `synchronizedList` is an older, deprecated API.

*(Scroll down for the answer)*

...

**Answer:** C) `synchronizedList` uses a single lock for all operations, leading to poor concurrency and scalability, especially for reads. The entire collection is locked for every operation, preventing multiple threads from even reading the list at the same time, whereas `CopyOnWriteArrayList` allows unlimited concurrent reads without any locking.

### **Lesson 10: Topic Summary, Interview Questions, and Final Project**

Congratulations on completing this in-depth tour of the Java Collections Framework. This final lesson will summarize the key data structures, present common interview questions to test your knowledge, and provide a mini-project to apply these concepts in a practical scenario.

---

#### **1. Summary Table of Major Collections**

| Interface | Class | Internal Structure | Ordering | Duplicates | Nulls | Thread Safety | Key Use Case |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **List** | `ArrayList` | Dynamic Array | Insertion | Allowed | Allowed | No | Fast random access; default `List`. |
| | `LinkedList` | Doubly-Linked List | Insertion | Allowed | Allowed | No | Frequent insertions/deletions. |
| **Set** | `HashSet` | `HashMap` | None | No | 1 key | No | Fastest unique element storage. |
| | `LinkedHashSet` | `HashMap` + List | Insertion | No | 1 key | No | Unique elements with predictable order. |
| | `TreeSet` | Red-Black Tree | Sorted | No | Not allowed | No | Unique, sorted elements. |
| **Queue** | `PriorityQueue` | Binary Heap | Priority | Allowed | Not allowed | No | Processing items by priority. |
| **Deque** | `ArrayDeque` | Circular Array | FIFO/LIFO | Allowed | Not allowed | No | Best for Stack/Queue implementation. |
| **Map** | `HashMap` | Hash Table | None | No (keys) | 1 null key | No | General purpose key-value storage. |
| | `LinkedHashMap` | Hash Table + List | Insertion | No (keys) | 1 null key | No | Ordered map, LRU caches. |
| | `TreeMap` | Red-Black Tree | Sorted | No (keys) | No null keys | No | Sorted map, range queries. |
| **Concurrent** | `ConcurrentHashMap`| Segmented Hash Table| None | No (keys) | Not allowed | Yes | High-performance thread-safe map. |
| **Concurrent** | `CopyOnWriteArrayList`| Immutable Array | Insertion | Allowed | Allowed | Yes | Read-heavy, concurrent list access. |

---

#### **2. Common Interview Questions**

1.  **"Explain the internal workings of a `HashMap`. What happens when a collision occurs?"**
    *   *Answer:* A `HashMap` is backed by an array of "buckets." When you `put` an element, it calculates the key's `hashCode()` to determine the bucket index. If the bucket is empty, a new `Node` is placed there. If the bucket is not empty (a collision), the keys in that bucket are checked using `equals()`. If an equal key is found, its value is updated. If not, the new `Node` is added to the end of a linked list at that bucket. Since Java 8, if this list grows beyond a certain threshold, it is converted into a balanced tree to improve worst-case performance from O(n) to O(log n).

2.  **"When would you choose an `ArrayList` over a `LinkedList`?"**
    *   *Answer:* Choose `ArrayList` when your primary use case is fast random access (using `get(index)`). Its array-based structure provides O(1) access. It's also efficient for adding/removing at the end of the list. Choose `LinkedList` when you have a high frequency of insertions and deletions in the middle of the list, as this is an O(1) operation for `LinkedList` (once the position is found) versus an expensive O(n) shifting operation for `ArrayList`.

3.  **"What is the difference between `HashSet`, `LinkedHashSet`, and `TreeSet`?"**
    *   *Answer:* All three are `Set`s and store unique elements. The key difference is ordering. `HashSet` offers the best performance (O(1)) but provides no order guarantees. `LinkedHashSet` provides O(1) performance and maintains the order in which elements were inserted. `TreeSet` is slightly slower (O(log n)) but keeps the elements in a constantly sorted order, defined by either their natural ordering (`Comparable`) or a custom `Comparator`.

4.  **"Explain the difference between `Comparable` and `Comparator`."**
    *   *Answer:* `Comparable` is used to define the *single, natural ordering* for a class. The class itself implements the `Comparable` interface. `Comparator` is used to define *external, custom, or multiple sorting strategies*. A separate class implements the `Comparator` interface. You use `Comparable` for the default sort order and `Comparator` when you need flexibility, multiple sort orders, or cannot modify the source code of the class you want to sort.

5.  **"Why is `ConcurrentHashMap` faster than a `Hashtable` or a `synchronizedMap`?"**
    *   *Answer:* `Hashtable` and `synchronizedMap` use a single lock for the entire collection. This means only one thread can access the map at a time, for any operation, causing high contention and poor scalability. `ConcurrentHashMap` uses a more intelligent locking mechanism (lock striping or per-bucket locking) that allows multiple threads to read and write to different parts of the map concurrently, leading to much higher throughput in multi-threaded applications.

---

#### **3. Final Mini-Project: Building a Leaderboard System**

This project will require you to select and use the right collections to build a system that tracks and displays player scores.

** Goal:** Create a `Leaderboard` class that can efficiently add new player scores and retrieve the top N players.

**Project Requirements:**

1.  **`PlayerScore` Class:**
    *   Create a class to hold a player's `playerId` (String) and `score` (int).
    *   This class must implement `Comparable`. The natural ordering should be by score in **descending order** (highest score first). If scores are equal, you can break ties alphabetically by `playerId`.
    *   Properly implement `equals()` and `hashCode()` based on the `playerId`.

2.  **`Leaderboard` Class:**
    *   The `Leaderboard` should store the scores. You need to choose the right collection(s) to meet the requirements.
    *   **Hint:** You will likely need two collections working together:
        *   One to provide fast updates and lookups for a player's score. What collection is best for `get(playerId)` and `put(playerId, newScore)`? A `Map` would be ideal.
        *   Another to keep the scores sorted at all times to easily retrieve the top players. What collection is best for this? A `TreeSet` or `PriorityQueue`.

3.  **`Leaderboard` Methods:**
    *   **`addOrUpdateScore(String playerId, int score)`:**
        *   If the player is new, add their score.
        *   If the player already exists, update their score only if the new score is higher than their old one. This method needs to be efficient.
    *   **`getTopPlayers(int n)`:**
        *   Efficiently return a `List` of the top `n` `PlayerScore` objects. This should be a fast operation.

4.  **Implementation Strategy:**
    *   Use a `Map<String, PlayerScore>` for fast lookups by `playerId`.
    *   Use a `TreeSet<PlayerScore>` to keep all the scores sorted.
    *   When updating a score, you must first remove the old `PlayerScore` object from the `TreeSet` and then add the new one, because a `TreeSet` cannot re-sort itself if you mutate an object that is already inside it.

**Example Usage:**`
```java
    public static void main(String[] args) {
    Leaderboard leaderboard = new Leaderboard();

    leaderboard.addOrUpdateScore("player1", 100);
    leaderboard.addOrUpdateScore("player2", 150);
    leaderboard.addOrUpdateScore("player3", 80);
    leaderboard.addOrUpdateScore("player1", 120); // Update player1's score

    System.out.println("Top 2 Players: " + leaderboard.getTopPlayers(2));
    // Expected Output might be: [PlayerScore{playerId='player2', score=150}, PlayerScore{playerId='player1', score=120}]
}
```

This project will challenge you to think critically about the performance and features of different collections and combine them to build an efficient and robust system.
